Index: psydac/linalg/stencil.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># coding: utf-8\n#\n# Copyright 2018 Yaman Güçlü\n\nimport os\nimport warnings\n\nimport numpy as np\n\nfrom types        import MappingProxyType\nfrom scipy.sparse import coo_matrix\nfrom mpi4py       import MPI\n\n\nfrom psydac.linalg.basic   import VectorSpace, Vector, Matrix\nfrom psydac.ddm.cart       import find_mpi_type, CartDecomposition, InterfaceCartDecomposition\nfrom psydac.ddm.utilities  import get_data_exchanger\nfrom .kernels              import *\n\n__all__ = ['StencilVectorSpace','StencilVector','StencilMatrix', 'StencilInterfaceMatrix']\n\n#===============================================================================\ndef compute_diag_len(pads, shifts_domain, shifts_codomain, return_padding=False):\n    \"\"\" Compute the diagonal length and the padding of the stencil matrix for each direction,\n        using the shifts of the domain and the codomain.\n\n        Parameters\n        ----------\n        pads : tuple-like (int)\n         Padding along each direction\n\n        shifts_domain : tuple_like (int)\n         Shifts of the domain along each direction\n\n        shifts_codomain : tuple_like (int)\n         Shifts of the codomain along each direction\n\n        return_padding : bool\n            Return the new padding if True\n    \n        Returns\n        -------\n        n : (int)\n         Diagonal length of the stencil matrix\n\n        ep : (int)\n          Padding that constitutes the starting index of the non zero elements \n    \"\"\"\n    n = ((np.ceil((pads+1)/shifts_codomain)-1)*shifts_domain).astype('int')\n    ep = -np.minimum(0, n-pads)\n    n = n+ep + pads+1\n    if return_padding:\n        return n.astype('int'), (ep).astype('int')\n    else:\n        return n.astype('int')\n\n#===============================================================================\nclass StencilVectorSpace( VectorSpace ):\n    \"\"\"\n    Vector space for n-dimensional stencil format. Two different initializations\n    are possible:\n\n    - serial  : StencilVectorSpace( npts, pads, periods, shifts=None, starts=None, ends=None, dtype=float )\n    - parallel: StencilVectorSpace( cart, dtype=float )\n\n    Parameters\n    ----------\n    npts : tuple-like (int)\n        Number of entries along each direction\n        (= global dimensions of vector space).\n\n    pads : tuple-like (int)\n        Padding p along each direction needed for the ghost regions.\n\n    periods : tuple-like (bool)\n        Periodicity along each direction.\n\n    shifts : tuple-like (int)\n        shift m of the coefficients in each direction.\n\n    starts : tuple-like (int)\n        Index of the first coefficient local to the space in each direction.\n\n    ends : tuple-like (int)\n        Index of the last coefficient local to the space in each direction.\n\n    dtype : type\n        Type of scalar entries.\n\n    cart : psydac.ddm.cart.CartDecomposition\n        Tensor-product grid decomposition according to MPI Cartesian topology.\n\n    \"\"\"\n\n    def __init__( self, cart, dtype=float ):\n\n        assert isinstance( cart, (CartDecomposition, InterfaceCartDecomposition) )\n\n        # Sequential attributes\n        self._parallel   = cart.is_parallel\n        self._cart       = cart\n        self._ndim       = cart._ndims\n        self._npts       = cart.npts\n        self._pads       = cart.pads\n        self._periods    = cart.periods\n        self._shifts     = cart.shifts\n        self._dtype      = dtype\n        self._starts     = cart.starts\n        self._ends       = cart.ends\n\n        # The shape of the allocated numpy array\n        self._shape         = cart.shape\n        self._parent_starts = cart.parent_starts\n        self._parent_ends   = cart.parent_ends\n        self._mpi_type      = find_mpi_type(dtype)\n\n        # The dictionary follows the structure {(axis, ext): StencilVectorSpace()}\n        # where axis and ext represent the boundary shared by two patches\n        self._interfaces    = {}\n        self._interfaces_readonly = MappingProxyType(self._interfaces)\n\n\n        # Parallel attributes\n        if cart.is_parallel and not cart.is_comm_null:\n            self._mpi_type      = find_mpi_type(dtype)\n            if isinstance(cart, InterfaceCartDecomposition):\n                self._shape = cart.get_interface_communication_infos(cart.axis)['gbuf_recv_shape'][0]\n            else:\n                self._synchronizer = get_data_exchanger( cart, dtype, assembly=True, blocking=False)\n    #--------------------------------------\n    # Abstract interface\n    #--------------------------------------\n    @property\n    def dimension( self ):\n        \"\"\" The dimension of a vector space V is the cardinality\n            (i.e. the number of vectors) of a basis of V over its base field.\n        \"\"\"\n        return np.prod( self._npts )\n\n    # ...\n    @property\n    def dtype( self ):\n        return self._dtype\n\n    # ...\n    def zeros( self ):\n        \"\"\"\n        Get a copy of the null element of the StencilVectorSpace V.\n\n        Returns\n        -------\n        null : StencilVector\n            A new vector object with all components equal to zero.\n\n        \"\"\"\n        return StencilVector( self )\n\n    #--------------------------------------\n    # Other properties/methods\n    #--------------------------------------\n    @property\n    def mpi_type( self ):\n        return self._mpi_type\n\n    @property\n    def shape( self ):\n        return self._shape\n\n    @property\n    def parallel( self ):\n        return self._parallel\n\n    # ...\n    @property\n    def cart( self ):\n        return self._cart\n\n    # ...\n    @property\n    def npts( self ):\n        return self._npts\n\n    # ...\n    @property\n    def starts( self ):\n        return self._starts\n\n    # ...\n    @property\n    def ends( self ):\n        return self._ends\n\n    # ...\n    @property\n    def parent_starts( self ):\n        return self._parent_starts\n\n    # ...\n    @property\n    def parent_ends( self ):\n        return self._parent_ends\n\n    # ...\n    @property\n    def pads( self ):\n        return self._pads\n\n    # ...\n    @property\n    def periods( self ):\n        return self._periods\n\n    # ...\n    @property\n    def shifts( self ):\n        return self._shifts\n\n    # ...\n    @property\n    def ndim( self ):\n        return self._ndim\n\n    @property\n    def interfaces( self ):\n        return self._interfaces_readonly\n\n    def set_interface(self, axis, ext, cart):\n\n        \"\"\" Set the interface space along a given axis and extremity.\n\n        Parameters\n        ----------\n         axis : int\n          The axis of the new Interface space.\n\n         ext: int\n          The extremity of the new Interface space.\n          the values must be 1 or -1.\n\n         cart: CartDecomposition\n          The cart of the new space.\n        \"\"\"\n\n        assert int(ext) in [-1,1]\n\n        # Create the interface space in the parallel case using the new cart\n        assert isinstance(cart, (CartDecomposition, InterfaceCartDecomposition))\n        if cart.is_comm_null: return\n        if isinstance(cart, InterfaceCartDecomposition):\n            # Case where the patches that share the interface are owned by different intra-communicators\n            space = StencilVectorSpace(cart)\n            self._interfaces[axis, ext] = space\n        else:\n            # Case where the patches that share the interface are owned by the same intra-communicator\n            if self.parent_ends[axis] is not None:\n                diff = min(1,self.parent_ends[axis]-self.ends[axis])\n            else:\n                diff = 0\n\n            starts = list(cart._starts)\n            ends   = list(cart._ends)\n            parent_starts = list(cart._parent_starts)\n            parent_ends   = list(cart._parent_ends)\n            if ext == 1:\n                starts[axis] = self.ends[axis]-self.pads[axis]+diff\n                if parent_starts[axis] is not None:\n                    parent_starts[axis] = parent_ends[axis]-self.pads[axis]\n            else:\n                ends[axis] = self.pads[axis]-diff\n                if parent_ends[axis] is not None:\n                    parent_ends[axis] = self.pads[axis]\n\n            cart = cart.change_starts_ends(starts, ends, parent_starts, parent_ends)\n            space = StencilVectorSpace(cart)\n\n            self._interfaces[axis, ext] = space\n\n#===============================================================================\nclass StencilVector( Vector ):\n    \"\"\"\n    Vector in n-dimensional stencil format.\n\n    Parameters\n    ----------\n    V : psydac.linalg.stencil.StencilVectorSpace\n        Space to which the new vector belongs.\n\n    \"\"\"\n    def __init__( self, V ):\n\n        assert isinstance( V, StencilVectorSpace )\n\n        self._space          = V\n        self._sizes          = V.shape\n        self._ndim           = len(V.npts)\n        self._data           = np.zeros( V.shape, dtype=V.dtype )\n        self._dot_send_data  = np.zeros((1,), dtype=V.dtype)\n        self._dot_recv_data  = np.zeros((1,), dtype=V.dtype)\n        self._interface_data = {}\n        self._requests       = None\n\n        # allocate data for the boundary that shares an interface\n        for axis, ext in V.interfaces:\n            self._interface_data[axis, ext] = np.zeros( V.interfaces[axis, ext].shape, dtype=V.dtype )\n\n        #prepare communications\n        if V.cart.is_parallel and not V.cart.is_comm_null and isinstance(V.cart, CartDecomposition):\n            self._requests = V._synchronizer.prepare_communications(self._data)\n\n        # TODO: distinguish between different directions\n        self._sync  = False\n\n    def __del__(self):\n        # Release memory of persistent MPI communication channels\n        if self._requests:\n            for request in self._requests:\n                request.Free()\n\n    #--------------------------------------\n    # Abstract interface\n    #--------------------------------------\n    @property\n    def space( self ):\n        return self._space\n\n    #...\n    @property\n    def dtype( self ):\n        return self.space.dtype\n\n    #...\n    def dot( self, v ):\n\n        assert isinstance( v, StencilVector )\n        assert v._space is self._space\n\n        if self._space.parallel:\n            self._dot_send_data[0] = self._dot(self._data, v._data , self.space.pads, self.space.shifts)\n            self._space.cart.global_comm.Allreduce((self._dot_send_data, self.space.mpi_type),\n                                                   (self._dot_recv_data, self.space.mpi_type),\n                                                   op=MPI.SUM )\n            return self._dot_recv_data[0]\n        else:\n            return self._dot(self._data, v._data , self.space.pads, self.space.shifts)\n\n    def vdot( self, v ):\n\n        assert isinstance( v, StencilVector )\n        assert v._space is self._space\n\n        if self._space.parallel:\n            self._dot_send_data[0] = self._dot(self._data.conjugate(), v._data , self.space.pads, self.space.shifts)\n            self._space.cart.global_comm.Allreduce((self._dot_send_data, self.space.mpi_type),\n                                                   (self._dot_recv_data, self.space.mpi_type),\n                                                   op=MPI.SUM )\n            return self._dot_recv_data[0]\n        else:\n            return self._dot(self._data.conjugate(), v._data , self.space.pads, self.space.shifts)\n\n    def conjugate(self):\n        w=self.copy()\n        w._data=self._data.conjugate()\n        return w\n\n    #...\n    @staticmethod\n    def _dot(v1, v2, pads, shifts):\n        index = tuple( slice(m*p,-m*p) for p,m in zip(pads, shifts))\n        return np.dot(v1[index].flat, v2[index].flat)\n\n    #...\n    def copy( self ):\n        w = StencilVector( self._space )\n        np.copyto(w._data, self._data, casting='no')\n        for axis, ext in self._space.interfaces:\n            np.copyto(w._interface_data[axis, ext], self._interface_data[axis, ext], casting='no')\n        w._sync    = self._sync\n        return w\n\n    #...\n    def __neg__( self ):\n        w = StencilVector( self._space )\n        np.negative(self._data, out=w._data)\n        for axis, ext in self._space.interfaces:\n            np.negative(self._interface_data[axis, ext], out=w._interface_data[axis, ext])\n        w._sync    =  self._sync\n        return w\n\n    #...\n    def __mul__( self, a ):\n        w = StencilVector( self._space )\n        np.multiply(self._data, a, out=w._data)\n        for axis, ext in self._space.interfaces:\n            np.multiply(self._interface_data[axis, ext], a, out =w._interface_data[axis, ext])\n        w._sync = self._sync\n        return w\n\n    #...\n    def __rmul__( self, a ):\n        w = StencilVector( self._space )\n        np.multiply(a, self._data, out=w._data)\n        for axis, ext in self._space.interfaces:\n            np.multiply(a,  self._interface_data[axis, ext], out=w._interface_data[axis, ext])\n        w._sync = self._sync\n        return w\n\n    #...\n    def __add__( self, v ):\n        assert isinstance( v, StencilVector )\n        assert v._space is self._space\n        w = StencilVector( self._space )\n        np.add(self._data, v._data, out=w._data)\n        for axis, ext in self._space.interfaces:\n            np.add(self._interface_data[axis, ext],  v._interface_data[axis, ext], out=w._interface_data[axis, ext])\n        w._sync = self._sync and v._sync\n        return w\n\n    #...\n    def __sub__( self, v ):\n        assert isinstance( v, StencilVector )\n        assert v._space is self._space\n        w = StencilVector( self._space )\n        np.subtract(self._data, v._data, out=w._data)\n        for axis, ext in self._space.interfaces:\n            np.subtract(self._interface_data[axis, ext],  v._interface_data[axis, ext], out=w._interface_data[axis, ext])\n        w._sync = self._sync and v._sync\n        return w\n\n    #...\n    def __imul__( self, a ):\n        self._data *= a\n        for axis, ext in self._space.interfaces:\n            self._interface_data[axis, ext] *= a\n        return self\n\n    #...\n    def __iadd__( self, v ):\n        assert isinstance( v, StencilVector )\n        assert v._space is self._space\n        self._data += v._data\n        for axis, ext in self._space.interfaces:\n            self._interface_data[axis, ext] += v._interface_data[axis, ext]\n        self._sync  = v._sync and self._sync\n        return self\n\n    #...\n    def __isub__( self, v ):\n        assert isinstance( v, StencilVector )\n        assert v._space is self._space\n        self._data -= v._data\n        for axis, ext in self._space.interfaces:\n            self._interface_data[axis, ext] -= v._interface_data[axis, ext]\n        self._sync  = v._sync and self._sync\n        return self\n\n    #--------------------------------------\n    # Other properties/methods\n    #--------------------------------------\n    @property\n    def starts(self):\n        return self._space.starts\n\n    # ...\n    @property\n    def ends(self):\n        return self._space.ends\n\n    # ...\n    @property\n    def pads(self):\n        return self._space.pads\n\n    # ...\n    def __str__(self):\n        txt  = '\\n'\n        txt += '> starts  :: {starts}\\n'.format( starts= self.starts )\n        txt += '> ends    :: {ends}\\n'  .format( ends  = self.ends   )\n        txt += '> pads    :: {pads}\\n'  .format( pads  = self.pads   )\n        txt += '> data    :: {data}\\n'  .format( data  = self._data  )\n        txt += '> sync    :: {sync}\\n'  .format( sync  = self._sync  )\n        return txt\n\n    # ...\n    def toarray( self, *, order='C', with_pads=False ):\n        \"\"\"\n        Return a numpy 1D array corresponding to the given StencilVector,\n        with or without pads.\n\n        Parameters\n        ----------\n        with_pads : bool\n            If True, include pads in output array.\n\n        order: {'C','F'}\n             Memory representation of the data ‘C’ for row-major ordering (C-style), ‘F’ column-major ordering (Fortran-style).\n\n        Returns\n        -------\n        array : numpy.ndarray\n            A copy of the data array collapsed into one dimension.\n\n        \"\"\"\n\n\n        # In parallel case, call different functions based on 'with_pads' flag\n        if self.space.parallel:\n            if with_pads:\n                return self._toarray_parallel_with_pads(order=order)\n            else:\n                return self._toarray_parallel_no_pads(order=order)\n\n        # In serial case, ignore 'with_pads' flag\n        return self.toarray_local(order=order)\n\n    # ...\n    def toarray_local( self , *, order='C'):\n        \"\"\" return the local array without the padding\"\"\"\n\n        idx = tuple( slice(m*p,-m*p) for p,m in zip(self.pads, self.space.shifts) )\n        return self._data[idx].flatten( order=order)\n\n    # ...\n    def _toarray_parallel_no_pads( self, order='C' ):\n        a         = np.zeros( self.space.npts, dtype=self.dtype)\n        idx_from  = tuple( slice(m*p,-m*p) for p,m in zip(self.pads, self.space.shifts) )\n        idx_to    = tuple( slice(s,e+1) for s,e in zip(self.starts,self.ends) )\n        a[idx_to] = self._data[idx_from]\n        return a.flatten( order=order)\n\n    # ...\n    def _toarray_parallel_with_pads( self, order='C' ):\n\n        pads = [m*p for m,p in zip(self.space.shifts, self.pads)]\n        # Step 0: create extended n-dimensional array with zero values\n        shape = tuple( n+2*p for n,p in zip( self.space.npts, pads ) )\n        a = np.zeros( shape, dtype=self.dtype )\n\n        # Step 1: write extended data chunk (local to process) onto array\n        idx = tuple( slice(s,e+2*p+1) for s,e,p in\n            zip( self.starts, self.ends, pads) )\n        a[idx] = self._data\n\n        # Step 2: if necessary, apply periodic boundary conditions to array\n        ndim = self.space.ndim\n\n        for direction in range( ndim ):\n\n            periodic = self.space.cart.periods[direction]\n            coord    = self.space.cart.coords [direction]\n            nproc    = self.space.cart.nprocs [direction]\n\n            if periodic:\n\n                p = pads[direction]\n\n                # Left-most process: copy data from left to right\n                if coord == 0:\n                    idx_from = tuple(\n                        (slice(None,p) if d == direction else slice(None))\n                        for d in range( ndim )\n                    )\n                    idx_to = tuple(\n                        (slice(-2*p,-p) if d == direction else slice(None))\n                        for d in range( ndim )\n                    )\n                    a[idx_to] = a[idx_from]\n\n                # Right-most process: copy data from right to left\n                if coord == nproc-1:\n                    idx_from = tuple(\n                        (slice(-p,None) if d == direction else slice(None))\n                        for d in range( ndim )\n                    )\n                    idx_to = tuple(\n                        (slice(p,2*p) if d == direction else slice(None))\n                        for d in range( ndim )\n                    )\n                    a[idx_to] = a[idx_from]\n\n        # Step 3: remove ghost regions from global array\n        idx = tuple( slice(p,-p) for p in pads )\n        out = a[idx]\n\n        # Step 4: return flattened array\n        return out.flatten( order=order)\n\n    def topetsc( self ):\n        \"\"\" Convert to petsc data structure.\n        \"\"\"\n        from psydac.linalg.topetsc import vec_topetsc\n        vec = vec_topetsc( self )\n        return vec\n\n    # ...\n    def __getitem__(self, key):\n        index = self._getindex( key )\n        return self._data[index]\n\n    # ...\n    def __setitem__(self, key, value):\n        index = self._getindex( key )\n        self._data[index] = value\n\n    # ...\n    @property\n    def ghost_regions_in_sync( self ):\n        return self._sync\n\n    # ...\n    # NOTE: this property must be set collectively\n    @ghost_regions_in_sync.setter\n    def ghost_regions_in_sync( self, value ):\n        assert isinstance( value, bool )\n        self._sync = value\n\n    # ...\n    # TODO: maybe change name to 'exchange'\n    def update_ghost_regions( self ):\n        \"\"\"\n        Update ghost regions before performing non-local access to vector\n        elements (e.g. in matrix-vector product).\n\n        Parameters\n        ----------\n        direction : int\n            Single direction along which to operate (if not specified, all of them).\n\n        \"\"\"\n\n        # Update interior ghost regions\n        if self.space.parallel:\n            if not self.space.cart.is_comm_null:\n                # PARALLEL CASE: fill in ghost regions with data from neighbors\n                self.space._synchronizer.start_update_ghost_regions( self._data, self._requests )\n                self.space._synchronizer.end_update_ghost_regions( self._data, self._requests )\n        else:\n            # SERIAL CASE: fill in ghost regions along periodic directions, otherwise set to zero\n            self._update_ghost_regions_serial()\n\n        # Update interface ghost regions\n        if self.space.parallel:\n\n            for axis, ext in self.space.interfaces:\n                V      = self.space.interfaces[axis, ext]\n                if isinstance(V.cart, InterfaceCartDecomposition):continue\n                slices = [slice(s, e+2*m*p+1) for s,e,m,p in zip(V.starts, V.ends, V.shifts, V.pads)]\n                self._interface_data[axis, ext][...] = self._data[tuple(slices)]\n        else:\n\n            for axis, ext in self.space.interfaces:\n                V      = self.space.interfaces[axis, ext]\n                slices = [slice(s, e+2*m*p+1) for s,e,m,p in zip(V.starts, V.ends, V.shifts, V.pads)]\n                self._interface_data[axis, ext][...] = self._data[tuple(slices)]\n\n        # Flag ghost regions as up-to-date\n        self._sync = True\n\n    # ...\n    def _update_ghost_regions_serial( self ):\n\n        ndim = self._space.ndim\n        for direction in range( ndim ):\n            periodic = self._space.periods[direction]\n            p        = self._space.pads   [direction]*self._space.shifts[direction]\n\n            idx_front = [slice(None)]*direction\n            idx_back  = [slice(None)]*(ndim-direction-1)\n\n            if periodic:\n                # Copy data from left to right\n                idx_from = tuple( idx_front + [slice( p, 2*p)] + idx_back )\n                idx_to   = tuple( idx_front + [slice(-p,None)] + idx_back )\n                self._data[idx_to] = self._data[idx_from]\n\n                # Copy data from right to left\n                idx_from = tuple( idx_front + [slice(-2*p,-p)] + idx_back )\n                idx_to   = tuple( idx_front + [slice(None, p)] + idx_back )\n                self._data[idx_to] = self._data[idx_from]\n\n            else:\n                # Set left ghost region to zero\n                idx_ghost = tuple( idx_front + [slice(None, p)] + idx_back )\n                self._data[idx_ghost] = 0\n\n                # Set right ghost region to zero\n                idx_ghost = tuple( idx_front + [slice(-p,None)] + idx_back )\n                self._data[idx_ghost] = 0\n\n    # ...\n    def exchange_assembly_data( self ):\n        \"\"\"\n        Exchange assembly data.\n        \"\"\"\n\n        if self.space.parallel and not self.space.cart.is_comm_null:\n            # PARALLEL CASE: fill in ghost regions with data from neighbors\n            self.space._synchronizer.start_exchange_assembly_data( self._data )\n            self.space._synchronizer.end_exchange_assembly_data( self._data )\n        else:\n            # SERIAL CASE: fill in ghost regions along periodic directions, otherwise set to zero\n            self._exchange_assembly_data_serial()\n\n        ndim     = self._space.ndim\n        for direction in range(ndim):\n            idx_front = [slice(None)]*direction\n            idx_back  = [slice(None)]*(ndim-direction-1)\n\n            p        = self._space.pads   [direction]\n            m        = self._space.shifts[direction]\n            idx_from = tuple( idx_front + [ slice(-m*p,None) if (-m*p+p)!=0 else slice(-m*p,None)] + idx_back )\n            self._data[idx_from] = 0.\n            idx_from = tuple( idx_front + [ slice(0,m*p)] + idx_back )\n            self._data[idx_from] = 0.\n    # ...\n    def _exchange_assembly_data_serial( self ):\n\n        ndim = self._space.ndim\n        for direction in range(ndim):\n\n            periodic = self._space.periods[direction]\n            p        = self._space.pads   [direction]\n            m        = self._space.shifts[direction]\n\n            if periodic:\n                idx_front = [slice(None)]*direction\n                idx_back  = [slice(None)]*(ndim-direction-1)\n\n                # Copy data from left to right\n                idx_to   = tuple( idx_front + [slice( m*p, m*p+p)] + idx_back )\n                idx_from = tuple( idx_front + [ slice(-m*p,-m*p+p) if (-m*p+p)!=0 else slice(-m*p,None)] + idx_back )\n                self._data[idx_to] += self._data[idx_from]\n\n    #--------------------------------------\n    # Private methods\n    #--------------------------------------\n    def _getindex( self, key ):\n\n        # TODO: check if we should ignore padding elements\n\n        if not isinstance( key, tuple ):\n            key = (key,)\n        index = []\n        for (i,s,p,m) in zip(key, self.starts, self.pads,self.space.shifts):\n            if isinstance(i, slice):\n                start = None if i.start is None else i.start - s + m*p\n                stop  = None if i.stop  is None else i.stop  - s + m*p\n                l = slice(start, stop, i.step)\n            else:\n                l = i - s + m*p\n            index.append(l)\n        return tuple(index)\n\n#===============================================================================\nclass StencilMatrix( Matrix ):\n    \"\"\"\n    Matrix in n-dimensional stencil format.\n\n    This is a linear operator that maps elements of stencil vector space V to\n    elements of stencil vector space W.\n\n    For now we only accept V==W.\n\n    Parameters\n    ----------\n    V : psydac.linalg.stencil.StencilVectorSpace\n        Domain of the new linear operator.\n\n    W : psydac.linalg.stencil.StencilVectorSpace\n        Codomain of the new linear operator.\n\n    \"\"\"\n    def __init__( self, V, W, pads=None , backend=None):\n\n        assert isinstance( V, StencilVectorSpace )\n        assert isinstance( W, StencilVectorSpace )\n        assert W.pads == V.pads\n\n        if pads is not None:\n            for p,vp in zip(pads, V.pads):\n                assert p<=vp\n\n        self._pads     = pads or tuple(V.pads)\n        dims           = list(W.shape)\n        diags          = [compute_diag_len(p, md, mc) for p,md,mc in zip(self._pads, V.shifts, W.shifts)]\n        self._data     = np.zeros( dims+diags, dtype=W.dtype )\n        self._domain   = V\n        self._codomain = W\n        self._ndim     = len( dims )\n        self._backend  = backend\n        self._is_T     = False\n        self._diag_indices = None\n        self._requests = None\n\n        # Parallel attributes\n        if W.parallel:\n            if W.cart.is_comm_null:return\n            # Create data exchanger for ghost regions\n            self._synchronizer = get_data_exchanger(\n                cart        = W.cart,\n                dtype       = W.dtype,\n                coeff_shape = diags,\n                assembly    = True\n            )\n\n        # Flag ghost regions as not up-to-date (conservative choice)\n        self._sync = False\n\n        # Prepare the arguments for the dot product method\n        nd  = [(ej-sj+2*gp*mj-mj*p-gp)//mj*mi+1 for sj,ej,mj,mi,p,gp in zip(V.starts, V.ends, V.shifts, W.shifts, self._pads, V.pads)]\n        nc  = [ei-si+1 for si,ei,mj,p in zip(W.starts, W.ends, V.shifts, self._pads)]\n\n        # Number of rows in matrix (along each dimension)\n        nrows        = [min(ni,nj) for ni,nj  in zip(nc, nd)]\n        nrows_extra  = [max(0,ni-nj) for ni,nj in zip(nc, nd)]\n\n        args                 = {}\n        args['starts']       = tuple(V.starts)\n        args['nrows']        = tuple(nrows)\n        args['nrows_extra']  = tuple(nrows_extra)\n        args['gpads']        = tuple(V.pads)\n        args['pads']         = tuple(self._pads)\n        args['dm']           = tuple(V.shifts)\n        args['cm']           = tuple(W.shifts)\n\n        self._dotargs_null = args\n        self._args         = args.copy()\n        self._func         = self._dot\n\n        self._transpose_args_null = self._prepare_transpose_args()\n        self._transpose_args      = self._transpose_args_null.copy()\n        self._transpose_func      = self._transpose\n\n        if backend is None:\n            backend = PSYDAC_BACKENDS.get(os.environ.get('PSYDAC_BACKEND'))\n\n        if backend:\n            self.set_backend(backend)\n\n\n    #--------------------------------------\n    # Abstract interface\n    #--------------------------------------\n    @property\n    def domain( self ):\n        return self._domain\n\n    # ...\n    @property\n    def codomain( self ):\n        return self._codomain\n\n    # ...\n    @property\n    def dtype( self ):\n        return self.domain.dtype\n\n    # ...\n    def dot( self, v, out=None):\n\n        assert isinstance( v, StencilVector )\n        assert v.space is self.domain\n\n        if out is not None:\n            assert isinstance( out, StencilVector )\n            assert out.space is self.codomain\n        else:\n            out = StencilVector( self.codomain )\n\n        # Necessary if vector space is distributed across processes\n        if not v.ghost_regions_in_sync:\n            v.update_ghost_regions()\n\n        self._func(self._data, v._data, out._data, **self._args)\n\n        # IMPORTANT: flag that ghost regions are not up-to-date\n        out.ghost_regions_in_sync = False\n        return out\n\n    # ...\n    @staticmethod\n    def _dot(mat, x, out, starts, nrows, nrows_extra, gpads, pads, dm, cm):\n\n        # Index for k=i-j\n        ndim = len(x.shape)\n        kk   = [slice(None)]*ndim\n\n        # pads are <= gpads\n        diff = [gp-p for gp,p in zip(gpads, pads)]\n\n        ndiags, _ = list(zip(*[compute_diag_len(p,mj,mi, return_padding=True) for p,mi,mj in zip(pads,cm,dm)]))\n\n        bb = [p*m+p+1-n-s%m for p,m,n,s in zip(gpads, dm, ndiags, starts)]\n\n        for xx in np.ndindex( *nrows ):\n\n            ii    = tuple( mi*pi + x for mi,pi,x in zip(cm, gpads, xx) )\n            jj    = tuple( slice(b-d+(x+s%mj)//mi*mj,b-d+(x+s%mj)//mi*mj+n) for x,mi,mj,b,s,n,d in zip(xx,cm,dm,bb,starts,ndiags,diff) )\n            ii_kk = tuple( list(ii) + kk )\n            out[ii] = np.dot( mat[ii_kk].flat, x[jj].flat )\n\n        new_nrows = list(nrows).copy()\n\n        for d,er in enumerate(nrows_extra):\n\n            rows = new_nrows.copy()\n            del rows[d]\n\n            for n in range(er):\n                for xx in np.ndindex(*rows):\n                    xx = list(xx)\n                    xx.insert(d, nrows[d]+n)\n\n                    ii     = tuple(mi*pi + x for mi,pi,x in zip(cm, gpads, xx))\n                    ee     = [max(x-l+1,0) for x,l in zip(xx, nrows)]\n                    jj     = tuple( slice(b-d+(x+s%mj)//mi*mj, b-d+(x+s%mj)//mi*mj+n-e) for x,mi,mj,d,e,b,s,n in zip(xx, cm, dm, diff, ee,bb,starts, ndiags) )\n                    kk     = [slice(None,n-e) for n,e in zip(ndiags, ee)]\n                    ii_kk  = tuple( list(ii) + kk )\n                    out[ii] = np.dot( mat[ii_kk].flat, x[jj].flat )\n\n            new_nrows[d] += er\n\n    # ...\n    def transpose( self ):\n        \"\"\" Create new StencilMatrix Mt, where domain and codomain are swapped\n            with respect to original matrix M, and Mt_{ij} = M_{ji}.\n        \"\"\"\n        # For clarity rename self\n        M = self\n\n        # If necessary, update ghost regions of original matrix M\n        if not M.ghost_regions_in_sync:\n            M.update_ghost_regions()\n\n        # Create new matrix where domain and codomain are swapped\n        Mt = StencilMatrix(M.codomain, M.domain, pads=self._pads, backend=self._backend)\n\n        # Call low-level '_transpose' function (works on Numpy arrays directly)\n        self._transpose_func(M._data, Mt._data, **self._transpose_args)\n        return Mt\n\n    @staticmethod\n    def _transpose( M, Mt, nrows, ncols, gpads, pads, dm, cm, ndiags, ndiagsT, si, sk, sl):\n\n        # NOTE:\n        #  . Array M  index by [i1, i2, ..., k1, k2, ...]\n        #  . Array Mt index by [j1, j2, ..., l1, l2, ...]\n\n        #M[i,j-i+p]\n        #Mt[j,i-j+p]\n\n        diff   = [gp-p for gp,p in zip(gpads, pads)]\n        for xx in np.ndindex( *nrows ):\n\n            jj = tuple(m*p + x for m,p,x in zip(dm, gpads, xx) )\n\n            for ll in np.ndindex( *ndiags ):\n\n                ii = tuple( s + mi*(x//mj) + l + d for mj,mi,x,l,d,s in zip(dm,cm, xx, ll, diff, si))\n\n                kk = tuple( s + x%mj-mj*(l//mi) for mj,mi,l,x,s in zip(dm, cm, ll, xx, sk))\n                ll = tuple(l+s for l,s in zip(ll, sl))\n\n                if all(k<n  and k>-1 for k,n in zip(kk,ndiagsT)) and\\\n                   all(l<n for l,n in zip(ll, ndiags)) and\\\n                   all(i<n for i,n in zip(ii, ncols)):\n                    Mt[(*jj, *ll)] = M[(*ii, *kk)]\n\n    # ...\n    def toarray( self, **kwargs ):\n        \"\"\" Convert to Numpy 2D array. \"\"\"\n\n        order     = kwargs.pop('order', 'C')\n        with_pads = kwargs.pop('with_pads', False)\n\n        if self.codomain.parallel and with_pads:\n            coo = self._tocoo_parallel_with_pads(order=order)\n        else:\n            coo = self._tocoo_no_pads(order=order)\n\n        return coo.toarray()\n\n    # ...\n    def tosparse( self, **kwargs ):\n        \"\"\" Convert to any Scipy sparse matrix format. \"\"\"\n\n        order     = kwargs.pop('order', 'C')\n        with_pads = kwargs.pop('with_pads', False)\n\n        if self.codomain.parallel and with_pads:\n            coo = self._tocoo_parallel_with_pads(order=order)\n        else:\n            coo = self._tocoo_no_pads(order=order)\n\n        return coo\n\n    #--------------------------------------\n    # Other properties/methods\n    #--------------------------------------\n\n    # ...\n    @property\n    def pads( self ):\n        return self._pads\n\n    # ...\n    @property\n    def backend( self ):\n        return self._backend\n\n    # ...\n    def __getitem__(self, key):\n        index = self._getindex( key )\n        return self._data[index]\n\n    # ...\n    def __setitem__(self, key, value):\n        index = self._getindex( key )\n        self._data[index] = value\n\n\n    #...\n    def max( self ):\n        return self._data.max()\n\n    #...\n    def copy( self ):\n        M = StencilMatrix( self.domain, self.codomain, self._pads, self._backend )\n        M._data[:] = self._data[:]\n        M._func    = self._func\n        M._args    = self._args\n        return M\n\n    #...\n    def __mul__( self, a ):\n        w = StencilMatrix( self._domain, self._codomain, self._pads, self._backend )\n        w._data = self._data * a\n        w._func = self._func\n        w._args = self._args\n        w._sync = self._sync\n        return w\n\n    #...\n    def __rmul__( self, a ):\n        w = StencilMatrix( self._domain, self._codomain, self._pads, self._backend )\n        w._data = a * self._data\n        w._func = self._func\n        w._args = self._args\n        w._sync = self._sync\n        return w\n\n    # ...\n    def __neg__(self):\n        return self.__mul__(-1)\n\n    #...\n    def __add__(self, m):\n        assert isinstance(m, StencilMatrix)\n        assert m._domain   is self._domain\n        assert m._codomain is self._codomain\n        assert m._pads     == self._pads\n\n        if m._backend is not self._backend:\n            msg = 'Adding two matrices with different backends is ambiguous - defaulting to backend of first addend'\n            warnings.warn(msg, category=RuntimeWarning)\n        \n        w = StencilMatrix(self._domain, self._codomain, self._pads, self._backend)\n        w._data = self._data  +  m._data\n        w._func = self._func\n        w._args = self._args\n        w._sync = self._sync and m._sync\n        return w\n\n    #...\n    def __sub__(self, m):\n        assert isinstance(m, StencilMatrix)\n        assert m._domain   is self._domain\n        assert m._codomain is self._codomain\n        assert m._pads     == self._pads\n\n        if m._backend is not self._backend:\n            msg = 'Subtracting two matrices with different backends is ambiguous - defaulting to backend of the matrix we subtract from'\n            warnings.warn(msg, category=RuntimeWarning)\n\n        w = StencilMatrix(self._domain, self._codomain, self._pads, self._backend)\n        w._data = self._data  -  m._data\n        w._func = self._func\n        w._args = self._args\n        w._sync = self._sync and m._sync\n        return w\n\n    #...\n    def __imul__(self, a):\n        self._data *= a\n        return self\n\n    #...\n    def __iadd__(self, m):\n        assert isinstance(m, StencilMatrix)\n        assert m._domain   is self._domain\n        assert m._codomain is self._codomain\n        assert m._pads     == self._pads\n        self._data += m._data\n        self._sync  = m._sync and self._sync\n        return self\n\n    #...\n    def __isub__(self, m):\n        assert isinstance(m, StencilMatrix)\n        assert m._domain   is self._domain\n        assert m._codomain is self._codomain\n        assert m._pads     == self._pads\n        self._data -= m._data\n        self._sync  = m._sync and self._sync\n        return self\n\n    #...\n    def __abs__( self ):\n        w = StencilMatrix( self._domain, self._codomain, self._pads, self._backend )\n        w._data = abs(self._data)\n        w._func = self._func\n        w._args = self._args\n        w._sync = self._sync\n        return w\n\n    #...\n    def remove_spurious_entries( self ):\n        \"\"\"\n        If any dimension is NOT periodic, make sure that the corresponding\n        periodic corners are set to zero.\n\n        \"\"\"\n        # TODO: access 'self._data' directly for increased efficiency\n        # TODO: add unit tests\n\n        ndim  = self._domain.ndim\n\n        for direction in range(ndim):\n\n            periodic = self._domain.periods[direction]\n\n            if not periodic:\n\n                nc = self._codomain.npts[direction]\n                nd = self._domain.npts[direction]\n\n                s = self._codomain.starts[direction]\n                e = self._codomain.ends  [direction]\n                p = self.pads  [direction]\n\n                idx_front = [slice(None)]*direction\n                idx_back  = [slice(None)]*(ndim-direction-1)\n\n                # Top-right corner\n                for i in range( max(0,s), min(p,e+1) ):\n                    index = tuple( idx_front + [i]            + idx_back +\n                                   idx_front + [slice(-p,-i)] + idx_back )\n                    self[index] = 0\n\n                # Bottom-left corner\n                for i in range( max(nd-p,s), min(nc,e+1) ):\n                    index = tuple( idx_front + [i]               + idx_back +\n                                   idx_front + [slice(nd-i,p+1)] + idx_back )\n                    self[index] = 0\n\n    # ...\n    def update_ghost_regions( self ):\n        \"\"\"\n        Update ghost regions before performing non-local access to matrix\n        elements (e.g. in matrix transposition).\n        \"\"\"\n        ndim     = self._codomain.ndim\n        parallel = self._codomain.parallel\n\n        if parallel:\n            if not self._codomain.cart.is_comm_null:\n                # PARALLEL CASE: fill in ghost regions with data from neighbors\n                self._synchronizer.start_update_ghost_regions( self._data, self._requests )\n                self._synchronizer.end_update_ghost_regions( self._data , self._requests)\n        else:\n            # SERIAL CASE: fill in ghost regions along periodic directions, otherwise set to zero\n            self._update_ghost_regions_serial()\n\n        # Flag ghost regions as up-to-date\n        self._sync = True\n\n    # ...\n    def exchange_assembly_data( self ):\n        \"\"\"\n        Exchange assembly data.\n        \"\"\"\n        ndim     = self._codomain.ndim\n        parallel = self._codomain.parallel\n\n        if self._codomain.parallel:\n            # PARALLEL CASE: fill in ghost regions with data from neighbors\n            self._synchronizer.start_exchange_assembly_data( self._data )\n            self._synchronizer.end_exchange_assembly_data( self._data )\n        else:\n            # SERIAL CASE: fill in ghost regions along periodic directions, otherwise set to zero\n            self._exchange_assembly_data_serial()\n\n        ndim = self._codomain.ndim\n        for direction in range(ndim):\n            idx_front = [slice(None)]*direction\n            idx_back  = [slice(None)]*(ndim-direction-1)\n\n            p        = self._codomain.pads   [direction]\n            m        = self._codomain.shifts[direction]\n            idx_from = tuple( idx_front + [ slice(-m*p,None) if (-m*p+p)!=0 else slice(-m*p,None)] + idx_back )\n            self._data[idx_from] = 0.\n            idx_from = tuple( idx_front + [ slice(0,m*p)] + idx_back )\n            self._data[idx_from] = 0.\n\n    # ...\n    def _exchange_assembly_data_serial( self ):\n\n        ndim     = self._codomain.ndim\n        for direction in range(ndim):\n\n            periodic = self._codomain.periods[direction]\n            p        = self._codomain.pads   [direction]\n            m        = self._codomain.shifts[direction]\n\n            if periodic:\n                idx_front = [slice(None)]*direction\n                idx_back  = [slice(None)]*(ndim-direction-1)\n\n                # Copy data from left to right\n                idx_to   = tuple( idx_front + [slice( m*p, m*p+p)] + idx_back )\n                idx_from = tuple( idx_front + [ slice(-m*p,-m*p+p) if (-m*p+p)!=0 else slice(-m*p,None)] + idx_back )\n                self._data[idx_to] += self._data[idx_from]\n\n    # ...\n    @property\n    def T(self):\n        return self.transpose()\n\n    def diagonal(self):\n        if self._diag_indices is None:\n            cm    = self.codomain.shifts\n            dm    = self.domain.shifts\n            ss    = self.codomain.starts\n            pp    = [compute_diag_len(p,mj,mi)-(p+1) for p,mi,mj in zip(self._pads, cm, dm)]\n            nrows = tuple(e-s+1 for s,e in zip(self.codomain.starts, self.codomain.ends))\n            indices = [np.zeros(np.product(nrows), dtype=int) for _ in range(2*len(nrows))]\n            l = 0\n            for xx in np.ndindex(*nrows):\n                ii = [m*p+x for m,p,x in zip(self.domain.shifts, self.domain.pads, xx)]\n                jj = [p+x+s-((x+s)//mi)*mj for (x,mi,mj,p,s) in zip(xx,cm,dm,pp,ss)]\n                for k in range(len(nrows)):\n                    indices[k][l] = ii[k]\n                    indices[k+len(nrows)][l] = jj[k]\n                l += 1\n            self._diag_indices = tuple(indices)\n        else:\n            nrows   = tuple(e-s+1 for s,e in zip(self.codomain.starts, self.codomain.ends))\n\n        return self._data[self._diag_indices].reshape(nrows)\n\n    # ...\n    def topetsc( self ):\n        \"\"\" Convert to petsc data structure.\n        \"\"\"\n        from psydac.linalg.topetsc import mat_topetsc\n        mat = mat_topetsc( self )\n        return mat\n\n    #--------------------------------------\n    # Private methods\n    #--------------------------------------\n\n    # ...\n    def _getindex( self, key ):\n\n        nd = self._ndim\n        ii = key[:nd]\n        kk = key[nd:]\n\n        index = []\n\n        for i,s,p,m in zip( ii, self._codomain.starts, self._codomain.pads, self._codomain.shifts ):\n            x = self._shift_index( i, m*p-s )\n            index.append( x )\n\n        for k,p in zip( kk, self._pads ):\n            l = self._shift_index( k, p )\n            index.append( l )\n        return tuple(index)\n\n    # ...\n    @staticmethod\n    def _shift_index( index, shift ):\n        if isinstance( index, slice ):\n            start = None if index.start is None else index.start + shift\n            stop  = None if index.stop  is None else index.stop  + shift\n            return slice(start, stop, index.step)\n        else:\n            return index + shift\n\n    def tocoo_local( self, order='C' ):\n\n        # Shortcuts\n        sc = self._codomain.starts\n        ec = self._codomain.ends\n        pc = self._codomain.pads\n\n        sd = self._domain.starts\n        ed = self._domain.ends\n        pd = self._domain.pads\n\n        nd = self._ndim\n\n        nr = [e-s+1 +2*p for s,e,p in zip(sc, ec, pc)]\n        nc = [e-s+1 +2*p for s,e,p in zip(sd, ed, pd)]\n\n        ravel_multi_index = np.ravel_multi_index\n\n        # COO storage\n        rows = []\n        cols = []\n        data = []\n\n        local = tuple( [slice(p,-p) for p in pc] + [slice(None)] * nd )\n\n        dd = [pdi-ppi for pdi,ppi in zip(pd, self._pads)]\n\n        for (index, value) in np.ndenumerate( self._data[local] ):\n\n            # index = [i1-s1, i2-s2, ..., p1+j1-i1, p2+j2-i2, ...]\n\n            xx = index[:nd]  # ii is local\n            ll = index[nd:]  # l=p+k\n\n            ii = [x+p for x,p in zip(xx, pc)]\n            jj = [(l+i+d)%n for (i,l,d,n) in zip(xx,ll,dd,nc)]\n\n            I = ravel_multi_index( ii, dims=nr,  order=order )\n            J = ravel_multi_index( jj, dims=nc,  order=order )\n\n            rows.append( I )\n            cols.append( J )\n            data.append( value )\n\n        M = coo_matrix(\n                (data,(rows,cols)),\n                shape = [np.prod(nr),np.prod(nc)],\n                dtype = self._domain.dtype\n        )\n\n        M.eliminate_zeros()\n\n        return M\n    #...\n    def _tocoo_no_pads( self , order='C'):\n\n        # Shortcuts\n        nr    = self._codomain.npts\n        nd    = self._ndim\n        nc    = self._domain.npts\n        ss    = self._codomain.starts\n        cpads = self._codomain.pads\n        dm    = self._domain.shifts\n        cm    = self._codomain.shifts\n\n        pp = [np.int64(compute_diag_len(p,mj,mi)-(p+1)) for p,mi,mj in zip(self._pads, cm, dm)]\n\n        # Range of data owned by local process (no ghost regions)\n        local = tuple( [slice(mi*p,-mi*p) for p,mi in zip(cpads, cm)] + [slice(None)] * nd )\n        size  = self._data[local].size\n\n        # COO storage\n        rows = np.zeros(size, dtype='int64')\n        cols = np.zeros(size, dtype='int64')\n        data = np.zeros(size, dtype=self.dtype)\n        nrl = [np.int64(e-s+1) for s,e in zip(self.codomain.starts, self.codomain.ends)]\n        ncl = [np.int64(i) for i in self._data.shape[nd:]]\n        ss = [np.int64(i) for i in ss]\n        nr = [np.int64(i) for i in nr]\n        nc = [np.int64(i) for i in nc]\n        dm = [np.int64(i) for i in dm]\n        cm = [np.int64(i) for i in cm]\n        cpads = [np.int64(i) for i in cpads]\n        pp = [np.int64(i) for i in pp]\n\n        func        = 'stencil2coo_{dim}d_{order}'.format(dim=nd, order=order)\n        stencil2coo = eval(func)\n\n        ind = stencil2coo(self._data, data, rows, cols, *nrl, *ncl, *ss, *nr, *nc, *dm, *cm, *cpads, *pp)\n        M = coo_matrix(\n                (data[:ind],(rows[:ind],cols[:ind])),\n                shape = [np.prod(nr),np.prod(nc)],\n                dtype = self.dtype)\n        return M\n\n    #...\n    def _tocoo_parallel_with_pads( self , order='C'):\n\n        # If necessary, update ghost regions\n        if not self.ghost_regions_in_sync:\n            self.update_ghost_regions()\n\n        # Shortcuts\n        nr = self._codomain.npts\n        nc = self._domain.npts\n        nd = self._ndim\n\n        ss = self._codomain.starts\n        ee = self._codomain.ends\n        pp = self._pads\n        pc = self._codomain.pads\n        pd = self._domain.pads\n        cc = self._codomain.periods\n\n        ravel_multi_index = np.ravel_multi_index\n\n        # COO storage\n        rows = []\n        cols = []\n        data = []\n\n        # List of rows (to avoid duplicate updates)\n        I_list = []\n\n        # Shape of row and diagonal spaces\n        xx_dims = self._data.shape[:nd]\n        ll_dims = self._data.shape[nd:]\n\n        # Cycle over rows (x = p + i - s)\n        for xx in np.ndindex( *xx_dims ):\n\n            # Compute row multi-index with simple shift\n            ii = [s + x - p for (s, x, p) in zip(ss, xx, pc)]\n\n            # Apply periodicity where appropriate\n            ii = [i - n if (c and i >= n and i - n < s) else\n                  i + n if (c and i <  0 and i + n > e) else i\n                  for (i, s, e, n, c) in zip(ii, ss, ee, nr, cc)]\n\n            # Compute row flat index\n            # Exclude values outside global limits of matrix\n            try:\n                I = ravel_multi_index( ii, dims=nr,  order=order )\n            except ValueError:\n                continue\n\n            # If I is a new row, append it to list of rows\n            # DO NOT update same row twice!\n            if I not in I_list:\n                I_list.append( I )\n            else:\n                continue\n\n            # Cycle over diagonals (l = p + k)\n            for ll in np.ndindex( *ll_dims ):\n\n                # Compute column multi-index (k = j - i)\n                jj = [(i+l-p) % n for (i,l,n,p) in zip(ii,ll,nc,pp)]\n\n                # Compute column flat index\n                J = ravel_multi_index( jj, dims=nc,  order=order )\n\n                # Extract matrix value\n                value = self._data[(*xx, *ll)]\n\n                # Append information to COO arrays\n                rows.append( I )\n                cols.append( J )\n                data.append( value )\n\n        # Create Scipy COO matrix\n        M = coo_matrix(\n                (data,(rows,cols)),\n                shape = [np.prod(nr), np.prod(nc)],\n                dtype = self._domain.dtype\n        )\n\n        M.eliminate_zeros()\n\n        return M\n\n    # ...\n    @property\n    def ghost_regions_in_sync( self ):\n        return self._sync\n\n    # ...\n    # NOTE: this property must be set collectively\n    @ghost_regions_in_sync.setter\n    def ghost_regions_in_sync( self, value ):\n        assert isinstance( value, bool )\n        self._sync = value\n\n    # ...\n    def _update_ghost_regions_serial( self ):\n\n        ndim     = self._codomain.ndim\n        for direction in range( self._codomain.ndim ):\n\n            periodic = self._codomain.periods[direction]\n            p        = self._codomain.pads   [direction]\n\n            idx_front = [slice(None)]*direction\n            idx_back  = [slice(None)]*(ndim-direction-1 + ndim)\n\n            if periodic:\n\n                # Copy data from left to right\n                idx_from = tuple( idx_front + [slice( p, 2*p)] + idx_back )\n                idx_to   = tuple( idx_front + [slice(-p,None)] + idx_back )\n                self._data[idx_to] = self._data[idx_from]\n\n                # Copy data from right to left\n                idx_from = tuple( idx_front + [slice(-2*p,-p)] + idx_back )\n                idx_to   = tuple( idx_front + [slice(None, p)] + idx_back )\n                self._data[idx_to] = self._data[idx_from]\n\n            else:\n\n                # Set left ghost region to zero\n                idx_ghost = tuple( idx_front + [slice(None, p)] + idx_back )\n                self._data[idx_ghost] = 0\n\n                # Set right ghost region to zero\n                idx_ghost = tuple( idx_front + [slice(-p,None)] + idx_back )\n                self._data[idx_ghost] = 0\n\n    # ...\n    def _prepare_transpose_args(self):\n\n        #prepare the arguments for the transpose method\n        V     = self.domain\n        W     = self.codomain\n        ssc   = W.starts\n        eec   = W.ends\n        ssd   = V.starts\n        eed   = V.ends\n        pads    = self._pads\n        gpads = V.pads\n\n        dm    = V.shifts\n        cm    = W.shifts\n\n        # Number of rows in the transposed matrix (along each dimension)\n        nrows       = [e-s+1 for s,e in zip(ssd, eed)]\n        ncols       = [e-s+2*m*p+1 for s,e,m,p in zip(ssc, eec, cm, gpads)]\n\n        pp = pads\n        ndiags, starts = list(zip(*[compute_diag_len(p,mi,mj, return_padding=True) for p,mi,mj in zip(pp,cm,dm)]))\n        ndiagsT, _     = list(zip(*[compute_diag_len(p,mj,mi, return_padding=True) for p,mi,mj in zip(pp,cm,dm)]))\n\n        diff   = [gp-p for gp,p in zip(gpads, pp)]\n\n        sl   = [(s if mi>mj else 0) + (s%mi+mi//mj if mi<mj else 0)+(s if mi==mj else 0)\\\n                 for s,p,mi,mj in zip(starts,pp,cm,dm)]\n\n        si   = [(mi*p-mi*(int(np.ceil((p+1)/mj))-1) if mi>mj else 0)+\\\n                 (mi*p-mi*(p//mi)+ d*(mi-1) if mi<mj else 0)+\\\n                 (mj*p-mj*(p//mi)+ d*(mi-1) if mi==mj else 0)\\\n                  for mi,mj,p,d in zip(cm, dm, pp, diff)]\n\n        sk   = [n-1\\\n                 + (-(p%mj) if mi>mj else 0)\\\n                 + (-p+mj*(p//mi) if mi<mj  else 0)\\\n                 + (-p+mj*(p//mi) if mi==mj else 0)\\\n                 for mi,mj,n,p in zip(cm, dm, ndiagsT, pp)]\n\n        args = {}\n        args['nrows']   = tuple(nrows)\n        args['ncols']   = tuple(ncols)\n        args['gpads']   = tuple(gpads)\n        args['pads']    = tuple(pads)\n        args['dm']      = tuple(dm)\n        args['cm']      = tuple(cm)\n        args['ndiags']  = tuple(ndiags)\n        args['ndiagsT'] = tuple(ndiagsT)\n        args['si']      = tuple(si)\n        args['sk']      = tuple(sk)\n        args['sl']      = tuple(sl)\n        return args\n\n    # ...\n    def set_backend(self, backend):\n        from psydac.api.ast.linalg import LinearOperatorDot, TransposeOperator\n        self._backend         = backend\n        self._args            = self._dotargs_null.copy()\n        self._transpose_args  = self._transpose_args_null.copy()\n\n        if self._backend is None:\n            self._func           = self._dot\n            self._transpose_func = self._transpose\n        else:\n            transpose = TransposeOperator(self._ndim, backend=frozenset(backend.items()))\n            self._transpose_func = transpose.func\n\n            nrows   = self._transpose_args.pop('nrows')\n            ncols   = self._transpose_args.pop('ncols')\n            gpads   = self._transpose_args.pop('gpads')\n            pads    = self._transpose_args.pop('pads')\n            dm      = self._transpose_args.pop('dm')\n            cm      = self._transpose_args.pop('cm')\n            ndiags  = self._transpose_args.pop('ndiags')\n            ndiagsT = self._transpose_args.pop('ndiagsT')\n            si      = self._transpose_args.pop('si')\n            sk      = self._transpose_args.pop('sk')\n            sl      = self._transpose_args.pop('sl')\n\n            args = dict([('n{i}',nrows),('nc{i}', ncols),('gp{i}', gpads),('p{i}',pads ),\n                                ('dm{i}', dm),('cm{i}', cm),('nd{i}', ndiags),\n                                ('ndT{i}', ndiagsT),('si{i}', si),('sk{i}', sk),('sl{i}', sl)])\n\n            for arg_name, arg_val in args.items():\n                for i in range(len(nrows)):\n                    self._transpose_args[arg_name.format(i=i+1)] = np.int64(arg_val[i]) if isinstance(arg_val[i], int) else arg_val[i]\n\n            if self.domain.parallel:\n                comm = self.codomain.cart.comm\n                if self.domain == self.codomain:\n                    # In this case nrows_extra[i] == 0 for all i\n                    dot = LinearOperatorDot(self._ndim,\n                                    block_shape = (1,1),\n                                    keys = ((0,0),),\n                                    comm = comm,\n                                    backend=frozenset(backend.items()),\n                                    nrows_extra = (self._args['nrows_extra'],),\n                                    gpads=(self._args['gpads'],),\n                                    pads=(self._args['pads'],),\n                                    dm = (self._args['dm'],),\n                                    cm = (self._args['cm'],))\n\n                    starts = self._args.pop('starts')\n                    nrows  = self._args.pop('nrows')\n\n                    self._args.pop('nrows_extra')\n                    self._args.pop('gpads')\n                    self._args.pop('pads')\n                    self._args.pop('dm')\n                    self._args.pop('cm')\n\n                    for i in range(len(nrows)):\n                        self._args['s00_{i}'.format(i=i+1)] = np.int64(starts[i])\n\n                    for i in range(len(nrows)):\n                        self._args['n00_{i}'.format(i=i+1)] = np.int64(nrows[i])\n\n                else:\n                    dot = LinearOperatorDot(self._ndim,\n                                            block_shape = (1,1),\n                                            keys = ((0,0),),\n                                            comm = comm,\n                                            backend=frozenset(backend.items()),\n                                            gpads=(self._args['gpads'],),\n                                            pads=(self._args['pads'],),\n                                            dm = (self._args['dm'],),\n                                            cm = (self._args['cm'],))\n\n                    starts      = self._args.pop('starts')\n                    nrows       = self._args.pop('nrows')\n                    nrows_extra = self._args.pop('nrows_extra')\n\n                    self._args.pop('gpads')\n                    self._args.pop('pads')\n                    self._args.pop('dm')\n                    self._args.pop('cm')\n\n                    for i in range(len(nrows)):\n                        self._args['s00_{i}'.format(i=i+1)] = np.int64(starts[i])\n\n                    for i in range(len(nrows)):\n                        self._args['n00_{i}'.format(i=i+1)] = np.int64(nrows[i])\n\n                    for i in range(len(nrows)):\n                        self._args['ne00_{i}'.format(i=i+1)] = np.int64(nrows_extra[i])\n\n            else:\n                dot = LinearOperatorDot(self._ndim,\n                                        block_shape = (1,1),\n                                        keys = ((0,0),),\n                                        comm = None,\n                                        backend=frozenset(backend.items()),\n                                        starts = (tuple(self._args['starts']),),\n                                        nrows=(tuple(self._args['nrows']),),\n                                        nrows_extra=(self._args['nrows_extra'],),\n                                        gpads=(self._args['gpads'],),\n                                        pads=(self._args['pads'],),\n                                        dm = (self._args['dm'],),\n                                        cm = (self._args['cm'],))\n                self._args.pop('nrows')\n                self._args.pop('nrows_extra')\n                self._args.pop('gpads')\n                self._args.pop('pads')\n                self._args.pop('starts')\n                self._args.pop('dm')\n                self._args.pop('cm')\n\n            self._func = dot.func\n\n#===============================================================================\n# TODO [YG, 28.01.2021]:\n# - Check if StencilMatrix should be subclassed\n# - Reimplement magic methods (some are simply copied from StencilMatrix)\ndef flip_axis(index, n):\n    s = n-index.start-1\n    e = n-index.stop-1 if n>index.stop else None\n    return slice(s,e,-1)\n\nclass StencilInterfaceMatrix(Matrix):\n    \"\"\"\n    Matrix in n-dimensional stencil format for an interface.\n\n    This is a linear operator that maps elements of stencil vector space V to\n    elements of stencil vector space W.\n\n    Parameters\n    ----------\n    V   : psydac.linalg.stencil.StencilVectorSpace\n          Domain of the new linear operator.\n\n    W   : psydac.linalg.stencil.StencilVectorSpace\n          Codomain of the new linear operator.\n\n    s_d : int\n          The starting index of the domain.\n\n    s_c : int\n          The starting index of the codomain.\n\n    dim : int\n          The axis of the interface.\n\n    pads: <list|tuple>\n          Padding of the linear operator.\n\n    \"\"\"\n    def __init__( self, V, W, s_d, s_c, d_axis, c_axis, d_ext, c_ext, *, flip=None, pads=None, backend=None ):\n\n        assert isinstance( V, StencilVectorSpace )\n        assert isinstance( W, StencilVectorSpace )\n        assert W.pads == V.pads\n\n        Vin = V.interfaces[d_axis, d_ext]\n\n        if pads is not None:\n            for p,vp in zip(pads, Vin.pads):\n                assert p<=vp\n\n        self._pads     = pads or tuple(Vin.pads)\n        dims           = list(W.shape)\n\n        if W.parent_ends[c_axis] is not None:\n            diff = min(1,W.parent_ends[c_axis]-W.ends[c_axis])\n        else:\n            diff = 0\n\n        dims[c_axis]   = W.pads[c_axis] + 1-diff + 2*W.shifts[c_axis]*W.pads[c_axis]\n        diags          = [compute_diag_len(p, md, mc) for p,md,mc in zip(self._pads, Vin.shifts, W.shifts)]\n        self._data     = np.zeros( dims+diags, dtype=W.dtype )\n\n        # Parallel attributes\n        if W.parallel and not isinstance(W.cart, InterfaceCartDecomposition):\n            if W.cart.is_comm_null:return\n            # Create data exchanger for ghost regions\n            self._synchronizer = get_data_exchanger(\n                cart        = W.cart,\n                dtype       = W.dtype,\n                coeff_shape = diags,\n                assembly    = True,\n                axis        = c_axis,\n                shape       = self._data.shape\n            )\n\n        self._flip        = tuple([1]*len(dims) if flip is None else flip)\n        self._permutation = list(range(len(dims)))\n        self._permutation[d_axis], self._permutation[c_axis] = self._permutation[c_axis], self._permutation[d_axis]\n        self._domain         = V\n        self._codomain       = W\n        self._domain_axis    = d_axis\n        self._codomain_axis  = c_axis\n        self._domain_ext     = d_ext\n        self._codomain_ext   = c_ext\n        self._domain_start   = s_d\n        self._codomain_start = s_c\n        self._ndim        = len( dims )\n        self._backend     = None\n\n\n        # Prepare the arguments for the dot product method\n        nd  = [(ej-sj+2*gp*mj-mj*p-gp)//mj*mi+1 for sj,ej,mj,mi,p,gp in zip(Vin.starts, Vin.ends, Vin.shifts, W.shifts, self._pads, Vin.pads)]\n        nc  = [ei-si+1 for si,ei,mj,p in zip(W.starts, W.ends, Vin.shifts, self._pads)]\n\n        # Number of rows in matrix (along each dimension)\n        nrows         = [min(ni,nj) for ni,nj  in zip(nc, nd)]\n        nrows_extra   = [max(0,ni-nj) for ni,nj in zip(nc, nd)]\n        nrows_extra[c_axis] = max(W.npts[c_axis]-Vin.npts[c_axis], 0)\n        nrows[c_axis] = W.pads[c_axis] + 1-diff-nrows_extra[c_axis]\n\n\n        args                 = {}\n        args['starts']       = tuple(Vin.starts)\n        args['nrows']        = tuple(nrows)\n        args['nrows_extra']  = tuple(nrows_extra)\n        args['gpads']        = tuple(Vin.pads)\n        args['pads']         = tuple(self._pads)\n        args['dm']           = tuple(Vin.shifts)\n        args['cm']           = tuple(W.shifts)\n        args['c_axis']       = c_axis\n        args['d_start']      = self._domain_start\n        args['c_start']      = self._codomain_start\n        args['flip']         = self._flip\n        args['permutation']  = self._permutation\n\n        self._dotargs_null = args\n        self._args         = args.copy()\n        self._func         = self._dot\n\n        self._transpose_args_null = self._prepare_transpose_args()\n        self._transpose_args      = self._transpose_args_null.copy()\n        self._transpose_func      = self._transpose\n\n        if backend is None:\n            backend = PSYDAC_BACKENDS.get(os.environ.get('PSYDAC_BACKEND'))\n\n        if backend:\n            self.set_backend(backend)\n\n        # Flag ghost regions as not up-to-date (conservative choice)\n        self._sync = False\n\n    #--------------------------------------\n    # Abstract interface\n    #--------------------------------------\n    @property\n    def domain( self ):\n        return self._domain\n\n    # ...\n    @property\n    def codomain( self ):\n        return self._codomain\n\n    # ...\n    @property\n    def dtype( self ):\n        return self.domain.dtype\n\n    # ...\n    def dot( self, v, out=None ):\n\n        assert isinstance( v, StencilVector )\n        assert v.space is self.domain\n\n        # Necessary if vector space is distributed across processes\n\n        if out is not None:\n            assert isinstance( out, StencilVector )\n            assert out.space is self.codomain\n        else:\n            out = StencilVector( self.codomain )\n\n        self._func(self._data, v._interface_data[self._domain_axis, self._domain_ext], out._data, **self._args)\n        # IMPORTANT: flag that ghost regions are not up-to-date\n        out.ghost_regions_in_sync = False\n        return out\n\n    # ...\n    @staticmethod\n    def _dot(mat, v, out, starts, nrows, nrows_extra, gpads, pads, dm, cm, c_axis, d_start, c_start, flip, permutation):\n\n        # Index for k=i-j\n        nrows      = list(nrows)\n        ndim       = len(v.shape)\n        kk         = [slice(None)]*ndim\n        diff       = [xp-p for xp,p in zip(gpads, pads)]\n\n        ndiags, _ = list(zip(*[compute_diag_len(p,mj,mi, return_padding=True) for p,mi,mj in zip(pads,cm,dm)]))\n        bb        = [p*m+p+1-n-s%m for p,m,n,s in zip(gpads, dm, ndiags, starts)]\n        nn        = v.shape\n\n        for xx in np.ndindex( *nrows ):\n            ii    = [ mi*pi + x for mi,pi,x in zip(cm, gpads, xx) ]\n            jj    = tuple( slice(b-d+(x+s%mj)//mi*mj,b-d+(x+s%mj)//mi*mj+n) for x,mi,mj,b,s,n,d in zip(xx,cm,dm,bb,starts,ndiags,diff) )\n            jj    = [flip_axis(i,n) if f==-1 else i for i,f,n in zip(jj,flip,nn)]\n            jj    = tuple(jj[i] for i in permutation)\n            ii_kk = tuple( ii + kk )\n\n            ii[c_axis] += c_start\n            out[tuple(ii)] = np.dot( mat[ii_kk].flat, v[jj].flat )\n\n\n        new_nrows = nrows.copy()\n        for d,er in enumerate(nrows_extra):\n\n            rows = new_nrows.copy()\n            del rows[d]\n\n            for n in range(er):\n                for xx in np.ndindex(*rows):\n                    xx = list(xx)\n                    xx.insert(d, nrows[d]+n)\n\n                    ii     = [mi*pi + x for mi,pi,x in zip(cm, gpads, xx)]\n                    ee     = [max(x-l+1,0) for x,l in zip(xx, nrows)]\n                    jj     = tuple( slice(b-d+(x+s%mj)//mi*mj, b-d+(x+s%mj)//mi*mj+n-e) for x,mi,mj,d,e,b,s,n in zip(xx, cm, dm, diff, ee, bb, starts, ndiags) )\n                    jj     = [flip_axis(i,n) if f==-1 else i for i,f,n in zip(jj, flip, nn)]\n                    jj     = tuple(jj[i] for i in permutation)\n                    kk     = [slice(None,n-e) for n,e in zip(ndiags, ee)]\n                    ii_kk  = tuple( ii + kk )\n                    ii[c_axis] += c_start\n                    out[tuple(ii)] = np.dot( mat[ii_kk].flat, v[jj].flat )\n\n            new_nrows[d] += er\n\n    # ...\n    def transpose( self , Mt=None):\n        \"\"\" Create new StencilInterfaceMatrix Mt, where domain and codomain are swapped\n            with respect to original matrix M, and Mt_{ij} = M_{ji}.\n        \"\"\"\n\n        # For clarity rename self\n        M = self\n\n        if Mt is None:\n            # Create new matrix where domain and codomain are swapped\n\n            Mt = StencilInterfaceMatrix(M.codomain, M.domain, M.codomain_start, M.domain_start, M.codomain_axis, M.domain_axis, M.codomain_ext, M.domain_ext,\n                                        flip=M.flip, pads=M.pads, backend=M.backend)\n\n        # Call low-level '_transpose' function (works on Numpy arrays directly)\n        M._transpose_func(M._data, Mt._data, **M._transpose_args)\n        return Mt\n\n    @staticmethod\n    def _transpose( M, Mt, nrows, ncols, gpads, pads, dm, cm, ndiags, ndiagsT, si, sk, sl):\n\n        # NOTE:\n        #  . Array M  index by [i1, i2, ..., k1, k2, ...]\n        #  . Array Mt index by [j1, j2, ..., l1, l2, ...]\n\n        #M[i,j-i+p]\n        #Mt[j,i-j+p]\n\n        diff       = [gp-p for gp,p in zip(gpads, pads)]\n\n        for xx in np.ndindex( *nrows ):\n            jj = tuple(m*p + x for m,p,x in zip(dm, gpads, xx) )\n            for ll in np.ndindex( *ndiags ):\n                ii = tuple( s + mi*(x//mj) + l + d for mj,mi,x,l,d,s in zip(dm,cm, xx, ll, diff, si))\n                kk = tuple( s + x%mj-mj*(l//mi) for mj,mi,l,x,s in zip(dm, cm, ll, xx, sk))\n                ll = tuple(l+s for l,s in zip(ll, sl))\n\n                if all(k<n  and k>-1 for k,n in zip(kk,ndiagsT)) and\\\n                   all(l<n for l,n in zip(ll, ndiags)) and\\\n                   all(i<n for i,n in zip(ii, ncols)):\n                    Mt[(*jj, *ll)] = M[(*ii, *kk)]\n\n    def _prepare_transpose_args(self):\n\n        #prepare the arguments for the transpose method\n        V     = self.domain\n        W     = self.codomain\n        ssc   = W.starts\n        eec   = W.ends\n        ssd   = V.interfaces[self._domain_axis, self._domain_ext].starts\n        eed   = V.interfaces[self._domain_axis, self._domain_ext].ends\n        pads  = self._pads\n        gpads = V.pads\n        dm    = V.shifts\n        cm    = W.shifts\n        dim   = self._codomain_axis\n\n        # Number of rows in the transposed matrix (along each dimension)\n        nrows       = [e-s+1 for s,e in zip(ssd, eed)]\n        ncols       = [e-s+1+2*m*p for s,e,m,p in zip(ssc, eec, cm, gpads)]\n\n        pp = pads\n        ndiags, starts = list(zip(*[compute_diag_len(p,mi,mj, return_padding=True) for p,mi,mj in zip(pp,cm,dm)]))\n        ndiagsT, _     = list(zip(*[compute_diag_len(p,mj,mi, return_padding=True) for p,mi,mj in zip(pp,cm,dm)]))\n\n        diff   = [gp-p for gp,p in zip(gpads, pp)]\n\n        sl   = [(s if mi>mj else 0) + (s%mi+mi//mj if mi<mj else 0)+(s if mi==mj else 0)\\\n                 for s,p,mi,mj in zip(starts,pp,cm,dm)]\n\n        si   = [(mi*p-mi*(int(np.ceil((p+1)/mj))-1) if mi>mj else 0)+\\\n                 (mi*p-mi*(p//mi)+ d*(mi-1) if mi<mj else 0)+\\\n                 (mj*p-mj*(p//mi)+ d*(mi-1) if mi==mj else 0)\\\n                  for mi,mj,p,d in zip(cm, dm, pp, diff)]\n\n        sk   = [n-1\\\n                 + (-(p%mj) if mi>mj else 0)\\\n                 + (-p+mj*(p//mi) if mi<mj  else 0)\\\n                 + (-p+mj*(p//mi) if mi==mj else 0)\\\n                 for mi,mj,n,p in zip(cm, dm, ndiagsT, pp)]\n\n\n        if V.parent_ends[dim] is not None:\n            diff_r = min(1,V.parent_ends[dim]-V.ends[dim])\n        else:\n            diff_r = 0\n\n        if W.parent_ends[dim] is not None:\n            diff_c = min(1,W.parent_ends[dim]-W.ends[dim])\n        else:\n            diff_c = 0\n\n        nrows[dim]  = pads[dim] + 1 - diff_r\n        ncols[dim]  = pads[dim] + 1 - diff_c + 2*cm[dim]*pads[dim]\n\n        args = {}\n        args['nrows']   = tuple(nrows)\n        args['ncols']   = tuple(ncols)\n        args['gpads']   = tuple(gpads)\n        args['pads']    = tuple(pads)\n        args['dm']      = tuple(dm)\n        args['cm']      = tuple(cm)\n        args['ndiags']  = tuple(ndiags)\n        args['ndiagsT'] = tuple(ndiagsT)\n        args['si']      = tuple(si)\n        args['sk']      = tuple(sk)\n        args['sl']      = tuple(sl)\n        return args\n    # ...\n    def toarray( self, **kwargs ):\n\n        order     = kwargs.pop('order', 'C')\n        with_pads = kwargs.pop('with_pads', False)\n\n        if self.codomain.parallel and with_pads:\n            coo = self._tocoo_parallel_with_pads()\n        else:\n            coo = self._tocoo_no_pads()\n\n        return coo.toarray()\n\n    # ...\n    def tosparse( self, **kwargs ):\n\n        order     = kwargs.pop('order', 'C')\n        with_pads = kwargs.pop('with_pads', False)\n\n        if self.codomain.parallel and with_pads:\n            coo = self._tocoo_parallel_with_pads()\n        else:\n            coo = self._tocoo_no_pads()\n\n        return coo\n\n    #...\n    def copy( self ):\n        M = StencilInterfaceMatrix( self._domain, self._codomain,\n                                    self._domain_start, self._codomain_start,\n                                    self._domain_axis, self._codomain_axis,\n                                    self._domain_ext, self._codomain_ext,\n                                    flip=self._flip, pads=self._pads,\n                                    backend=self._backend )\n        M._data[:] = self._data[:]\n        return M\n\n    # ...\n    def __neg__(self):\n        return self.__mul__(-1)\n\n    #...\n    def __mul__( self, a ):\n        w = self.copy()\n        w._data *= a\n        w._sync = self._sync\n        return w\n\n    #...\n    def __rmul__( self, a ):\n        w = self.copy()\n        w._data = a * w._data\n        w._sync = self._sync\n        return w\n\n    #...\n    def __add__(self, m):\n        raise NotImplementedError('TODO: StencilInterfaceMatrix.__add__')\n\n    #...\n    def __sub__(self, m):\n        raise NotImplementedError('TODO: StencilInterfaceMatrix.__sub__')\n\n    #...\n    def __imul__(self, a):\n        raise NotImplementedError('TODO: StencilInterfaceMatrix.__imul__')\n\n    #...\n    def __iadd__(self, m):\n        raise NotImplementedError('TODO: StencilInterfaceMatrix.__iadd__')\n\n    #...\n    def __isub__(self, m):\n        raise NotImplementedError('TODO: StencilInterfaceMatrix.__isub__')\n\n    #--------------------------------------\n    # Other properties/methods\n    #--------------------------------------\n\n    # ...\n    @property\n    def domain_axis( self ):\n        return self._domain_axis\n\n    # ...\n    @property\n    def codomain_axis( self ):\n        return self._codomain_axis\n\n    # ...\n    @property\n    def domain_ext( self ):\n        return self._domain_ext\n\n    # ...\n    @property\n    def codomain_ext( self ):\n        return self._codomain_ext\n\n    # ...\n    @property\n    def domain_start( self ):\n        return self._domain_start\n\n    # ...\n    @property\n    def codomain_start( self ):\n        return self._codomain_start\n\n    # ...\n    @property\n    def dim( self ):\n        return self._dim\n\n    # ...\n    @property\n    def flip( self ):\n        return self._flip\n\n    # ...\n    @property\n    def permutation( self ):\n        return self._permutation\n\n    # ...\n    @property\n    def pads( self ):\n        return self._pads\n\n    # ...\n    @property\n    def T(self):\n        return self.transpose()\n\n    # ...\n    def __getitem__(self, key):\n        index = self._getindex( key )\n        return self._data[index]\n\n    # ...\n    def __setitem__(self, key, value):\n        index = self._getindex( key )\n        self._data[index] = value\n\n    #...\n    def max( self ):\n        return self._data.max()\n\n    # ...\n\n    @property\n    def backend( self ):\n        return self._backend\n\n    #--------------------------------------\n    # Private methods\n    #--------------------------------------\n    def _getindex( self, key ):\n\n        nd = self._ndim\n        ii = key[:nd]\n        kk = key[nd:]\n\n        index = []\n\n        for i,s,p in zip( ii, self._codomain.starts, self._codomain.pads ):\n            x = self._shift_index( i, p-s )\n            index.append( x )\n\n        for k,p in zip( kk, self._pads ):\n            l = self._shift_index( k, p )\n            index.append( l )\n\n        return tuple(index)\n\n    # ...\n    @staticmethod\n    def _shift_index( index, shift ):\n        if isinstance( index, slice ):\n            start = None if index.start is None else index.start + shift\n            stop  = None if index.stop  is None else index.stop  + shift\n            return slice(start, stop, index.step)\n        else:\n            return index + shift\n    #...\n    def _tocoo_no_pads( self ):\n        # Shortcuts\n        nr  = self.codomain.npts\n        nc  = self.domain.npts\n        ss  = self.codomain.starts\n        pp  = self.codomain.pads\n        nd  = len(pp)\n\n        dim = self._codomain_axis\n\n        flip        = self.flip\n        permutation = self.permutation\n        c_start     = self.codomain_start\n        d_start     = self.domain_start\n        dm          = self.domain.shifts\n        cm          = self.codomain.shifts\n\n        ravel_multi_index = np.ravel_multi_index\n\n        # COO storage\n        rows = []\n        cols = []\n        data = []\n        # Range of data owned by local process (no ghost regions)\n        local = tuple( [slice(m*p,-m*p) for m,p in zip(cm, pp)] + [slice(None)] * nd )\n        pp = [compute_diag_len(p,mj,mi)-(p+1) for p,mi,mj in zip(self._pads, cm, dm)]\n\n        for (index,value) in np.ndenumerate( self._data[local] ):\n            if value:\n                # index = [i1, i2, ..., p1+j1-i1, p2+j2-i2, ...]\n\n                xx = index[:nd]  # x=i-s\n                ll = index[nd:]  # l=p+k\n\n                ii = [s+x for s,x in zip(ss,xx)]\n                di = [i//m for i,m in zip(ii,cm)]\n\n                jj = [(i*m+l-p)%n for (i,m,l,n,p) in zip(di,dm,ll,nc,pp)]\n\n                ii[dim] += c_start\n                jj[dim] += d_start\n\n                jj = [n-j-1 if f==-1 else j for j,f,n in zip(jj,flip,nc)]\n\n                jj = [jj[i] for i in permutation]\n\n                I = ravel_multi_index( ii, dims=nr, order='C' )\n                J = ravel_multi_index( jj, dims=nc, order='C' )\n\n                rows.append( I )\n                cols.append( J )\n                data.append( value )\n\n        M = coo_matrix(\n                    (data,(rows,cols)),\n                    shape = [np.prod(nr),np.prod(nc)],\n                    dtype = self.domain.dtype)\n\n        return M\n\n    # ...\n    @property\n    def ghost_regions_in_sync( self ):\n        return self._sync\n\n    # ...\n    # NOTE: this property must be set collectively\n    @ghost_regions_in_sync.setter\n    def ghost_regions_in_sync( self, value ):\n        assert isinstance( value, bool )\n        self._sync = value\n\n    # ...\n    def _update_ghost_regions_serial( self, direction: int ):\n\n        if direction is None:\n            for d in range( self._codomain.ndim ):\n                self._update_ghost_regions_serial( d )\n            return\n\n        ndim     = self._codomain.ndim\n        periodic = self._codomain.periods[direction]\n        p        = self._codomain.pads   [direction]\n\n        idx_front = [slice(None)]*direction\n        idx_back  = [slice(None)]*(ndim-direction-1 + ndim)\n\n        if periodic:\n\n            # Copy data from left to right\n            idx_from = tuple( idx_front + [slice( p, 2*p)] + idx_back )\n            idx_to   = tuple( idx_front + [slice(-p,None)] + idx_back )\n            self._data[idx_to] = self._data[idx_from]\n\n            # Copy data from right to left\n            idx_from = tuple( idx_front + [slice(-2*p,-p)] + idx_back )\n            idx_to   = tuple( idx_front + [slice(None, p)] + idx_back )\n            self._data[idx_to] = self._data[idx_from]\n\n        else:\n\n            # Set left ghost region to zero\n            idx_ghost = tuple( idx_front + [slice(None, p)] + idx_back )\n            self._data[idx_ghost] = 0\n\n            # Set right ghost region to zero\n            idx_ghost = tuple( idx_front + [slice(-p,None)] + idx_back )\n            self._data[idx_ghost] = 0\n\n    # ...\n    def exchange_assembly_data( self ):\n        \"\"\"\n        Exchange assembly data.\n        \"\"\"\n        ndim     = self._codomain.ndim\n        parallel = self._codomain.parallel\n\n        if self._codomain.parallel:\n            # PARALLEL CASE: fill in ghost regions with data from neighbors\n            self._synchronizer.start_exchange_assembly_data( self._data )\n            self._synchronizer.end_exchange_assembly_data( self._data )\n        else:\n            # SERIAL CASE: fill in ghost regions along periodic directions, otherwise set to zero\n            self._exchange_assembly_data_serial()\n\n    # ...\n    def _exchange_assembly_data_serial( self ):\n\n        ndim     = self._codomain.ndim\n        for direction in range(ndim):\n            if direction == self._codomain_axis:continue\n            periodic = self._codomain.periods[direction]\n            p        = self._codomain.pads   [direction]\n            m        = self._codomain.shifts[direction]\n\n            if periodic:\n                idx_front = [slice(None)]*direction\n                idx_back  = [slice(None)]*(ndim-direction-1)\n\n                # Copy data from left to right\n                idx_to   = tuple( idx_front + [slice( m*p, m*p+p)] + idx_back )\n                idx_from = tuple( idx_front + [ slice(-m*p,-m*p+p) if (-m*p+p)!=0 else slice(-m*p,None)] + idx_back )\n                self._data[idx_to] += self._data[idx_from]\n\n\n    def set_backend(self, backend):\n        from psydac.api.ast.linalg import LinearOperatorDot, InterfaceTransposeOperator\n        self._backend         = backend\n        self._args            = self._dotargs_null.copy()\n        self._transpose_args  = self._transpose_args_null.copy()\n\n        if self._backend is None:\n            self._func           = self._dot\n            self._transpose_func = self._transpose\n        else:\n            transpose = InterfaceTransposeOperator(self._ndim, backend=frozenset(backend.items()))\n            self._transpose_func = transpose.func\n\n            nrows   = self._transpose_args.pop('nrows')\n            ncols   = self._transpose_args.pop('ncols')\n            gpads   = self._transpose_args.pop('gpads')\n            pads    = self._transpose_args.pop('pads')\n            dm      = self._transpose_args.pop('dm')\n            cm      = self._transpose_args.pop('cm')\n            ndiags  = self._transpose_args.pop('ndiags')\n            ndiagsT = self._transpose_args.pop('ndiagsT')\n            si      = self._transpose_args.pop('si')\n            sk      = self._transpose_args.pop('sk')\n            sl      = self._transpose_args.pop('sl')\n\n            args = dict([('n{i}',nrows),('nc{i}', ncols),('gp{i}', gpads),('p{i}',pads ),\n                          ('dm{i}', dm),('cm{i}', cm), ('nd{i}', ndiags),('ndT{i}', ndiagsT),('si{i}', si),\n                          ('sk{i}', sk),('sl{i}', sl)])\n\n            self._transpose_args            = {}\n            for arg_name, arg_val in args.items():\n                for i in range(len(nrows)):\n                    self._transpose_args[arg_name.format(i=i+1)] =  np.int64(arg_val[i])\n\n            if self.domain.parallel:\n\n                comm = self.domain.interfaces[self._domain_axis, self._domain_ext].cart.local_comm\n\n                if self.domain == self.codomain:\n                    # In this case nrows_extra[i] == 0 for all i\n                    dot = LinearOperatorDot(self._ndim,\n                                    block_shape = (1,1),\n                                    keys = ((0,0),),\n                                    comm = comm,\n                                    backend=frozenset(backend.items()),\n                                    nrows_extra=(self._args['nrows_extra'],),\n                                    gpads=(self._args['gpads'],),\n                                    pads=(self._args['pads'],),\n                                    dm = (self._args['dm'],),\n                                    cm = (self._args['cm'],),\n                                    interface=True,\n                                    flip_axis=self._flip,\n                                    interface_axis=self._codomain_axis,\n                                    d_start=(self._domain_start,),\n                                    c_start=(self._codomain_start,))\n\n                    starts = self._args.pop('starts')\n                    nrows  = self._args.pop('nrows')\n\n                    self._args = {}\n                    for i in range(len(nrows)):\n                        self._args['s00_{i}'.format(i=i+1)] = np.int64(starts[i])\n\n                    for i in range(len(nrows)):\n                        self._args['n00_{i}'.format(i=i+1)] = np.int64(nrows[i])\n\n                else:\n                    dot = LinearOperatorDot(self._ndim,\n                                            block_shape = (1,1),\n                                            keys = ((0,0),),\n                                            comm = comm,\n                                            backend=frozenset(backend.items()),\n                                            gpads=(self._args['gpads'],),\n                                            pads=(self._args['pads'],),\n                                            dm = (self._args['dm'],),\n                                            cm = (self._args['cm'],),\n                                            interface=True,\n                                            flip_axis=self._flip,\n                                            interface_axis=self._codomain_axis,\n                                            d_start=(self._domain_start,),\n                                            c_start=(self._codomain_start,))\n\n                    starts      = self._args.pop('starts')\n                    nrows       = self._args.pop('nrows')\n                    nrows_extra = self._args.pop('nrows_extra')\n\n                    self._args = {}\n\n                    for i in range(len(nrows)):\n                        self._args['s00_{i}'.format(i=i+1)] = np.int64(starts[i])\n\n                    for i in range(len(nrows)):\n                        self._args['n00_{i}'.format(i=i+1)] =  np.int64(nrows[i])\n\n                    for i in range(len(nrows)):\n                        self._args['ne00_{i}'.format(i=i+1)] =  np.int64(nrows_extra[i])\n\n            else:\n                dot = LinearOperatorDot(self._ndim,\n                                        block_shape = (1,1),\n                                        keys = ((0,0),),\n                                        comm = None,\n                                        backend=frozenset(backend.items()),\n                                        starts = (tuple(self._args['starts']),),\n                                        nrows=(self._args['nrows'],),\n                                        nrows_extra=(self._args['nrows_extra'],),\n                                        gpads=(self._args['gpads'],),\n                                        pads=(self._args['pads'],),\n                                        dm = (self._args['dm'],),\n                                        cm = (self._args['cm'],),\n                                        interface=True,\n                                        flip_axis=self._flip,\n                                        interface_axis=self._codomain_axis,\n                                        d_start=(self._domain_start,),\n                                        c_start=(self._codomain_start,))\n\n                self._args = {}\n\n            self._func = dot.func\n#===============================================================================\nfrom psydac.api.settings   import PSYDAC_BACKENDS\ndel VectorSpace, Vector, Matrix\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/psydac/linalg/stencil.py b/psydac/linalg/stencil.py
--- a/psydac/linalg/stencil.py	
+++ b/psydac/linalg/stencil.py	
@@ -270,8 +270,8 @@
                 if parent_ends[axis] is not None:
                     parent_ends[axis] = self.pads[axis]
 
-            cart = cart.change_starts_ends(starts, ends, parent_starts, parent_ends)
-            space = StencilVectorSpace(cart)
+            cart = cart.change_starts_ends(tuple(starts), tuple(ends), tuple(parent_starts), tuple(parent_ends))
+            space = StencilVectorSpace(cart, dtype=self.dtype)
 
             self._interfaces[axis, ext] = space
 
@@ -358,8 +358,11 @@
             return self._dot(self._data.conjugate(), v._data , self.space.pads, self.space.shifts)
 
     def conjugate(self):
-        w=self.copy()
-        w._data=self._data.conjugate()
+        w = StencilVector( self._space )
+        np.copyto(w._data, self._data.conjugate(), casting='no')
+        for axis, ext in self._space.interfaces:
+            np.copyto(w._interface_data[axis, ext], self._interface_data[axis, ext], casting='no')
+        w._sync    = self._sync
         return w
 
     #...
Index: psydac/linalg/tests/test_stencil_matrix.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding: UTF-8 -*-\n\nimport pytest\nimport numpy as np\nfrom random import random\n\nfrom psydac.linalg.stencil import StencilVectorSpace, StencilVector, StencilMatrix\nfrom psydac.api.settings   import *\nfrom psydac.ddm.cart import DomainDecomposition, CartDecomposition\n\n#===============================================================================\ndef compute_global_starts_ends(domain_decomposition, npts, pads):\n    ndims         = len(npts)\n    global_starts = [None]*ndims\n    global_ends   = [None]*ndims\n\n    for axis in range(ndims):\n        ee = domain_decomposition.global_element_ends  [axis]\n\n        global_ends  [axis]     = ee.copy()\n        global_ends  [axis][-1] = npts[axis]-1\n        global_starts[axis]     = np.array([0] + (global_ends[axis][:-1]+1).tolist())\n\n    for s,e,p in zip(global_starts, global_ends, pads):\n        assert all(e-s+1>=p)\n\n    return tuple(global_starts), tuple(global_ends)\n#===============================================================================\n# SERIAL TESTS\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [7,15] )\n@pytest.mark.parametrize( 'n2', [8,12] )\n@pytest.mark.parametrize( 'p1', [1,2,3] )\n@pytest.mark.parametrize( 'p2', [1,2,3] )\n\ndef test_stencil_matrix_2d_serial_init( n1, n2, p1, p2, P1=True, P2=False ):\n\n    D = DomainDecomposition([n1,n2], periods=[P1,P2])\n\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V )\n\n    assert M._data.shape == (n1+2*p1, n2+2*p2, 1+2*p1, 1+2*p2)\n    assert M.shape == (n1*n2, n1*n2)\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [7,15] )\n@pytest.mark.parametrize( 'n2', [8,12] )\n@pytest.mark.parametrize( 'p1', [1,2,3] )\n@pytest.mark.parametrize( 'p2', [1,2,3] )\n\ndef test_stencil_matrix_2d_basic_ops( n1, n2, p1, p2, P1=True, P2=False ):\n\n    D = DomainDecomposition([n1,n2], periods=[P1,P2])\n\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V )\n\n    # take random data, but determinize it\n    np.random.seed(2)\n\n    M._data[:] = np.random.random(M._data.shape)\n\n    assert M._data.shape == (n1+2*p1, n2+2*p2, 1+2*p1, 1+2*p2)\n    assert M.shape == (n1*n2, n1*n2)\n\n    # we try to go for equality here...\n    assert np.array_equal((M * 2)._data, M._data * 2)\n    assert np.array_equal((M / 2)._data, M._data / 2)\n    assert np.array_equal((M + M)._data, M._data + M._data)\n    assert np.array_equal((M - M)._data, M._data - M._data)\n\n    M1 = M.copy()\n    M1 *= 2\n    M2 = M.copy()\n    M2 /= 2\n    M3 = M.copy()\n    M3 += M\n    M4 = M.copy()\n    M4 -= M\n    assert np.array_equal(M1._data, M._data * 2)\n    assert np.array_equal(M2._data, M._data / 2)\n    assert np.array_equal(M3._data, M._data + M._data)\n    assert np.array_equal(M4._data, M._data - M._data)\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [7,15] )\n@pytest.mark.parametrize( 'n2', [8,12] )\n@pytest.mark.parametrize( 'p1', [1,2,3] )\n@pytest.mark.parametrize( 'p2', [1,2,3] )\n\ndef test_stencil_matrix_2d_basic_ops_complex( n1, n2, p1, p2, P1=True, P2=False ):\n\n    D = DomainDecomposition([n1,n2], periods=[P1,P2])\n\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    V = StencilVectorSpace( cart, dtype=complex )\n    M = StencilMatrix( V, V )\n\n    # take random data, but determinize it\n    np.random.seed(2)\n\n    M._data[:] = np.random.random(M._data.shape)\n\n    assert M._data.shape == (n1+2*p1, n2+2*p2, 1+2*p1, 1+2*p2)\n    assert M.shape == (n1*n2, n1*n2)\n\n    # we try to go for equality here...\n    assert np.array_equal((M * 2)._data, M._data * 2)\n    assert np.array_equal((M / 2)._data, M._data / 2)\n    assert np.array_equal((M + M)._data, M._data + M._data)\n    assert np.array_equal((M - M)._data, M._data - M._data)\n\n    M1 = M.copy()\n    M1 *= 2\n    M2 = M.copy()\n    M2 /= 2\n    M3 = M.copy()\n    M3 += M\n    M4 = M.copy()\n    M4 -= M\n    assert np.array_equal(M1._data, M._data * 2)\n    assert np.array_equal(M2._data, M._data / 2)\n    assert np.array_equal(M3._data, M._data + M._data)\n    assert np.array_equal(M4._data, M._data - M._data)\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [7,15] )\n@pytest.mark.parametrize( 'n2', [8,12] )\n@pytest.mark.parametrize( 'p1', [1,2,3] )\n@pytest.mark.parametrize( 'p2', [1,2,3] )\n\ndef test_stencil_matrix_2d_serial_toarray( n1, n2, p1, p2, P1=False, P2=True ):\n\n    # Select non-zero values based on diagonal index\n    nonzero_values = dict()\n    for k1 in range(-p1,p1+1):\n        for k2 in range(-p2,p2+1):\n            nonzero_values[k1,k2] = 10*k1 + k2\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1,n2], periods=[P1,P2])\n\n    # Partition the points\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space and stencil matrix\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V )\n\n    # Fill in stencil matrix values\n    for k1 in range(-p1,p1+1):\n        for k2 in range(-p2,p2+1):\n            M[:,:,k1,k2] = nonzero_values[k1,k2]\n\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # Convert stencil matrix to 2D array\n    Ma = M.toarray()\n\n    # Construct exact matrix by hand\n    A = np.zeros( M.shape )\n    for i1 in range(n1):\n        for i2 in range(n2):\n            for k1 in range(-p1,p1+1):\n                for k2 in range(-p2,p2+1):\n                    j1 = (i1+k1) % n1\n                    j2 = (i2+k2) % n2\n                    i  = i1*(n2) + i2\n                    j  = j1*(n2) + j2\n                    if (P1 or 0 <= i1+k1 < n1) and (P2 or 0 <= i2+k2 < n2):\n                        A[i,j] = nonzero_values[k1,k2]\n\n    # Check shape and data in 2D array\n    assert Ma.shape == M.shape\n    assert np.all( Ma == A )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [10,32] )\n@pytest.mark.parametrize( 'p1', [1,2,3] )\n@pytest.mark.parametrize( 'P1', [True, False] )\n\ndef test_stencil_matrix_1d_serial_dot( n1, p1, P1 ):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1], periods=[P1])\n\n    # Partition the points\n    npts = [n1]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V )\n    x = StencilVector( V )\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    for k1 in range(-p1,p1+1):\n        M[:,k1] = k1\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(n1):\n        x[i1] = 2.0*random() - 1.0\n    x.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y = M.dot(x)\n\n    assert isinstance( y, StencilVector )\n    assert y.space is x.space\n\n    # Convert stencil objects to Scipy sparse matrix and 1D Numpy arrays\n    Ms = M.tosparse()\n    xa = x.toarray()\n    ya = y.toarray()\n\n    # Exact result using Scipy sparse dot product\n    ya_exact = Ms.dot( xa )\n\n    # Check data in 1D array\n    assert np.allclose( ya, ya_exact, rtol=1e-14, atol=1e-14 )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [5,15] )\n@pytest.mark.parametrize( 'n2', [5,12] )\n@pytest.mark.parametrize( 'p1', [1,2,3] )\n@pytest.mark.parametrize( 'p2', [1,2,3] )\n@pytest.mark.parametrize( 'P1', [True, False] )\n@pytest.mark.parametrize( 'P2', [True, False] )\n\ndef test_stencil_matrix_2d_serial_dot_1( n1, n2, p1, p2, P1, P2 ):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1,n2], periods=[P1,P2])\n\n    # Partition the points\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V )\n    x = StencilVector( V )\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    for k1 in range(-p1,p1+1):\n        for k2 in range(-p2,p2+1):\n            M[:,:,k1,k2] = 10*k1+k2\n\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(n1):\n        for i2 in range(n2):\n            x[i1,i2] = 2.0*random() - 1.0\n    x.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y = M.dot(x)\n\n    # Convert stencil objects to Numpy arrays\n    Ma = M.toarray()\n    xa = x.toarray()\n    ya = y.toarray()\n\n    # Exact result using Numpy dot product\n    ya_exact = np.dot( Ma, xa )\n\n    # Check data in 1D array\n    assert np.allclose( ya, ya_exact, rtol=1e-13, atol=1e-13 )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [5,15] )\n@pytest.mark.parametrize( 'n2', [5,12] )\n@pytest.mark.parametrize( 'p1', [2,3] )\n@pytest.mark.parametrize( 'p2', [2,3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n\ndef test_stencil_matrix_2d_serial_dot_2( n1, n2, p1, p2, P1, P2 ):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts1 = [n1,n2]\n    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])\n\n    npts2 = [n1-1,n2-1]\n    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])\n\n    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])\n    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V1 = StencilVectorSpace( cart1 )\n    V2 = StencilVectorSpace( cart2 )\n\n    M1 = StencilMatrix( V1, V2 ,pads=(p1,p2))\n    M2 = StencilMatrix( V2, V1 ,pads=(p1,p2))\n    x1 = StencilVector( V1 )\n    x2 = StencilVector( V2 )\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    M1._data[p1:-p1, p2:-p2, :, :] = np.random.random(M1._data[p1:-p1, p2:-p2, :, :].shape)\n    M2._data[p1:-p1, p2:-p2, :, :] = np.random.random(M2._data[p1:-p1, p2:-p2, :, :].shape)\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M1.remove_spurious_entries()\n    M2.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(n1):\n        for i2 in range(n2-1):\n            x1[i1,i2] = 2.0*random() - 1.0\n    x1.update_ghost_regions()\n\n    for i1 in range(n1-1):\n        for i2 in range(n2-1):\n            x2[i1,i2] = 2.0*random() - 1.0\n    x2.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y1 = M1.dot(x1)\n    y2 = M2.dot(x2)\n\n    # Convert stencil objects to Numpy arrays\n    M1a = M1.toarray()\n    x1a = x1.toarray()\n    y1a = y1.toarray()\n\n    M2a = M2.toarray()\n    x2a = x2.toarray()\n    y2a = y2.toarray()\n\n    # Exact result using Numpy dot product\n    y1a_exact = np.dot( M1a, x1a )\n    y2a_exact = np.dot( M2a, x2a )\n\n    # Check data in 1D array\n\n    assert np.allclose( y1a, y1a_exact, rtol=1e-13, atol=1e-13 )\n    assert np.allclose( y2a, y2a_exact, rtol=1e-13, atol=1e-13 )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [5,15] )\n@pytest.mark.parametrize( 'n2', [5,12] )\n@pytest.mark.parametrize( 'p1', [2,3] )\n@pytest.mark.parametrize( 'p2', [2,3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n\ndef test_stencil_matrix_2d_serial_dot_3( n1, n2, p1, p2, P1, P2 ):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts1 = [n1,n2-1]\n    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])\n\n    npts2 = [n1-1,n2-1]\n    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])\n\n    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])\n    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V1 = StencilVectorSpace( cart1 )\n    V2 = StencilVectorSpace( cart2 )\n    M1 = StencilMatrix( V1, V2 ,pads=(p1,p2-1))\n    M2 = StencilMatrix( V2, V1 ,pads=(p1,p2-1))\n    x1 = StencilVector( V1 )\n    x2 = StencilVector( V2 )\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    M1[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1+1, 2*p2-1))\n    M2[0:n1, 0:n2-1, :, :]   = np.random.random((n1, n2-1, 2*p1+1, 2*p2-1))\n\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M1.remove_spurious_entries()\n    M2.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(n1):\n        for i2 in range(n2-1):\n            x1[i1,i2] = 2.0*random() - 1.0\n    x1.update_ghost_regions()\n\n    for i1 in range(n1-1):\n        for i2 in range(n2-1):\n            x2[i1,i2] = 2.0*random() - 1.0\n    x2.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y1 = M1.dot(x1)\n    y2 = M2.dot(x2)\n\n    # Convert stencil objects to Numpy arrays\n    M1a = M1.toarray()\n    x1a = x1.toarray()\n    y1a = y1.toarray()\n\n    M2a = M2.toarray()\n    x2a = x2.toarray()\n    y2a = y2.toarray()\n\n    # Exact result using Numpy dot product\n    y1a_exact = np.dot( M1a, x1a )\n    y2a_exact = np.dot( M2a, x2a )\n\n    # Check data in 1D array\n\n    assert np.allclose( y1a, y1a_exact, rtol=1e-13, atol=1e-13 )\n    assert np.allclose( y2a, y2a_exact, rtol=1e-13, atol=1e-13 )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [5,15] )\n@pytest.mark.parametrize( 'n2', [5,12] )\n@pytest.mark.parametrize( 'p1', [2,3] )\n@pytest.mark.parametrize( 'p2', [2,3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n\ndef test_stencil_matrix_2d_serial_dot_4( n1, n2, p1, p2, P1, P2 ):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts1 = [n1-1,n2]\n    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])\n\n    npts2 = [n1-1,n2-1]\n    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])\n\n    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])\n    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V1 = StencilVectorSpace( cart1 )\n    V2 = StencilVectorSpace( cart2 )\n    M1 = StencilMatrix( V1, V2, pads=(p1-1,p2))\n    M2 = StencilMatrix( V2, V1, pads=(p1-1,p2))\n    x1 = StencilVector( V1 )\n    x2 = StencilVector( V2 )\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    M1[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1-1, 2*p2+1))\n    M2[0:n1-1, 0:n2  , :, :] = np.random.random((n1-1, n2  , 2*p1-1, 2*p2+1))\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M1.remove_spurious_entries()\n    M2.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(n1-1):\n        for i2 in range(n2):\n            x1[i1,i2] = 2.0*random() - 1.0\n    x1.update_ghost_regions()\n\n    for i1 in range(n1-1):\n        for i2 in range(n2-1):\n            x2[i1,i2] = 2.0*random() - 1.0\n    x2.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y1 = M1.dot(x1)\n    y2 = M2.dot(x2)\n\n    # Convert stencil objects to Numpy arrays\n    M1a = M1.toarray()\n    x1a = x1.toarray()\n    y1a = y1.toarray()\n\n    M2a = M2.toarray()\n    x2a = x2.toarray()\n    y2a = y2.toarray()\n\n    # Exact result using Numpy dot product\n    y1a_exact = np.dot( M1a, x1a )\n    y2a_exact = np.dot( M2a, x2a )\n\n    # Check data in 1D array\n\n    assert np.allclose( y1a, y1a_exact, rtol=1e-13, atol=1e-13 )\n    assert np.allclose( y2a, y2a_exact, rtol=1e-13, atol=1e-13 )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [5,15] )\n@pytest.mark.parametrize( 'n2', [5,12] )\n@pytest.mark.parametrize( 'p1', [2,3] )\n@pytest.mark.parametrize( 'p2', [2,3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n\ndef test_stencil_matrix_2d_serial_dot_5( n1, n2, p1, p2, P1, P2 ):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts1 = [n1-1,n2]\n    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])\n\n    npts2 = [n1-1,n2-1]\n    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])\n\n    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])\n    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V1 = StencilVectorSpace( cart1 )\n    V2 = StencilVectorSpace( cart2 )\n    M1 = StencilMatrix( V1, V2 ,pads=(p1,p2))\n    M2 = StencilMatrix( V2, V1 ,pads=(p1,p2))\n    x1 = StencilVector( V1 )\n    x2 = StencilVector( V2 )\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    M1[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1+1, 2*p2+1))\n    M2[0:n1-1, 0:n2, :, :] = np.random.random((n1-1, n2, 2*p1+1, 2*p2+1))\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M1.remove_spurious_entries()\n    M2.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(n1-1):\n        for i2 in range(n2):\n            x1[i1,i2] = 2.0*random() - 1.0\n    x1.update_ghost_regions()\n\n    for i1 in range(n1-1):\n        for i2 in range(n2-1):\n            x2[i1,i2] = 2.0*random() - 1.0\n    x2.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y1 = M1.dot(x1)\n    y2 = M2.dot(x2)\n\n    # Convert stencil objects to Numpy arrays\n    M1a = M1.toarray()\n    x1a = x1.toarray()\n    y1a = y1.toarray()\n\n    M2a = M2.toarray()\n    x2a = x2.toarray()\n    y2a = y2.toarray()\n\n    # Exact result using Numpy dot product\n    y1a_exact = np.dot( M1a, x1a )\n    y2a_exact = np.dot( M2a, x2a )\n\n    # Check data in 1D array\n\n    assert np.allclose( y1a, y1a_exact, rtol=1e-13, atol=1e-13 )\n    assert np.allclose( y2a, y2a_exact, rtol=1e-13, atol=1e-13 )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [5,15] )\n@pytest.mark.parametrize( 'n2', [5,12] )\n@pytest.mark.parametrize( 'p1', [2,3] )\n@pytest.mark.parametrize( 'p2', [2,3] )\n@pytest.mark.parametrize( 'P1', [True] )\n@pytest.mark.parametrize( 'P2', [True] )\n\ndef test_stencil_matrix_2d_serial_dot_6( n1, n2, p1, p2, P1, P2 ):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V , pads=(p1-1, p2-1))\n    x = StencilVector( V )\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    for k1 in range(-p1+1,p1):\n        for k2 in range(-p2+1,p2):\n            M[:,:,k1,k2] = 10*k1+k2\n\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(n1):\n        for i2 in range(n2):\n            x[i1,i2] = 2.0*random() - 1.0\n    x.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y = M.dot(x)\n\n    # Convert stencil objects to Numpy arrays\n    Ma = M.toarray()\n    xa = x.toarray()\n    ya = y.toarray()\n\n    # Exact result using Numpy dot product\n    ya_exact = np.dot( Ma, xa )\n\n    # Check data in 1D array\n    assert np.allclose( ya, ya_exact, rtol=1e-13, atol=1e-13 )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [4, 10, 32] )\n@pytest.mark.parametrize( 'p1', [1, 2, 3] )\n@pytest.mark.parametrize( 'P1', [True, False] )\n\ndef test_stencil_matrix_1d_serial_transpose( n1, p1, P1 ):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1], periods=[P1])\n\n    # Partition the points\n    npts = [n1]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[1])\n\n    # Create vector space and stencil matrix\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V )\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[0:n1, -p1:p1+1] = np.random.random( (n1, 2*p1+1) )\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Numpy array\n    Ta = M.transpose().toarray()\n\n    # Exact result: convert to Numpy array, then transpose\n    Ta_exact = M.toarray().transpose()\n\n    # Check data\n    assert np.array_equal( Ta, Ta_exact )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [5, 15] )\n@pytest.mark.parametrize( 'n2', [5, 12] )\n@pytest.mark.parametrize( 'p1', [1, 2, 3] )\n@pytest.mark.parametrize( 'p2', [1, 2, 3] )\n@pytest.mark.parametrize( 'P1', [True, False] )\n@pytest.mark.parametrize( 'P2', [True, False] )\n\ndef test_stencil_matrix_2d_serial_transpose_1( n1, n2, p1, p2, P1, P2 ):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space and stencil matrix\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V )\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[0:n1, 0:n2, :, :] = np.random.random((n1, n2, 2*p1+1, 2*p2+1))\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Scipy sparse format\n    Ts = M.transpose().tosparse()\n\n    # Exact result: convert to Scipy sparse format, then transpose\n    Ts_exact = M.tosparse().transpose()\n\n    # Check data\n    assert abs(Ts - Ts_exact).max() < 1e-14\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [5, 12] )\n@pytest.mark.parametrize( 'n2', [6, 10] )\n@pytest.mark.parametrize( 'p1', [1, 2, 3] )\n@pytest.mark.parametrize( 'p2', [1, 2, 3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n\ndef test_stencil_matrix_2d_serial_transpose_2( n1, n2, p1, p2, P1, P2 ):\n    # This should only work with non periodic boundaries\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts1 = [n1,n2]\n    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])\n\n    npts2 = [n1-1,n2-1]\n    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])\n\n    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])\n    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space and stencil matrix\n    V1 = StencilVectorSpace( cart1 )\n    V2 = StencilVectorSpace( cart2 )\n    M  = StencilMatrix(V1, V2, pads=(p1,p2))\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1+1, 2*p2+1))\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Scipy sparse format\n    Ts = M.transpose().transpose().tosparse()\n\n    # Exact result: convert to Scipy sparse format, then transpose\n    Ts_exact = M.tosparse()\n\n    # Check data\n    assert abs(Ts - Ts_exact).max() < 1e-14\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [5, 12] )\n@pytest.mark.parametrize( 'n2', [6, 10] )\n@pytest.mark.parametrize( 'p1', [1, 2, 3] )\n@pytest.mark.parametrize( 'p2', [1, 2, 3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n\ndef test_stencil_matrix_2d_serial_transpose_3( n1, n2, p1, p2, P1, P2 ):\n    # This should only work with non periodic boundaries\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts1 = [n1,n2]\n    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])\n\n    npts2 = [n1-1,n2]\n    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])\n\n    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])\n    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space and stencil matrix\n    V1 = StencilVectorSpace( cart1 )\n    V2 = StencilVectorSpace( cart2 )\n    M  = StencilMatrix(V1, V2, pads=(p1,p2))\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[0:n1-1, 0:n2, :, :] = np.random.random((n1-1, n2, 2*p1+1, 2*p2+1))\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Scipy sparse format\n    Ts = M.transpose().transpose().tosparse()\n\n    # Exact result: convert to Scipy sparse format, then transpose\n    Ts_exact = M.tosparse()\n\n    # Check data\n    assert abs(Ts - Ts_exact).max() < 1e-14\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [5, 12] )\n@pytest.mark.parametrize( 'n2', [6, 10] )\n@pytest.mark.parametrize( 'p1', [1, 2, 3] )\n@pytest.mark.parametrize( 'p2', [1, 2, 3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n\ndef test_stencil_matrix_2d_serial_transpose_4( n1, n2, p1, p2, P1, P2 ):\n    # This should only work with non periodic boundaries\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts1 = [n1,n2]\n    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])\n\n    npts2 = [n1,n2-1]\n    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])\n\n    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])\n    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])\n\n\n    # Create vector space and stencil matrix\n    V1 = StencilVectorSpace( cart1 )\n    V2 = StencilVectorSpace( cart2 )\n    M  = StencilMatrix(V1, V2, pads=(p1,p2))\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[0:n1, 0:n2-1, :, :] = np.random.random((n1, n2-1, 2*p1+1, 2*p2+1))\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Scipy sparse format\n    Ts = M.transpose().transpose().tosparse()\n\n    # Exact result: convert to Scipy sparse format, then transpose\n    Ts_exact = M.tosparse()\n\n    # Check data\n    assert abs(Ts - Ts_exact).max() < 1e-14\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [7, 12] )\n@pytest.mark.parametrize( 'n2', [7, 10] )\n@pytest.mark.parametrize( 'p1', [2, 3] )\n@pytest.mark.parametrize( 'p2', [2, 3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n\ndef test_stencil_matrix_2d_serial_transpose_5( n1, n2, p1, p2, P1, P2 ):\n    # This should only work with non periodic boundaries\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts1 = [n1,n2-1]\n    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])\n\n    npts2 = [n1,n2-1]\n    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])\n\n    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])\n    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space and stencil matrix\n    V1 = StencilVectorSpace( cart1 )\n    V2 = StencilVectorSpace( cart2 )\n    M  = StencilMatrix(V1, V2, pads=(p1, p2-1))\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[0:n1, 0:n2-1, :, :] = np.random.random((n1, n2-1, 2*p1+1, 2*p2-1))\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Scipy sparse format\n    Ts = M.transpose().transpose().tosparse()\n\n    # Exact result: convert to Scipy sparse format, then transpose\n    Ts_exact = M.tosparse()\n\n    # Check data\n    assert abs(Ts - Ts_exact).max() < 1e-14\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [7, 12] )\n@pytest.mark.parametrize( 'n2', [7, 10] )\n@pytest.mark.parametrize( 'p1', [2, 3] )\n@pytest.mark.parametrize( 'p2', [2, 3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n\ndef test_stencil_matrix_2d_serial_transpose_6( n1, n2, p1, p2, P1, P2 ):\n    # This should only work with non periodic boundaries\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts1 = [n1-1,n2-1]\n    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])\n\n    npts2 = [n1,n2-1]\n    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])\n\n    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])\n    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space and stencil matrix\n    V1 = StencilVectorSpace( cart1 )\n    V2 = StencilVectorSpace( cart2 )\n    M  = StencilMatrix(V1, V2, pads=(p1, p2-1))\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[0:n1, 0:n2-1, :, :] = np.random.random((n1, n2-1, 2*p1+1, 2*p2-1))\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Scipy sparse format\n    Ts = M.transpose().transpose().tosparse()\n\n    # Exact result: convert to Scipy sparse format, then transpose\n    Ts_exact = M.tosparse()\n\n    # Check data\n    assert abs(Ts - Ts_exact).max() < 1e-14\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [7, 12] )\n@pytest.mark.parametrize( 'n2', [7, 10] )\n@pytest.mark.parametrize( 'p1', [2, 3] )\n@pytest.mark.parametrize( 'p2', [2, 3] )\n@pytest.mark.parametrize( 'P1', [True] )\n@pytest.mark.parametrize( 'P2', [True] )\n\ndef test_stencil_matrix_2d_serial_transpose_7( n1, n2, p1, p2, P1, P2 ):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space and stencil matrix\n    V1 = StencilVectorSpace( cart )\n    V2 = StencilVectorSpace( cart )\n    M  = StencilMatrix(V1, V2, pads=(p1, p2-1))\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[0:n1, 0:n2, :, :] = np.random.random((n1, n2, 2*p1+1, 2*p2-1))\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Scipy sparse format\n    Ts = M.transpose().transpose().tosparse()\n\n    # Exact result: convert to Scipy sparse format, then transpose\n    Ts_exact = M.tosparse()\n\n    # Check data\n    assert abs(Ts - Ts_exact).max() < 1e-14\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [7, 12] )\n@pytest.mark.parametrize( 'n2', [7, 10] )\n@pytest.mark.parametrize( 'p1', [2, 3] )\n@pytest.mark.parametrize( 'p2', [2, 3] )\n@pytest.mark.parametrize( 'P1', [True] )\n@pytest.mark.parametrize( 'P2', [True] )\n\ndef test_stencil_matrix_2d_serial_transpose_8( n1, n2, p1, p2, P1, P2 ):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space and stencil matrix\n    V1 = StencilVectorSpace( cart )\n    V2 = StencilVectorSpace( cart )\n    M  = StencilMatrix(V1, V2, pads=(p1-1, p2-1))\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[0:n1, 0:n2, :, :] = np.random.random((n1, n2, 2*p1-1, 2*p2-1))\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Scipy sparse format\n    Ts = M.transpose().transpose().tosparse()\n\n    # Exact result: convert to Scipy sparse format, then transpose\n    Ts_exact = M.tosparse()\n\n    # Check data\n    assert abs(Ts - Ts_exact).max() < 1e-14\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [7, 12] )\n@pytest.mark.parametrize( 'n2', [7, 10] )\n@pytest.mark.parametrize( 'p1', [2, 3] )\n@pytest.mark.parametrize( 'p2', [2, 3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n\ndef test_stencil_matrix_2d_serial_transpose_9( n1, n2, p1, p2, P1, P2 ):\n    # This should only work with non periodic boundaries\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts = [n1-1,n2-1]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n\n    # Create vector space and stencil matrix\n    V1 = StencilVectorSpace( cart )\n    V2 = StencilVectorSpace( cart )\n    M  = StencilMatrix(V1, V2)\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1+1, 2*p2+1))\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Scipy sparse format\n    Ts = M.transpose().transpose().tosparse()\n\n    # Exact result: convert to Scipy sparse format, then transpose\n    Ts_exact = M.tosparse()\n\n    # Check data\n    assert abs(Ts - Ts_exact).max() < 1e-14\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [7, 12] )\n@pytest.mark.parametrize( 'n2', [7, 10] )\n@pytest.mark.parametrize( 'n3', [7, 10] )\n@pytest.mark.parametrize( 'p1', [2, 3] )\n@pytest.mark.parametrize( 'p2', [2, 3] )\n@pytest.mark.parametrize( 'p3', [2, 3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n@pytest.mark.parametrize( 'P3', [False] )\n\ndef test_stencil_matrix_3d_serial_transpose_1( n1, n2, n3, p1, p2, p3, P1, P2, P3 ):\n    # This should only work with non periodic boundaries\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1, n3-1], periods=[P1,P2,P3])\n\n    # Partition the points\n    npts1 = [n1-1,n2-1, n3-1]\n    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])\n\n    npts2 = [n1,n2-1, n3-1]\n    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])\n\n    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2,p3], shifts=[1,1,1])\n    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2,p3], shifts=[1,1,1])\n\n    # Create vector space and stencil matrix\n    V1 = StencilVectorSpace( cart1 )\n    V2 = StencilVectorSpace( cart2 )\n    M  = StencilMatrix(V1, V2, pads=(p1, p2-1, p3-1))\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[0:n1, 0:n2-1, 0:n3-1, :, :, :] = np.random.random((n1, n2-1, n3-1, 2*p1+1, 2*p2-1, 2*p3-1))\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Scipy sparse format\n    Ts = M.transpose().transpose().tosparse()\n\n    # Exact result: convert to Scipy sparse format, then transpose\n    Ts_exact = M.tosparse()\n\n    # Check data\n    assert abs(Ts - Ts_exact).max() < 1e-14\n\n\n#===============================================================================\n# BACKENDS TESTS\n#===============================================================================\n\n@pytest.mark.parametrize( 'n1', [5,15] )\n@pytest.mark.parametrize( 'n2', [5,12] )\n@pytest.mark.parametrize( 'p1', [2,3] )\n@pytest.mark.parametrize( 'p2', [2,3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n@pytest.mark.parametrize( 'backend', [PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )\n\ndef test_stencil_matrix_2d_serial_backend_dot_1( n1, n2, p1, p2, P1, P2 , backend):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts1 = [n1-1,n2]\n    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])\n\n    npts2 = [n1-1,n2-1]\n    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])\n\n    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])\n    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V1 = StencilVectorSpace( cart1 )\n    V2 = StencilVectorSpace( cart2 )\n    M1 = StencilMatrix( V1, V2 ,pads=(p1,p2), backend=backend)\n    M2 = StencilMatrix( V2, V1 ,pads=(p1,p2), backend=backend)\n    x1 = StencilVector( V1 )\n    x2 = StencilVector( V2 )\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    M1[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1+1, 2*p2+1))\n    M2[0:n1-1, 0:n2, :, :] = np.random.random((n1-1, n2, 2*p1+1, 2*p2+1))\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M1.remove_spurious_entries()\n    M2.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(n1-1):\n        for i2 in range(n2):\n            x1[i1,i2] = 2.0*random() - 1.0\n    x1.update_ghost_regions()\n\n    for i1 in range(n1-1):\n        for i2 in range(n2-1):\n            x2[i1,i2] = 2.0*random() - 1.0\n    x2.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y1 = M1.dot(x1)\n    y2 = M2.dot(x2)\n\n    # Convert stencil objects to Numpy arrays\n    M1a = M1.toarray()\n    x1a = x1.toarray()\n    y1a = y1.toarray()\n\n    M2a = M2.toarray()\n    x2a = x2.toarray()\n    y2a = y2.toarray()\n\n    # Exact result using Numpy dot product\n    y1a_exact = np.dot( M1a, x1a )\n    y2a_exact = np.dot( M2a, x2a )\n\n    # Check data in 1D array\n\n    assert np.allclose( y1a, y1a_exact, rtol=1e-13, atol=1e-13 )\n    assert np.allclose( y2a, y2a_exact, rtol=1e-13, atol=1e-13 )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [5,15] )\n@pytest.mark.parametrize( 'n2', [5,12] )\n@pytest.mark.parametrize( 'p1', [2,3] )\n@pytest.mark.parametrize( 'p2', [2,3] )\n@pytest.mark.parametrize( 'P1', [True] )\n@pytest.mark.parametrize( 'P2', [True] )\n@pytest.mark.parametrize( 'backend', [None, PSYDAC_BACKEND_PYTHON, PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )\n\ndef test_stencil_matrix_2d_serial_backend_dot_2( n1, n2, p1, p2, P1, P2 , backend):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts = [n1-1,n2-1]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V , pads=(p1-1, p2-1), backend=backend)\n    x = StencilVector( V )\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    for k1 in range(-p1+1,p1):\n        for k2 in range(-p2+1,p2):\n            M[:,:,k1,k2] = 10*k1+k2\n\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(n1):\n        for i2 in range(n2):\n            x[i1,i2] = 2.0*random() - 1.0\n    x.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y = M.dot(x)\n\n    # Convert stencil objects to Numpy arrays\n    Ma = M.toarray()\n    xa = x.toarray()\n    ya = y.toarray()\n\n    # Exact result using Numpy dot product\n    ya_exact = np.dot( Ma, xa )\n\n    # Check data in 1D array\n    assert np.allclose( ya, ya_exact, rtol=1e-13, atol=1e-13 )\n\n    # tests for backend propagation\n    assert M.backend is backend\n    assert M.T.backend is M.backend\n    assert (M+M).backend is M.backend\n    assert (2*M).backend is M.backend\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [5,15] )\n@pytest.mark.parametrize( 'n2', [5,12] )\n@pytest.mark.parametrize( 'p1', [2,3] )\n@pytest.mark.parametrize( 'p2', [2,3] )\n@pytest.mark.parametrize( 'P1', [False] )\n@pytest.mark.parametrize( 'P2', [False] )\n@pytest.mark.parametrize( 'backend', [PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )\n\ndef test_stencil_matrix_2d_serial_backend_dot_4( n1, n2, p1, p2, P1, P2, backend):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts1 = [n1-1,n2]\n    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])\n\n    npts2 = [n1-1,n2-1]\n    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])\n\n    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])\n    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V1 = StencilVectorSpace( cart1 )\n    V2 = StencilVectorSpace( cart2 )\n    M1 = StencilMatrix( V1, V2, pads=(p1-1,p2), backend=backend)\n    M2 = StencilMatrix( V2, V1, pads=(p1-1,p2), backend=backend)\n    x1 = StencilVector( V1 )\n    x2 = StencilVector( V2 )\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    M1[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1-1, 2*p2+1))\n    M2[0:n1-1, 0:n2  , :, :] = np.random.random((n1-1, n2  , 2*p1-1, 2*p2+1))\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M1.remove_spurious_entries()\n    M2.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(n1-1):\n        for i2 in range(n2):\n            x1[i1,i2] = 2.0*random() - 1.0\n    x1.update_ghost_regions()\n\n    for i1 in range(n1-1):\n        for i2 in range(n2-1):\n            x2[i1,i2] = 2.0*random() - 1.0\n    x2.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y1 = M1.dot(x1)\n    y2 = M2.dot(x2)\n\n    # Convert stencil objects to Numpy arrays\n    M1a = M1.toarray()\n    x1a = x1.toarray()\n    y1a = y1.toarray()\n\n    M2a = M2.toarray()\n    x2a = x2.toarray()\n    y2a = y2.toarray()\n\n    # Exact result using Numpy dot product\n    y1a_exact = np.dot( M1a, x1a )\n    y2a_exact = np.dot( M2a, x2a )\n\n    # Check data in 1D array\n\n    assert np.allclose( y1a, y1a_exact, rtol=1e-13, atol=1e-13 )\n    assert np.allclose( y2a, y2a_exact, rtol=1e-13, atol=1e-13 )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [15] )\n@pytest.mark.parametrize( 'n2', [12] )\n@pytest.mark.parametrize( 'p1', [2] )\n@pytest.mark.parametrize( 'p2', [3] )\n@pytest.mark.parametrize( 'P1', [True] )\n@pytest.mark.parametrize( 'P2', [True] )\n@pytest.mark.parametrize( 'backend', [None, PSYDAC_BACKEND_PYTHON, PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )\n@pytest.mark.parametrize( 'backend2', [None, PSYDAC_BACKEND_PYTHON, PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )\n\ndef test_stencil_matrix_2d_serial_backend_switch( n1, n2, p1, p2, P1, P2 , backend, backend2):\n\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])\n\n    # Partition the points\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V , pads=(p1-1, p2-1), backend=backend)\n    x = StencilVector( V )\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    for k1 in range(-p1+1,p1):\n        for k2 in range(-p2+1,p2):\n            M[:,:,k1,k2] = 10*k1+k2\n\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(n1):\n        for i2 in range(n2):\n            x[i1,i2] = 2.0*random() - 1.0\n    x.update_ghost_regions()\n\n    assert M.backend is backend\n    M.dot(x)\n    M.set_backend(backend2)\n\n    assert M.backend is backend2\n    M.dot(x)\n\n#===============================================================================\n# PARALLEL TESTS\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [20,67] )\n@pytest.mark.parametrize( 'p1', [1,2,3] )\n@pytest.mark.parametrize( 'P1', [True, False] )\n@pytest.mark.parallel\n\ndef test_stencil_matrix_1d_parallel_dot( n1, p1, P1 ):\n\n    from mpi4py import MPI\n\n    comm = MPI.COMM_WORLD\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1], periods=[P1], comm=comm)\n\n    # Partition the points\n    npts = [n1]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[1])\n\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V )\n    x = StencilVector( V )\n\n    s1, = V.starts\n    e1, = V.ends\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    for k1 in range(-p1,p1+1):\n        M[:,k1] = k1\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(x.starts[0],x.ends[0]+1):\n        x[i1] = 2.0*random() - 1.0\n    x.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y = M.dot( x )\n\n    assert isinstance( y, StencilVector )\n    assert y.space is x.space\n\n    # Convert stencil objects to Scipy sparse matrix and 1D Numpy arrays\n    Ms = M.tosparse()\n    xa = x.toarray( with_pads=True )\n    ya = y.toarray()\n\n    # Exact result using Scipy sparse dot product\n    ya_exact = Ms.dot( xa )\n\n    # Check data in 1D array\n    assert np.allclose( ya, ya_exact, rtol=1e-14, atol=1e-14 )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [8,21] )\n@pytest.mark.parametrize( 'n2', [13,32] )\n@pytest.mark.parametrize( 'p1', [1,3] )\n@pytest.mark.parametrize( 'p2', [1,2] )\n@pytest.mark.parametrize( 'P1', [True, False] )\n@pytest.mark.parametrize( 'P2', [True, False] )\n@pytest.mark.parallel\n\ndef test_stencil_matrix_2d_parallel_dot( n1, n2, p1, p2, P1, P2 ):\n\n    from mpi4py import MPI\n\n    comm = MPI.COMM_WORLD\n    # Create domain decomposition\n    D = DomainDecomposition([n1,n2], periods=[P1,P2], comm=comm)\n\n    # Partition the points\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V )\n    x = StencilVector( V )\n\n    s1,s2 = V.starts\n    e1,e2 = V.ends\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    for k1 in range(-p1,p1+1):\n        for k2 in range(-p2,p2+1):\n            M[:,:,k1,k2] = 10*k1+k2\n\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(s1,e1+1):\n        for i2 in range(s2,e2+1):\n            x[i1,i2] = 2.0*random() - 1.0\n    x.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y = M.dot(x)\n\n    assert isinstance( y, StencilVector )\n    assert y.space is x.space\n\n    # Convert stencil objects to Numpy arrays\n    Ma = M.toarray()\n    xa = x.toarray( with_pads=True )\n    ya = y.toarray()\n\n    # Exact result using Numpy dot product\n    ya_exact = np.dot( Ma, xa )\n\n    # Check data in 1D array\n    assert np.allclose( ya, ya_exact, rtol=1e-13, atol=1e-13 )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [20,67] )\n@pytest.mark.parametrize( 'p1', [1,2,3] )\n@pytest.mark.parametrize( 'P1', [True, False] )\n@pytest.mark.parallel\n\ndef test_stencil_matrix_1d_parallel_sync( n1, p1, P1):\n\n    from mpi4py       import MPI\n    from psydac.ddm.cart import CartDecomposition\n\n    comm = MPI.COMM_WORLD\n    # Create domain decomposition\n    D = DomainDecomposition([n1], periods=[P1], comm=comm)\n\n    # Partition the points\n    npts = [n1]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[1])\n\n    V = StencilVectorSpace( cart, dtype=int )\n    M = StencilMatrix( V, V )\n\n    s1, = V.starts\n    e1, = V.ends\n\n    # Fill-in pattern\n    fill_in = lambda i1, k1 : 10*i1+k1\n\n    # Fill in stencil matrix\n    for i1 in range(s1, e1+1):\n        for k1 in range(-p1, p1+1):\n            M[i1,k1] = fill_in( i1, k1 )\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: update ghost regions\n    M.update_ghost_regions()\n\n    # Convert stencil object to 1D Numpy array\n    Ma = M.toarray( with_pads=True )\n\n    # Create exact solution\n    Me = np.zeros( (n1,n1), dtype=V.dtype )\n\n    for i1 in range(n1):\n        for k1 in range(-p1, p1+1):\n\n            # Get column index\n            j1 = i1 + k1\n\n            # If j1 is outside matrix limits, apply periodic BCs or skip entry\n            if not 0 <= j1 < n1:\n                if P1:\n                    j1 = j1 % n1\n                else:\n                    continue\n\n            # Fill in matrix element\n            Me[i1,j1] = fill_in( i1, k1 )\n\n    # Compare local solution to global\n    i1_min = max(0, s1-p1)\n    i1_max = min(e1+p1+1, n1)\n\n#    for i in range( comm.size ):\n#        if i == comm.rank:\n#            print( \"RANK {}:\".format( i ) )\n#            print( M._data.shape )\n#            print( Ma.shape )\n#            print( Ma )\n#            print( \"PASSED\" )\n#            print( flush=True )\n#        comm.Barrier()\n\n    assert np.array_equal( Ma[i1_min:i1_max, :], Me[i1_min:i1_max, :] )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [21,67] )\n@pytest.mark.parametrize( 'n2', [13,32] )\n@pytest.mark.parametrize( 'p1', [1,3] )\n@pytest.mark.parametrize( 'p2', [1,2] )\n@pytest.mark.parametrize( 'P1', [True, False] )\n@pytest.mark.parametrize( 'P2', [True, False] )\n@pytest.mark.parallel\n\ndef test_stencil_matrix_2d_parallel_sync( n1, n2, p1, p2, P1, P2):\n\n    from mpi4py       import MPI\n    from psydac.ddm.cart import CartDecomposition\n\n    comm = MPI.COMM_WORLD\n    # Create domain decomposition\n    D = DomainDecomposition([n1,n2], periods=[P1,P2], comm=comm)\n\n    # Partition the points\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    V = StencilVectorSpace( cart, dtype=int )\n    M = StencilMatrix( V, V )\n\n    s1, s2 = V.starts\n    e1, e2 = V.ends\n\n    # Fill-in pattern\n    fill_in = lambda i1, i2, k1, k2: 1000*i1 + 100*i2 + 10*abs(k1) + abs(k2)\n\n    # Fill in stencil matrix\n    for i1 in range(s1, e1+1):\n        for i2 in range(s2, e2+1):\n            for k1 in range(-p1, p1+1):\n                for k2 in range(-p2, p2+1):\n                    M[i1, i2, k1, k2] = fill_in( i1, i2, k1, k2 )\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: update ghost regions\n    M.update_ghost_regions()\n\n    # Convert stencil object to 1D Numpy array\n    Ma = M.toarray( with_pads=True )\n\n    # Create exact solution\n    Me = np.zeros( (n1*n2, n1*n2), dtype=V.dtype )\n\n    for i1 in range(n1):\n        for i2 in range(n2):\n            for k1 in range(-p1, p1+1):\n                for k2 in range(-p2, p2+1):\n\n                    # Get column multi-index\n                    j1 = i1 + k1\n                    j2 = i2 + k2\n\n                    # If j1 is outside matrix limits,\n                    # apply periodic BCs or skip entry\n                    if not 0 <= j1 < n1:\n                        if P1:\n                            j1 = j1 % n1\n                        else:\n                            continue\n\n                    # If j2 is outside matrix limits,\n                    # apply periodic BCs or skip entry\n                    if not 0 <= j2 < n2:\n                        if P2:\n                            j2 = j2 % n2\n                        else:\n                            continue\n\n                    # Get matrix indices assuming C ordering\n                    i = i1 * n2 + i2\n                    j = j1 * n2 + j2\n\n                    # Fill in matrix element\n                    Me[i,j] = fill_in( i1, i2, k1, k2 )\n\n#    #++++++++++++++++++++++++++++++++++++++\n#    # DEBUG\n#    #++++++++++++++++++++++++++++++++++++++\n#    np.set_printoptions( linewidth=200 )\n#\n#    if comm.rank == 0:\n#        print( 'Me' )\n#        print( Me )\n#        print( flush=True )\n#    comm.Barrier()\n#\n#    for i in range(comm.size):\n#        if i == comm.rank:\n#            print( 'RANK {}'.format( i ) )\n#            print( Ma )\n#            print( flush=True )\n#        comm.Barrier()\n#    #++++++++++++++++++++++++++++++++++++++\n\n    # Compare local solution to global, row by row\n    i1_min = max(0, s1-p1)\n    i1_max = min(e1+p1+1, n1)\n\n    i2_min = max(0, s2-p2)\n    i2_max = min(e2+p2+1, n2)\n\n    for i1 in range( i1_min, i1_max ):\n        for i2 in range( i2_min, i2_max ):\n            i = i1 * n2 + i2\n            assert np.array_equal( Ma[i,:], Me[i,:] )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [20, 67] )\n@pytest.mark.parametrize( 'p1', [1, 2, 3] )\n@pytest.mark.parametrize( 'P1', [True, False] )\n@pytest.mark.parallel\n\ndef test_stencil_matrix_1d_parallel_transpose( n1, p1, P1 ):\n\n    from mpi4py       import MPI\n    from psydac.ddm.cart import CartDecomposition\n\n    comm = MPI.COMM_WORLD\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1], periods=[P1], comm=comm)\n\n    # Partition the points\n    npts = [n1]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[1])\n\n    # Create vector space and stencil matrix\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V )\n\n    s1, = V.starts\n    e1, = V.ends\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[s1:e1+1, -p1:p1+1] = np.random.random( (e1-s1+1, 2*p1+1) )\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Numpy array\n    Ta = M.transpose().toarray()\n\n    # Exact result: convert to Numpy array including padding, then transpose,\n    # hence remove entries that do not belong to current process.\n    Ta_exact = M.toarray( with_pads=True ).transpose()\n    Ta_exact[  :s1, :] = 0.0\n    Ta_exact[e1+1:, :] = 0.0\n\n    # Check data\n    assert np.array_equal( Ta, Ta_exact )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [8, 21] )\n@pytest.mark.parametrize( 'n2', [13, 32] )\n@pytest.mark.parametrize( 'p1', [1, 3] )\n@pytest.mark.parametrize( 'p2', [1, 2] )\n@pytest.mark.parametrize( 'P1', [True, False] )\n@pytest.mark.parametrize( 'P2', [True, False] )\n@pytest.mark.parallel\n\ndef test_stencil_matrix_2d_parallel_transpose( n1, n2, p1, p2, P1, P2 ):\n\n    from mpi4py       import MPI\n    from psydac.ddm.cart import CartDecomposition\n\n    comm = MPI.COMM_WORLD\n    # Create domain decomposition\n    D = DomainDecomposition([n1,n2], periods=[P1,P2], comm=comm)\n\n    # Partition the points\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space and stencil matrix\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V )\n\n    s1, s2 = V.starts\n    e1, e2 = V.ends\n\n    # Fill in matrix values with random numbers between 0 and 1\n    M[s1:e1+1, s2:e2+1, -p1:p1+1, -p2:p2+1] = np.random.random(\n            (e1-s1+1, e2-s2+1, 2*p1+1, 2*p2+1))\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # TEST: compute transpose, then convert to Scipy sparse format\n    Ts = M.transpose().tosparse()\n\n    # Exact result: convert to Scipy sparse format, then transpose\n    Ts_exact = M.tosparse().transpose()\n\n    # Exact result: convert to Scipy sparse format including padding, then\n    # transpose, hence remove entries that do not belong to current process.\n    Ts_exact = M.tosparse( with_pads=True ).transpose()\n\n    #...\n    Ts_exact = Ts_exact.tocsr()\n    for i, j in zip(*Ts_exact.nonzero()):\n        i1, i2 = np.unravel_index( i, shape=[n1, n2], order='C' )\n        if not (s1 <= i1 <= e1 and s2 <= i2 <= e2):\n            Ts_exact[i, j] = 0.0\n    Ts_exact = Ts_exact.tocoo()\n    Ts_exact.eliminate_zeros()\n    #...\n\n    # Check data\n    assert abs(Ts - Ts_exact).max() < 1e-14\n\n#===============================================================================\n# PARALLEL BACKENDS TESTS\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [20,67] )\n@pytest.mark.parametrize( 'p1', [1,2,3] )\n@pytest.mark.parametrize( 'P1', [True, False] )\n@pytest.mark.parametrize( 'backend', [PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )\n@pytest.mark.parallel\n\ndef test_stencil_matrix_1d_parallel_backend_dot( n1, p1, P1 , backend):\n\n    from mpi4py       import MPI\n    from psydac.ddm.cart import CartDecomposition\n\n    comm = MPI.COMM_WORLD\n    # Create domain decomposition\n    D = DomainDecomposition([n1-1], periods=[P1], comm=comm)\n\n    # Partition the points\n    npts = [n1]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[1])\n\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V , backend=backend)\n    x = StencilVector( V )\n\n    s1, = V.starts\n    e1, = V.ends\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    for k1 in range(-p1,p1+1):\n        M[:,k1] = k1\n\n    # If domain is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(x.starts[0],x.ends[0]+1):\n        x[i1] = 2.0*random() - 1.0\n    x.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y = M.dot( x )\n\n    assert isinstance( y, StencilVector )\n    assert y.space is x.space\n\n    # Convert stencil objects to Scipy sparse matrix and 1D Numpy arrays\n    Ms = M.tosparse()\n    xa = x.toarray( with_pads=True )\n    ya = y.toarray()\n\n    # Exact result using Scipy sparse dot product\n    ya_exact = Ms.dot( xa )\n\n    # Check data in 1D array\n    assert np.allclose( ya, ya_exact, rtol=1e-14, atol=1e-14 )\n\n#===============================================================================\n@pytest.mark.parametrize( 'n1', [8,21] )\n@pytest.mark.parametrize( 'n2', [13,32] )\n@pytest.mark.parametrize( 'p1', [1,3] )\n@pytest.mark.parametrize( 'p2', [1,2] )\n@pytest.mark.parametrize( 'P1', [True, False] )\n@pytest.mark.parametrize( 'P2', [True, False] )\n@pytest.mark.parametrize( 'backend', [None, PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )\n@pytest.mark.parallel\n\ndef test_stencil_matrix_2d_parallel_backend_dot( n1, n2, p1, p2, P1, P2, backend):\n\n    from mpi4py       import MPI\n    from psydac.ddm.cart import CartDecomposition\n\n    comm = MPI.COMM_WORLD\n    # Create domain decomposition\n    D = DomainDecomposition([n1,n2], periods=[P1,P2], comm=comm)\n\n    # Partition the points\n    npts = [n1,n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])\n\n    # Create vector space, stencil matrix, and stencil vector\n    V = StencilVectorSpace( cart )\n    M = StencilMatrix( V, V , backend=backend)\n    x = StencilVector( V )\n\n    s1,s2 = V.starts\n    e1,e2 = V.ends\n\n    # Fill in stencil matrix values based on diagonal index (periodic!)\n    for k1 in range(-p1,p1+1):\n        for k2 in range(-p2,p2+1):\n            M[:,:,k1,k2] = 10*k1+k2\n\n    # If any dimension is not periodic, set corresponding periodic corners to zero\n    M.remove_spurious_entries()\n\n    # Fill in vector with random values, then update ghost regions\n    for i1 in range(s1,e1+1):\n        for i2 in range(s2,e2+1):\n            x[i1,i2] = 2.0*random() - 1.0\n    x.update_ghost_regions()\n\n    # Compute matrix-vector product\n    y = M.dot(x)\n\n    assert isinstance( y, StencilVector )\n    assert y.space is x.space\n\n    # Convert stencil objects to Numpy arrays\n    Ma = M.toarray()\n    xa = x.toarray( with_pads=True )\n    ya = y.toarray()\n\n    # Exact result using Numpy dot product\n    ya_exact = np.dot( Ma, xa )\n\n    # Check data in 1D array\n    assert np.allclose( ya, ya_exact, rtol=1e-13, atol=1e-13 )\n\n    # tests for backend propagation\n    assert M.backend is backend\n    assert M.T.backend is M.backend\n    assert (M+M).backend is M.backend\n    assert (2*M).backend is M.backend\n\n#===============================================================================\n# SCRIPT FUNCTIONALITY\n#===============================================================================\nif __name__ == \"__main__\":\n    import sys\n    pytest.main( sys.argv )\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/psydac/linalg/tests/test_stencil_matrix.py b/psydac/linalg/tests/test_stencil_matrix.py
--- a/psydac/linalg/tests/test_stencil_matrix.py	
+++ b/psydac/linalg/tests/test_stencil_matrix.py	
@@ -5,80 +5,172 @@
 from random import random
 
 from psydac.linalg.stencil import StencilVectorSpace, StencilVector, StencilMatrix
-from psydac.api.settings   import *
+from psydac.api.settings import *
 from psydac.ddm.cart import DomainDecomposition, CartDecomposition
 
-#===============================================================================
+
+# ===============================================================================
 def compute_global_starts_ends(domain_decomposition, npts, pads):
-    ndims         = len(npts)
-    global_starts = [None]*ndims
-    global_ends   = [None]*ndims
+    ndims = len(npts)
+    global_starts = [None] * ndims
+    global_ends = [None] * ndims
 
     for axis in range(ndims):
-        ee = domain_decomposition.global_element_ends  [axis]
+        ee = domain_decomposition.global_element_ends[axis]
 
-        global_ends  [axis]     = ee.copy()
-        global_ends  [axis][-1] = npts[axis]-1
-        global_starts[axis]     = np.array([0] + (global_ends[axis][:-1]+1).tolist())
+        global_ends[axis] = ee.copy()
+        global_ends[axis][-1] = npts[axis] - 1
+        global_starts[axis] = np.array([0] + (global_ends[axis][:-1] + 1).tolist())
 
-    for s,e,p in zip(global_starts, global_ends, pads):
-        assert all(e-s+1>=p)
+    for s, e, p in zip(global_starts, global_ends, pads):
+        assert all(e - s + 1 >= p)
 
     return tuple(global_starts), tuple(global_ends)
-#===============================================================================
+
+
+# TODO : Add test remove_spurious_entries, update_ghost_regions, exchange-assembly_data, diagonal, topetsc,
+#        ghost_regions_in_sync
+# ===============================================================================
 # SERIAL TESTS
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [7,15] )
-@pytest.mark.parametrize( 'n2', [8,12] )
-@pytest.mark.parametrize( 'p1', [1,2,3] )
-@pytest.mark.parametrize( 'p2', [1,2,3] )
-
-def test_stencil_matrix_2d_serial_init( n1, n2, p1, p2, P1=True, P2=False ):
-
-    D = DomainDecomposition([n1,n2], periods=[P1,P2])
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [7, 15])
+@pytest.mark.parametrize('n2', [8, 12])
+@pytest.mark.parametrize('p1', [2, 3, 4])
+@pytest.mark.parametrize('p2', [2, 3, 4])
+@pytest.mark.parametrize('s1', [1, 2, 3])
+@pytest.mark.parametrize('s2', [1, 2, 3])
+def test_stencil_matrix_2d_serial_init(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
+
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
+
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
+
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
+
+    assert M.domain == V
+    assert M.codomain == V
+    assert M.dtype == dtype
+    assert M.pads == (p1, p2)
+    assert M.backend == None
+    assert M._data.shape == (n1 + 2 * p1 * s1, n2 + 2 * p2 * s2, 1 + 2 * p1, 1 + 2 * p2)
+    assert M.shape == (n1 * n2, n1 * n2)
+
+# ===============================================================================
+@pytest.mark.parametrize('case', [1,2])
+@pytest.mark.parametrize('n1', [7, 15])
+@pytest.mark.parametrize('n2', [8, 12])
+@pytest.mark.parametrize('p1', [2, 3, 4])
+@pytest.mark.parametrize('p2', [2, 3, 4])
+@pytest.mark.parametrize('s1', [1, 2, 3])
+@pytest.mark.parametrize('s2', [1, 2, 3])
+def test_stencil_matrix_2d_serial_dtype_different(case, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
+
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
+
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
+
+    if case ==1:
+        V1 = StencilVectorSpace(cart, dtype=float)
+        V2 = StencilVectorSpace(cart, dtype=complex)
+    else:
+        V2 = StencilVectorSpace(cart, dtype=float)
+        V1 = StencilVectorSpace(cart, dtype=complex)
+    M = StencilMatrix(V1, V2)
+
+    assert M.domain == V1
+    assert M.codomain == V2
+    assert M.dtype == V1.dtype
+    assert M.pads == (p1, p2)
+    assert M.backend == None
+    assert M._data.shape == (n1 + 2 * p1 * s1, n2 + 2 * p2 * s2, 1 + 2 * p1, 1 + 2 * p2)
+    assert M.shape == (n1 * n2, n1 * n2)
+
+# TODO : how do we must handle different dtype ?
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [7, 15])
+@pytest.mark.parametrize('n2', [8, 12])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('p2', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1, 2, 3])
+@pytest.mark.parametrize('s2', [1, 2, 3])
+def test_stencil_matrix_2d_copy(dtype, n1, n2, p1, p2,s1,s2, P1=True, P2=False):
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
 
-    assert M._data.shape == (n1+2*p1, n2+2*p2, 1+2*p1, 1+2*p2)
-    assert M.shape == (n1*n2, n1*n2)
+    # take random data, but determinize it
+    np.random.seed(2)
+
+    if dtype == complex:
+        M._data[:] = np.random.random(M._data.shape) + 10j * np.random.random(M._data.shape)
+    else:
+        M._data[:] = np.random.random(M._data.shape)
+
+    M1 = M.copy()
+
+    assert M1.domain == V
+    assert M1.codomain == V
+    assert M1.dtype == dtype
+    assert M1.pads == (p1, p2)
+    assert M1.backend == None
+    assert M1._data.shape == (n1 + 2 * p1 * s1, n2 + 2 * p2 * s2, 1 + 2 * p1, 1 + 2 * p2)
+    assert M1.shape == (n1 * n2, n1 * n2)
+    assert np.array_equal(M1._data, M._data)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [7,15] )
-@pytest.mark.parametrize( 'n2', [8,12] )
-@pytest.mark.parametrize( 'p1', [1,2,3] )
-@pytest.mark.parametrize( 'p2', [1,2,3] )
-
-def test_stencil_matrix_2d_basic_ops( n1, n2, p1, p2, P1=True, P2=False ):
-
-    D = DomainDecomposition([n1,n2], periods=[P1,P2])
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [7, 15])
+@pytest.mark.parametrize('n2', [8, 12])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('p2', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1, 2, 3])
+@pytest.mark.parametrize('s2', [1, 2, 3])
+def test_stencil_matrix_2d_basic_ops(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
 
     # take random data, but determinize it
     np.random.seed(2)
 
-    M._data[:] = np.random.random(M._data.shape)
+    if dtype == complex:
+        M._data[:] = np.random.random(M._data.shape) + 10j * np.random.random(M._data.shape)
+    else:
+        M._data[:] = np.random.random(M._data.shape)
 
-    assert M._data.shape == (n1+2*p1, n2+2*p2, 1+2*p1, 1+2*p2)
-    assert M.shape == (n1*n2, n1*n2)
 
     # we try to go for equality here...
+    assert (M * 2).dtype == dtype
     assert np.array_equal((M * 2)._data, M._data * 2)
+    assert (M / 2).dtype == dtype
     assert np.array_equal((M / 2)._data, M._data / 2)
+    assert (M + M).dtype == dtype
     assert np.array_equal((M + M)._data, M._data + M._data)
+    assert (M - M).dtype == dtype
     assert np.array_equal((M - M)._data, M._data - M._data)
+    if dtype==complex:
+        assert (2j*M).dtype == dtype
+        assert np.array_equal((M*2j)._data, M._data*2j)
 
     M1 = M.copy()
     M1 *= 2
@@ -88,87 +180,201 @@
     M3 += M
     M4 = M.copy()
     M4 -= M
+
+    assert M1.dtype==dtype
     assert np.array_equal(M1._data, M._data * 2)
+    assert M2.dtype==dtype
     assert np.array_equal(M2._data, M._data / 2)
+    assert M3.dtype==dtype
     assert np.array_equal(M3._data, M._data + M._data)
+    assert M4.dtype==dtype
     assert np.array_equal(M4._data, M._data - M._data)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [7,15] )
-@pytest.mark.parametrize( 'n2', [8,12] )
-@pytest.mark.parametrize( 'p1', [1,2,3] )
-@pytest.mark.parametrize( 'p2', [1,2,3] )
-
-def test_stencil_matrix_2d_basic_ops_complex( n1, n2, p1, p2, P1=True, P2=False ):
-
-    D = DomainDecomposition([n1,n2], periods=[P1,P2])
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [7, 15])
+@pytest.mark.parametrize('n2', [8, 12])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('p2', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1, 2, 3])
+@pytest.mark.parametrize('s2', [1, 2, 3])
+def test_stencil_matrix_2d_math(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
-    V = StencilVectorSpace( cart, dtype=complex )
-    M = StencilMatrix( V, V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
 
     # take random data, but determinize it
     np.random.seed(2)
 
-    M._data[:] = np.random.random(M._data.shape)
+    if dtype == complex:
+        M._data[:] = np.random.random(M._data.shape) + 10j * np.random.random(M._data.shape)
+    else:
+        M._data[:] = np.random.random(M._data.shape)
 
-    assert M._data.shape == (n1+2*p1, n2+2*p2, 1+2*p1, 1+2*p2)
-    assert M.shape == (n1*n2, n1*n2)
+    M1=abs(M)
+
+
+    assert M.max()==M._data.max()
+    assert M1.domain == V
+    assert M1.codomain == V
+    assert M1.dtype == dtype
+    assert M1.pads == (p1, p2)
+    assert M1.backend == None
+    assert M1._data.shape == (n1 + 2 * p1 * s1, n2 + 2 * p2 * s2, 1 + 2 * p1, 1 + 2 * p2)
+    assert M1.shape == (n1 * n2, n1 * n2)
+    assert np.array_equal(M1._data, abs(M._data))
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('P1', [False])
+def test_stencil_matrix_1d_serial_spurious_entries( dtype, p1, s1, P1, n1=15):
+
+    # Select non-zero values based on diagonal index
+    nonzero_values = dict()
+    for k1 in range(-p1, p1 + 1):
+        nonzero_values[k1] = k1
+
+    # Create domain decomposition
+    D = DomainDecomposition([n1], periods=[P1])
+
+    # Partition the points
+    npts = [n1]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])
+
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[s1])
+
+    # Create vector space and stencil matrix
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
+
+    # Fill in stencil matrix values
+    for k1 in range(-p1, p1 + 1):
+        M[:, k1] = nonzero_values[k1]
+
+    # If any dimension is not periodic, set corresponding periodic corners to zero
+    M.remove_spurious_entries()
+    Ma=M._data
+
+    # Construct exact data array by hand
+    A = np.zeros(Ma.shape, dtype=dtype)
+    for k1 in range(-p1, p1 + 1):
+        A[:, k1+p1] = nonzero_values[k1]
+
+    if (not P1) :
+        for i1 in range( 1, p1 ):
+                A[i1, slice(-p1,-i1)] = 0
+        for i1 in range( n1-p1, n1 ):
+            A[i1, slice(n1-i1+1, p1)] = 0
+    print(A[:,:]-Ma)
+        # for i2 in range( 0, p2 ):
+        #         A[:,i1,:, slice(-p2,-i2)+p2] = 0
+
+
+    # Check shape and data in data array
+    assert np.array_equal(Ma, A)
+
+# TODO : how the index in the data work ?
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('p2', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [True])
+def test_stencil_matrix_2d_serial_spurious_entries( dtype, p1, p2, s1, s2, P1, P2, n1=15, n2=15):
+
+    # Select non-zero values based on diagonal index
+    nonzero_values = dict()
+    for k1 in range(-p1, p1 + 1):
+        for k2 in range(-p2, p2 + 1):
+            nonzero_values[k1, k2] = 10 * k1 + k2
+
+    # Create domain decomposition
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
+
+    # Partition the points
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
+
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
+
+    # Create vector space and stencil matrix
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
+
+    # Fill in stencil matrix values
+    for k1 in range(-p1, p1 + 1):
+        for k2 in range(-p2, p2 + 1):
+            M[:, :, k1, k2] = nonzero_values[k1, k2]
+
+    # If any dimension is not periodic, set corresponding periodic corners to zero
+    M.remove_spurious_entries()
+    Ma=M._data
 
-    # we try to go for equality here...
-    assert np.array_equal((M * 2)._data, M._data * 2)
-    assert np.array_equal((M / 2)._data, M._data / 2)
-    assert np.array_equal((M + M)._data, M._data + M._data)
-    assert np.array_equal((M - M)._data, M._data - M._data)
+    # Construct exact data array by hand
+    A = np.zeros(Ma.shape, dtype=dtype)
+    for k1 in range(-p1, p1 + 1):
+        for k2 in range(-p2, p2 + 1):
+            A[:, :, k1+p1, k2+p2] = nonzero_values[k1, k2]
 
-    M1 = M.copy()
-    M1 *= 2
-    M2 = M.copy()
-    M2 /= 2
-    M3 = M.copy()
-    M3 += M
-    M4 = M.copy()
-    M4 -= M
-    assert np.array_equal(M1._data, M._data * 2)
-    assert np.array_equal(M2._data, M._data / 2)
-    assert np.array_equal(M3._data, M._data + M._data)
-    assert np.array_equal(M4._data, M._data - M._data)
+    if (not P1) and P2:
+        for i1 in range( 1, p1 ):
+                A[i1, :, slice(-p1,-i1), :] = 0
+        for i1 in range( n1-p1, n1 ):
+            A[i1, :, slice(n1-i1+1, p1), :] = 0
+    print(A[:,0,:,0])
+    print(Ma[:,0,:,0])
+        # for i2 in range( 0, p2 ):
+        #         A[:,i1,:, slice(-p2,-i2)+p2] = 0
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [7,15] )
-@pytest.mark.parametrize( 'n2', [8,12] )
-@pytest.mark.parametrize( 'p1', [1,2,3] )
-@pytest.mark.parametrize( 'p2', [1,2,3] )
-
-def test_stencil_matrix_2d_serial_toarray( n1, n2, p1, p2, P1=False, P2=True ):
-
+
+    # Check shape and data in data array
+    assert np.array_equal(Ma, A)
+
+# TODO : how the index in the data work ?
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [7, 15])
+@pytest.mark.parametrize('n2', [8, 12])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('p2', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
+def test_stencil_matrix_2d_serial_toarray( dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # Select non-zero values based on diagonal index
     nonzero_values = dict()
-    for k1 in range(-p1,p1+1):
-        for k2 in range(-p2,p2+1):
-            nonzero_values[k1,k2] = 10*k1 + k2
+    for k1 in range(-p1, p1 + 1):
+        for k2 in range(-p2, p2 + 1):
+            nonzero_values[k1, k2] = 10 * k1 + k2
 
     # Create domain decomposition
-    D = DomainDecomposition([n1,n2], periods=[P1,P2])
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     # Partition the points
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space and stencil matrix
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
 
     # Fill in stencil matrix values
-    for k1 in range(-p1,p1+1):
-        for k2 in range(-p2,p2+1):
-            M[:,:,k1,k2] = nonzero_values[k1,k2]
+    for k1 in range(-p1, p1 + 1):
+        for k2 in range(-p2, p2 + 1):
+            M[:, :, k1, k2] = nonzero_values[k1, k2]
 
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
@@ -177,29 +383,98 @@
     Ma = M.toarray()
 
     # Construct exact matrix by hand
-    A = np.zeros( M.shape )
+    A = np.zeros(M.shape, dtype=dtype)
     for i1 in range(n1):
         for i2 in range(n2):
-            for k1 in range(-p1,p1+1):
-                for k2 in range(-p2,p2+1):
-                    j1 = (i1+k1) % n1
-                    j2 = (i2+k2) % n2
-                    i  = i1*(n2) + i2
-                    j  = j1*(n2) + j2
-                    if (P1 or 0 <= i1+k1 < n1) and (P2 or 0 <= i2+k2 < n2):
-                        A[i,j] = nonzero_values[k1,k2]
+            for k1 in range(-p1, p1 + 1):
+                for k2 in range(-p2, p2 + 1):
+                    j1 = (i1 + k1) % n1
+                    j2 = (i2 + k2) % n2
+                    i = i1 * (n2) + i2
+                    j = j1 * (n2) + j2
+                    if (P1 or 0 <= i1 + k1 < n1) and (P2 or 0 <= i2 + k2 < n2):
+                        A[i, j] = nonzero_values[k1, k2]
 
     # Check shape and data in 2D array
     assert Ma.shape == M.shape
-    assert np.all( Ma == A )
+    assert np.array_equal(Ma, A)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [10,32] )
-@pytest.mark.parametrize( 'p1', [1,2,3] )
-@pytest.mark.parametrize( 'P1', [True, False] )
-
-def test_stencil_matrix_1d_serial_dot( n1, p1, P1 ):
-
+# TODO : understand why it's not working when s>1
+# ===============================================================================
+
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [7, 15])
+@pytest.mark.parametrize('n2', [8, 12])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('p2', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
+def test_stencil_matrix_2d_serial_tosparse( dtype, n1, n2, p1, p2, s1, s2, P1, P2):
+    # Select non-zero values based on diagonal index
+    nonzero_values = dict()
+    for k1 in range(-p1, p1 + 1):
+        for k2 in range(-p2, p2 + 1):
+            nonzero_values[k1, k2] = 10 * k1 + k2
+
+    # Create domain decomposition
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
+
+    # Partition the points
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
+
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
+
+    # Create vector space and stencil matrix
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
+
+    # Fill in stencil matrix values
+    for k1 in range(-p1, p1 + 1):
+        for k2 in range(-p2, p2 + 1):
+            M[:, :, k1, k2] = nonzero_values[k1, k2]
+
+    # If any dimension is not periodic, set corresponding periodic corners to zero
+    M.remove_spurious_entries()
+
+    # Convert stencil matrix to 2D array
+    Ms = M.tosparse()
+
+    # Construct exact matrix by hand
+    data=[]
+    i_vec=[]
+    j_vec=[]
+    for i1 in range(n1):
+        for i2 in range(n2):
+            for k1 in range(-p1, p1 + 1):
+                for k2 in range(-p2, p2 + 1):
+                    j1 = (i1 + k1) % n1
+                    j2 = (i2 + k2) % n2
+                    i = i1 * (n2) + i2
+                    j = j1 * (n2) + j2
+                    if (P1 or 0 <= i1 + k1 < n1) and (P2 or 0 <= i2 + k2 < n2):
+                        if not nonzero_values[k1,k2]==0:
+                            data.append(nonzero_values[k1,k2])
+                            i_vec.append(i)
+                            j_vec.append(j)
+
+    from scipy.sparse import coo_matrix
+    Ms_exa=coo_matrix((data, (i_vec, j_vec)), shape=[n1*n2,n1*n2], dtype=dtype)
+
+    # Check shape and data in 2D array
+    assert Ms.shape == M.shape
+    assert np.array_equal(Ms.toarray(), Ms_exa.toarray())
+
+# TODO: verify for s>1
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [10, 32])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('P1', [True, False])
+def test_stencil_matrix_1d_serial_dot(dtype, n1, p1, s1, P1):
     # Create domain decomposition
     D = DomainDecomposition([n1], periods=[P1])
 
@@ -207,29 +482,38 @@
     npts = [n1]
     global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[s1])
 
     # Create vector space, stencil matrix, and stencil vector
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V )
-    x = StencilVector( V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
+    x = StencilVector(V)
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    for k1 in range(-p1,p1+1):
-        M[:,k1] = k1
+    if dtype==complex:
+        for k1 in range(-p1, p1 + 1):
+            M[:, k1] = (1+1j)*k1
+    else:
+        for k1 in range(-p1, p1 + 1):
+            M[:, k1] = k1
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(n1):
-        x[i1] = 2.0*random() - 1.0
+    if dtype==complex:
+        for i1 in range(n1):
+            x[i1] = (2.0+3j) * random() - 1.0
+    else:
+        for i1 in range(n1):
+            x[i1] = 2.0 * random() - 1.0
+
     x.update_ghost_regions()
 
     # Compute matrix-vector product
     y = M.dot(x)
 
-    assert isinstance( y, StencilVector )
+    assert isinstance(y, StencilVector)
     assert y.space is x.space
 
     # Convert stencil objects to Scipy sparse matrix and 1D Numpy arrays
@@ -238,47 +522,61 @@
     ya = y.toarray()
 
     # Exact result using Scipy sparse dot product
-    ya_exact = Ms.dot( xa )
+    ya_exact = Ms.dot(xa)
 
     # Check data in 1D array
-    assert np.allclose( ya, ya_exact, rtol=1e-14, atol=1e-14 )
+    assert y.dtype == dtype
+    assert np.allclose(ya, ya_exact, rtol=1e-14, atol=1e-14)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [5,15] )
-@pytest.mark.parametrize( 'n2', [5,12] )
-@pytest.mark.parametrize( 'p1', [1,2,3] )
-@pytest.mark.parametrize( 'p2', [1,2,3] )
-@pytest.mark.parametrize( 'P1', [True, False] )
-@pytest.mark.parametrize( 'P2', [True, False] )
-
-def test_stencil_matrix_2d_serial_dot_1( n1, n2, p1, p2, P1, P2 ):
-
+# TODO: verify for s>1
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 15])
+@pytest.mark.parametrize('n2', [5, 12])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('p2', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
+# Case where domain and codomain are the same and matrix pads are the same
+def test_stencil_matrix_2d_serial_dot_1(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # Create domain decomposition
-    D = DomainDecomposition([n1,n2], periods=[P1,P2])
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     # Partition the points
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space, stencil matrix, and stencil vector
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V )
-    x = StencilVector( V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
+    x = StencilVector(V)
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    for k1 in range(-p1,p1+1):
-        for k2 in range(-p2,p2+1):
-            M[:,:,k1,k2] = 10*k1+k2
+    if dtype==complex:
+        for k1 in range(-p1, p1 + 1):
+            for k2 in range(-p2, p2 + 1):
+                M[:, :, k1, k2] = 10 * k1 + 1j*k2
+    else:
+        for k1 in range(-p1, p1 + 1):
+            for k2 in range(-p2, p2 + 1):
+                M[:, :, k1, k2] = 10 * k1 + k2
 
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(n1):
-        for i2 in range(n2):
-            x[i1,i2] = 2.0*random() - 1.0
+    if dtype==complex:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 2.0 * random() - 1.0j
+    else:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 2.0 * random() - 1.0
     x.update_ghost_regions()
 
     # Compute matrix-vector product
@@ -290,59 +588,74 @@
     ya = y.toarray()
 
     # Exact result using Numpy dot product
-    ya_exact = np.dot( Ma, xa )
+    ya_exact = np.dot(Ma, xa)
 
     # Check data in 1D array
-    assert np.allclose( ya, ya_exact, rtol=1e-13, atol=1e-13 )
+    assert y.dtype==dtype
+    assert np.allclose(ya, ya_exact, rtol=1e-13, atol=1e-13)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [5,15] )
-@pytest.mark.parametrize( 'n2', [5,12] )
-@pytest.mark.parametrize( 'p1', [2,3] )
-@pytest.mark.parametrize( 'p2', [2,3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-
-def test_stencil_matrix_2d_serial_dot_2( n1, n2, p1, p2, P1, P2 ):
-
+# TODO: verify for s>1
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 15])
+@pytest.mark.parametrize('n2', [5, 12])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+# Case where domain and codomain have different size for both dimension and matrix pads are the same
+def test_stencil_matrix_2d_serial_dot_2(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts1 = [n1,n2]
-    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])
+    npts1 = [n1, n2]
+    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1, p2])
 
-    npts2 = [n1-1,n2-1]
-    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])
+    npts2 = [n1 - 1, n2 - 1]
+    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1, p2])
 
-    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])
-    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])
+    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1, p2], shifts=[s1, s2])
+    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space, stencil matrix, and stencil vector
-    V1 = StencilVectorSpace( cart1 )
-    V2 = StencilVectorSpace( cart2 )
-
-    M1 = StencilMatrix( V1, V2 ,pads=(p1,p2))
-    M2 = StencilMatrix( V2, V1 ,pads=(p1,p2))
-    x1 = StencilVector( V1 )
-    x2 = StencilVector( V2 )
+    V1 = StencilVectorSpace(cart1, dtype=dtype)
+    V2 = StencilVectorSpace(cart2, dtype=dtype)
+    M1 = StencilMatrix(V1, V2, pads=(p1, p2))
+    M2 = StencilMatrix(V2, V1, pads=(p1, p2))
+    x1 = StencilVector(V1)
+    x2 = StencilVector(V2)
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    M1._data[p1:-p1, p2:-p2, :, :] = np.random.random(M1._data[p1:-p1, p2:-p2, :, :].shape)
-    M2._data[p1:-p1, p2:-p2, :, :] = np.random.random(M2._data[p1:-p1, p2:-p2, :, :].shape)
+    if dtype==complex:
+        M1._data[p1:-p1, p2:-p2, :, :] = np.random.random(M1._data[p1:-p1, p2:-p2, :, :].shape)+1j*np.random.random(M1._data[p1:-p1, p2:-p2, :, :].shape)
+        M2._data[p1:-p1, p2:-p2, :, :] = np.random.random(M2._data[p1:-p1, p2:-p2, :, :].shape)+1j*np.random.random(M2._data[p1:-p1, p2:-p2, :, :].shape)
+    else:
+        M1._data[p1:-p1, p2:-p2, :, :] = np.random.random(M1._data[p1:-p1, p2:-p2, :, :].shape)
+        M2._data[p1:-p1, p2:-p2, :, :] = np.random.random(M2._data[p1:-p1, p2:-p2, :, :].shape)
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M1.remove_spurious_entries()
     M2.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(n1):
-        for i2 in range(n2-1):
-            x1[i1,i2] = 2.0*random() - 1.0
-    x1.update_ghost_regions()
-
-    for i1 in range(n1-1):
-        for i2 in range(n2-1):
-            x2[i1,i2] = 2.0*random() - 1.0
+    if dtype ==complex:
+        for i1 in range(n1):
+            for i2 in range(n2 - 1):
+                x1[i1, i2] = (2.0+1j) * random() - 1.0
+        for i1 in range(n1 - 1):
+            for i2 in range(n2 - 1):
+                x2[i1, i2] = (2.0+1j)  * random() - 1.0
+    else:
+        for i1 in range(n1):
+            for i2 in range(n2 - 1):
+                x1[i1, i2] = 2.0 * random() - 1.0
+        for i1 in range(n1 - 1):
+            for i2 in range(n2 - 1):
+                x2[i1, i2] = 2.0 * random() - 1.0
+    x1.update_ghost_regions()
     x2.update_ghost_regions()
 
     # Compute matrix-vector product
@@ -359,62 +672,78 @@
     y2a = y2.toarray()
 
     # Exact result using Numpy dot product
-    y1a_exact = np.dot( M1a, x1a )
-    y2a_exact = np.dot( M2a, x2a )
+    y1a_exact = np.dot(M1a, x1a)
+    y2a_exact = np.dot(M2a, x2a)
 
     # Check data in 1D array
-
-    assert np.allclose( y1a, y1a_exact, rtol=1e-13, atol=1e-13 )
-    assert np.allclose( y2a, y2a_exact, rtol=1e-13, atol=1e-13 )
+    assert y1.dtype == dtype
+    assert y2.dtype == dtype
+    assert np.allclose(y1a, y1a_exact, rtol=1e-13, atol=1e-13)
+    assert np.allclose(y2a, y2a_exact, rtol=1e-13, atol=1e-13)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [5,15] )
-@pytest.mark.parametrize( 'n2', [5,12] )
-@pytest.mark.parametrize( 'p1', [2,3] )
-@pytest.mark.parametrize( 'p2', [2,3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-
-def test_stencil_matrix_2d_serial_dot_3( n1, n2, p1, p2, P1, P2 ):
-
+# TODO: verify for s>1
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 15])
+@pytest.mark.parametrize('n2', [5, 12])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+# Case where domain and codomain have different size for first dimension and matrix pads are different
+def test_stencil_matrix_2d_serial_dot_3(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts1 = [n1,n2-1]
-    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])
+    npts1 = [n1, n2 - 1]
+    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1, p2])
 
-    npts2 = [n1-1,n2-1]
-    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])
+    npts2 = [n1 - 1, n2 - 1]
+    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1, p2])
 
-    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])
-    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])
+    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1, p2], shifts=[s1, s2])
+    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space, stencil matrix, and stencil vector
-    V1 = StencilVectorSpace( cart1 )
-    V2 = StencilVectorSpace( cart2 )
-    M1 = StencilMatrix( V1, V2 ,pads=(p1,p2-1))
-    M2 = StencilMatrix( V2, V1 ,pads=(p1,p2-1))
-    x1 = StencilVector( V1 )
-    x2 = StencilVector( V2 )
+    V1 = StencilVectorSpace(cart1, dtype=dtype)
+    V2 = StencilVectorSpace(cart2, dtype=dtype)
+    M1 = StencilMatrix(V1, V2, pads=(p1, p2 - 1))
+    M2 = StencilMatrix(V2, V1, pads=(p1, p2 - 1))
+    x1 = StencilVector(V1)
+    x2 = StencilVector(V2)
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    M1[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1+1, 2*p2-1))
-    M2[0:n1, 0:n2-1, :, :]   = np.random.random((n1, n2-1, 2*p1+1, 2*p2-1))
+    if dtype==complex:
+        M1[0:n1 - 1, 0:n2 - 1, :, :] = np.random.random((n1 - 1, n2 - 1, 2 * p1 + 1, 2 * p2 - 1))+1j*np.random.random((n1 - 1, n2 - 1, 2 * p1 + 1, 2 * p2 - 1))
+        M2[0:n1, 0:n2 - 1, :, :] = np.random.random((n1, n2 - 1, 2 * p1 + 1, 2 * p2 - 1))+1j*np.random.random((n1, n2 - 1, 2 * p1 + 1, 2 * p2 - 1))
+    else:
+        M1[0:n1 - 1, 0:n2 - 1, :, :] = np.random.random((n1 - 1, n2 - 1, 2 * p1 + 1, 2 * p2 - 1))
+        M2[0:n1, 0:n2 - 1, :, :] = np.random.random((n1, n2 - 1, 2 * p1 + 1, 2 * p2 - 1))
 
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M1.remove_spurious_entries()
     M2.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(n1):
-        for i2 in range(n2-1):
-            x1[i1,i2] = 2.0*random() - 1.0
-    x1.update_ghost_regions()
-
-    for i1 in range(n1-1):
-        for i2 in range(n2-1):
-            x2[i1,i2] = 2.0*random() - 1.0
+    if dtype == complex:
+        for i1 in range(n1):
+            for i2 in range(n2 - 1):
+                x1[i1, i2] = (2.0+1j) * random() - 1.0
+        for i1 in range(n1 - 1):
+            for i2 in range(n2 - 1):
+                x2[i1, i2] = (2.0+1j) * random() - 1.0
+    else:
+        for i1 in range(n1):
+            for i2 in range(n2 - 1):
+                x1[i1, i2] = 2.0 * random() - 1.0
+        for i1 in range(n1 - 1):
+            for i2 in range(n2 - 1):
+                x2[i1, i2] = 2.0 * random() - 1.0
+    x1.update_ghost_regions()
     x2.update_ghost_regions()
 
     # Compute matrix-vector product
@@ -431,61 +760,78 @@
     y2a = y2.toarray()
 
     # Exact result using Numpy dot product
-    y1a_exact = np.dot( M1a, x1a )
-    y2a_exact = np.dot( M2a, x2a )
+    y1a_exact = np.dot(M1a, x1a)
+    y2a_exact = np.dot(M2a, x2a)
 
     # Check data in 1D array
-
-    assert np.allclose( y1a, y1a_exact, rtol=1e-13, atol=1e-13 )
-    assert np.allclose( y2a, y2a_exact, rtol=1e-13, atol=1e-13 )
+    assert y1.dtype==dtype
+    assert y2.dtype==dtype
+    assert np.allclose(y1a, y1a_exact, rtol=1e-13, atol=1e-13)
+    assert np.allclose(y2a, y2a_exact, rtol=1e-13, atol=1e-13)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [5,15] )
-@pytest.mark.parametrize( 'n2', [5,12] )
-@pytest.mark.parametrize( 'p1', [2,3] )
-@pytest.mark.parametrize( 'p2', [2,3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-
-def test_stencil_matrix_2d_serial_dot_4( n1, n2, p1, p2, P1, P2 ):
-
+# TODO: verify for s>1
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 15])
+@pytest.mark.parametrize('n2', [5, 12])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+# Case where domain and codomain have different size for second dimension and matrix pads are different
+def test_stencil_matrix_2d_serial_dot_4(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts1 = [n1-1,n2]
-    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])
+    npts1 = [n1 - 1, n2]
+    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1, p2])
 
-    npts2 = [n1-1,n2-1]
-    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])
+    npts2 = [n1 - 1, n2 - 1]
+    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1, p2])
 
-    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])
-    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])
+    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1, p2], shifts=[s1, s2])
+    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space, stencil matrix, and stencil vector
-    V1 = StencilVectorSpace( cart1 )
-    V2 = StencilVectorSpace( cart2 )
-    M1 = StencilMatrix( V1, V2, pads=(p1-1,p2))
-    M2 = StencilMatrix( V2, V1, pads=(p1-1,p2))
-    x1 = StencilVector( V1 )
-    x2 = StencilVector( V2 )
+    V1 = StencilVectorSpace(cart1, dtype=dtype)
+    V2 = StencilVectorSpace(cart2, dtype=dtype)
+    M1 = StencilMatrix(V1, V2, pads=(p1 - 1, p2))
+    M2 = StencilMatrix(V2, V1, pads=(p1 - 1, p2))
+    x1 = StencilVector(V1)
+    x2 = StencilVector(V2)
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    M1[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1-1, 2*p2+1))
-    M2[0:n1-1, 0:n2  , :, :] = np.random.random((n1-1, n2  , 2*p1-1, 2*p2+1))
+    if dtype==complex:
+        M1[0:n1 - 1, 0:n2 - 1, :, :] = np.random.random((n1 - 1, n2 - 1, 2 * p1 - 1, 2 * p2 + 1))+1j*np.random.random((n1 - 1, n2 - 1, 2 * p1 - 1, 2 * p2 + 1))
+        M2[0:n1 - 1, 0:n2, :, :] = np.random.random((n1 - 1, n2, 2 * p1 - 1, 2 * p2 + 1))+1j*np.random.random((n1 - 1, n2, 2 * p1 - 1, 2 * p2 + 1))
+    else:
+        M1[0:n1 - 1, 0:n2 - 1, :, :] = np.random.random((n1 - 1, n2 - 1, 2 * p1 - 1, 2 * p2 + 1))
+        M2[0:n1 - 1, 0:n2, :, :] = np.random.random((n1 - 1, n2, 2 * p1 - 1, 2 * p2 + 1))
+
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M1.remove_spurious_entries()
     M2.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(n1-1):
-        for i2 in range(n2):
-            x1[i1,i2] = 2.0*random() - 1.0
-    x1.update_ghost_regions()
-
-    for i1 in range(n1-1):
-        for i2 in range(n2-1):
-            x2[i1,i2] = 2.0*random() - 1.0
+
+    if dtype==complex:
+        for i1 in range(n1 - 1):
+            for i2 in range(n2):
+                x1[i1, i2] = (2.0+1j) * random() - 1.0
+        for i1 in range(n1 - 1):
+            for i2 in range(n2 - 1):
+                x2[i1, i2] = (2.0+1j) * random() - 1.0
+    else:
+        for i1 in range(n1 - 1):
+            for i2 in range(n2):
+                x1[i1, i2] = 2.0 * random() - 1.0
+        for i1 in range(n1 - 1):
+            for i2 in range(n2 - 1):
+                x2[i1, i2] = 2.0 * random() - 1.0
+    x1.update_ghost_regions()
     x2.update_ghost_regions()
 
     # Compute matrix-vector product
@@ -502,61 +848,80 @@
     y2a = y2.toarray()
 
     # Exact result using Numpy dot product
-    y1a_exact = np.dot( M1a, x1a )
-    y2a_exact = np.dot( M2a, x2a )
+    y1a_exact = np.dot(M1a, x1a)
+    y2a_exact = np.dot(M2a, x2a)
 
     # Check data in 1D array
 
-    assert np.allclose( y1a, y1a_exact, rtol=1e-13, atol=1e-13 )
-    assert np.allclose( y2a, y2a_exact, rtol=1e-13, atol=1e-13 )
+    assert np.allclose(y1a, y1a_exact, rtol=1e-13, atol=1e-13)
+    assert np.allclose(y2a, y2a_exact, rtol=1e-13, atol=1e-13)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [5,15] )
-@pytest.mark.parametrize( 'n2', [5,12] )
-@pytest.mark.parametrize( 'p1', [2,3] )
-@pytest.mark.parametrize( 'p2', [2,3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-
-def test_stencil_matrix_2d_serial_dot_5( n1, n2, p1, p2, P1, P2 ):
-
+# TODO: verify for s>1
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 15])
+@pytest.mark.parametrize('n2', [5, 12])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+# Case where domain and codomain have different size for second dimension and matrix pads are the same
+def test_stencil_matrix_2d_serial_dot_5(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts1 = [n1-1,n2]
-    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])
+    npts1 = [n1 - 1, n2]
+    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1, p2])
 
-    npts2 = [n1-1,n2-1]
-    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])
+    npts2 = [n1 - 1, n2 - 1]
+    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1, p2])
 
-    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])
-    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])
+    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1, p2], shifts=[s1, s2])
+    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space, stencil matrix, and stencil vector
-    V1 = StencilVectorSpace( cart1 )
-    V2 = StencilVectorSpace( cart2 )
-    M1 = StencilMatrix( V1, V2 ,pads=(p1,p2))
-    M2 = StencilMatrix( V2, V1 ,pads=(p1,p2))
-    x1 = StencilVector( V1 )
-    x2 = StencilVector( V2 )
+    V1 = StencilVectorSpace(cart1, dtype=dtype)
+    V2 = StencilVectorSpace(cart2, dtype=dtype)
+    M1 = StencilMatrix(V1, V2, pads=(p1, p2))
+    M2 = StencilMatrix(V2, V1, pads=(p1, p2))
+    x1 = StencilVector(V1)
+    x2 = StencilVector(V2)
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    M1[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1+1, 2*p2+1))
-    M2[0:n1-1, 0:n2, :, :] = np.random.random((n1-1, n2, 2*p1+1, 2*p2+1))
+    if dtype==complex:
+        M1[0:n1 - 1, 0:n2 - 1, :, :] = np.random.random((n1 - 1, n2 - 1, 2 * p1 + 1, 2 * p2 + 1))+1j*np.random.random((n1 - 1, n2 - 1, 2 * p1 + 1, 2 * p2 + 1))
+        M2[0:n1 - 1, 0:n2, :, :] = np.random.random((n1 - 1, n2, 2 * p1 + 1, 2 * p2 + 1))+1j*np.random.random((n1 - 1, n2, 2 * p1 + 1, 2 * p2 + 1))
+    else:
+        M1[0:n1 - 1, 0:n2 - 1, :, :] = np.random.random((n1 - 1, n2 - 1, 2 * p1 + 1, 2 * p2 + 1))
+        M2[0:n1 - 1, 0:n2, :, :] = np.random.random((n1 - 1, n2, 2 * p1 + 1, 2 * p2 + 1))
+
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M1.remove_spurious_entries()
     M2.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(n1-1):
-        for i2 in range(n2):
-            x1[i1,i2] = 2.0*random() - 1.0
-    x1.update_ghost_regions()
-
-    for i1 in range(n1-1):
-        for i2 in range(n2-1):
-            x2[i1,i2] = 2.0*random() - 1.0
+
+
+    if dtype==complex:
+        for i1 in range(n1 - 1):
+            for i2 in range(n2):
+                x1[i1, i2] = (2.0+1j) * random() - 1.0
+        for i1 in range(n1 - 1):
+            for i2 in range(n2 - 1):
+                x2[i1, i2] = (2.0+1j) * random() - 1.0
+    else:
+        for i1 in range(n1 - 1):
+            for i2 in range(n2):
+                x1[i1, i2] = 2.0 * random() - 1.0
+        for i1 in range(n1 - 1):
+            for i2 in range(n2 - 1):
+                x2[i1, i2] = 2.0 * random() - 1.0
+
+    x1.update_ghost_regions()
     x2.update_ghost_regions()
 
     # Compute matrix-vector product
@@ -573,50 +938,64 @@
     y2a = y2.toarray()
 
     # Exact result using Numpy dot product
-    y1a_exact = np.dot( M1a, x1a )
-    y2a_exact = np.dot( M2a, x2a )
+    y1a_exact = np.dot(M1a, x1a)
+    y2a_exact = np.dot(M2a, x2a)
 
     # Check data in 1D array
 
-    assert np.allclose( y1a, y1a_exact, rtol=1e-13, atol=1e-13 )
-    assert np.allclose( y2a, y2a_exact, rtol=1e-13, atol=1e-13 )
+    assert np.allclose(y1a, y1a_exact, rtol=1e-13, atol=1e-13)
+    assert np.allclose(y2a, y2a_exact, rtol=1e-13, atol=1e-13)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [5,15] )
-@pytest.mark.parametrize( 'n2', [5,12] )
-@pytest.mark.parametrize( 'p1', [2,3] )
-@pytest.mark.parametrize( 'p2', [2,3] )
-@pytest.mark.parametrize( 'P1', [True] )
-@pytest.mark.parametrize( 'P2', [True] )
-
-def test_stencil_matrix_2d_serial_dot_6( n1, n2, p1, p2, P1, P2 ):
-
+# TODO: verify for s>1
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 15])
+@pytest.mark.parametrize('n2', [5, 12])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [True])
+@pytest.mark.parametrize('P2', [True])
+# Case where domain and codomain have different size for both dimension and matrix pads are different
+def test_stencil_matrix_2d_serial_dot_6(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space, stencil matrix, and stencil vector
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V , pads=(p1-1, p2-1))
-    x = StencilVector( V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V, pads=(p1 - 1, p2 - 1))
+    x = StencilVector(V)
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    for k1 in range(-p1+1,p1):
-        for k2 in range(-p2+1,p2):
-            M[:,:,k1,k2] = 10*k1+k2
+    if dtype==complex:
+        for k1 in range(-p1 + 1, p1):
+            for k2 in range(-p2 + 1, p2):
+                M[:, :, k1, k2] = 10 * k1 + 1j*k2
+    else:
+        for k1 in range(-p1 + 1, p1):
+            for k2 in range(-p2 + 1, p2):
+                M[:, :, k1, k2] = 10 * k1 + k2
 
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(n1):
-        for i2 in range(n2):
-            x[i1,i2] = 2.0*random() - 1.0
+    if dtype==complex:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 2.0 * random() - 1.0j
+    else:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 2.0 * random() - 1.0
     x.update_ghost_regions()
 
     # Compute matrix-vector product
@@ -628,33 +1007,35 @@
     ya = y.toarray()
 
     # Exact result using Numpy dot product
-    ya_exact = np.dot( Ma, xa )
+    ya_exact = np.dot(Ma, xa)
 
     # Check data in 1D array
-    assert np.allclose( ya, ya_exact, rtol=1e-13, atol=1e-13 )
+    assert np.allclose(ya, ya_exact, rtol=1e-13, atol=1e-13)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [4, 10, 32] )
-@pytest.mark.parametrize( 'p1', [1, 2, 3] )
-@pytest.mark.parametrize( 'P1', [True, False] )
-
-def test_stencil_matrix_1d_serial_transpose( n1, p1, P1 ):
-
+# TODO: verify for s>1
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [4, 10, 32])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('s1', [1])
+def test_stencil_matrix_1d_serial_transpose(dtype, n1, p1, s1, P1):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1], periods=[P1])
+    D = DomainDecomposition([n1 - 1], periods=[P1])
 
     # Partition the points
     npts = [n1]
     global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[s1])
 
     # Create vector space and stencil matrix
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[0:n1, -p1:p1+1] = np.random.random( (n1, 2*p1+1) )
+    M[0:n1, -p1:p1 + 1] = np.random.random((n1, 2 * p1 + 1))
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
@@ -666,33 +1047,41 @@
     Ta_exact = M.toarray().transpose()
 
     # Check data
-    assert np.array_equal( Ta, Ta_exact )
+    assert M.transpose().dtype==dtype
+    assert np.array_equal(Ta, Ta_exact)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [5, 15] )
-@pytest.mark.parametrize( 'n2', [5, 12] )
-@pytest.mark.parametrize( 'p1', [1, 2, 3] )
-@pytest.mark.parametrize( 'p2', [1, 2, 3] )
-@pytest.mark.parametrize( 'P1', [True, False] )
-@pytest.mark.parametrize( 'P2', [True, False] )
-
-def test_stencil_matrix_2d_serial_transpose_1( n1, n2, p1, p2, P1, P2 ):
-
+# TODO: verify for s>1
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 15])
+@pytest.mark.parametrize('n2', [5, 12])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('p2', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
+# Case where domain and codomain have the same size for both dimension and matrix pads the same
+def test_stencil_matrix_2d_serial_transpose_1(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space and stencil matrix
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[0:n1, 0:n2, :, :] = np.random.random((n1, n2, 2*p1+1, 2*p2+1))
+    if dtype == complex:
+        M[0:n1, 0:n2, :, :] = np.random.random((n1, n2, 2 * p1 + 1, 2 * p2 + 1))+1j*np.random.random((n1, n2, 2 * p1 + 1, 2 * p2 + 1))
+    else:
+        M[0:n1, 0:n2, :, :] = np.random.random((n1, n2, 2 * p1 + 1, 2 * p2 + 1))
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
@@ -704,447 +1093,540 @@
     Ts_exact = M.tosparse().transpose()
 
     # Check data
+    assert M.transpose().dtype==dtype
+    assert Ts.dtype==dtype
     assert abs(Ts - Ts_exact).max() < 1e-14
+    assert abs(Ts - M.T.tosparse()).max() < 1e-14
+
+# TODO: verify for s>1
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [5, 12] )
-@pytest.mark.parametrize( 'n2', [6, 10] )
-@pytest.mark.parametrize( 'p1', [1, 2, 3] )
-@pytest.mark.parametrize( 'p2', [1, 2, 3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-
-def test_stencil_matrix_2d_serial_transpose_2( n1, n2, p1, p2, P1, P2 ):
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 12])
+@pytest.mark.parametrize('n2', [6, 10])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('p2', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+# Case where domain and codomain have different size for both dimension and matrix pads the same
+def test_stencil_matrix_2d_serial_transpose_2(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # This should only work with non periodic boundaries
 
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts1 = [n1,n2]
-    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])
+    npts1 = [n1, n2]
+    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1, p2])
 
-    npts2 = [n1-1,n2-1]
-    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])
+    npts2 = [n1 - 1, n2 - 1]
+    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1, p2])
 
-    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])
-    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])
+    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1, p2], shifts=[s1, s2])
+    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space and stencil matrix
-    V1 = StencilVectorSpace( cart1 )
-    V2 = StencilVectorSpace( cart2 )
-    M  = StencilMatrix(V1, V2, pads=(p1,p2))
+    V1 = StencilVectorSpace(cart1, dtype=dtype)
+    V2 = StencilVectorSpace(cart2, dtype=dtype)
+    M = StencilMatrix(V1, V2, pads=(p1, p2))
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1+1, 2*p2+1))
+    if dtype == complex:
+        M[0:n1- 1, 0:n2, :, :] = np.random.random((n1- 1, n2, 2 * p1 + 1, 2 * p2 + 1))+1j*np.random.random((n1- 1, n2, 2 * p1 + 1, 2 * p2 + 1))
+    else:
+        M[0:n1- 1, 0:n2, :, :] = np.random.random((n1- 1, n2, 2 * p1 + 1, 2 * p2 + 1))
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # TEST: compute transpose, then convert to Scipy sparse format
-    Ts = M.transpose().transpose().tosparse()
+    Ts = M.transpose().tosparse()
 
     # Exact result: convert to Scipy sparse format, then transpose
-    Ts_exact = M.tosparse()
+    Ts_exact = M.tosparse().transpose()
 
     # Check data
+    assert M.transpose().dtype==dtype
+    assert Ts.dtype==dtype
     assert abs(Ts - Ts_exact).max() < 1e-14
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [5, 12] )
-@pytest.mark.parametrize( 'n2', [6, 10] )
-@pytest.mark.parametrize( 'p1', [1, 2, 3] )
-@pytest.mark.parametrize( 'p2', [1, 2, 3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-
-def test_stencil_matrix_2d_serial_transpose_3( n1, n2, p1, p2, P1, P2 ):
+# TODO: verify for s>1
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 12])
+@pytest.mark.parametrize('n2', [6, 10])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('p2', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+# Case where domain and codomain have different size for the first dimension and matrix pads the same
+def test_stencil_matrix_2d_serial_transpose_3(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # This should only work with non periodic boundaries
 
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts1 = [n1,n2]
-    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])
+    npts1 = [n1, n2]
+    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1, p2])
 
-    npts2 = [n1-1,n2]
-    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])
+    npts2 = [n1 - 1, n2]
+    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1, p2])
 
-    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])
-    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])
+    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1, p2], shifts=[s1, s2])
+    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space and stencil matrix
-    V1 = StencilVectorSpace( cart1 )
-    V2 = StencilVectorSpace( cart2 )
-    M  = StencilMatrix(V1, V2, pads=(p1,p2))
+    V1 = StencilVectorSpace(cart1, dtype=dtype)
+    V2 = StencilVectorSpace(cart2, dtype=dtype)
+    M = StencilMatrix(V1, V2, pads=(p1, p2))
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[0:n1-1, 0:n2, :, :] = np.random.random((n1-1, n2, 2*p1+1, 2*p2+1))
+    if dtype == complex:
+        M[0:n1- 1, 0:n2, :, :] = np.random.random((n1- 1, n2, 2 * p1 + 1, 2 * p2 + 1))+1j*np.random.random((n1- 1, n2, 2 * p1 + 1, 2 * p2 + 1))
+    else:
+        M[0:n1- 1, 0:n2, :, :] = np.random.random((n1- 1, n2, 2 * p1 + 1, 2 * p2 + 1))
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # TEST: compute transpose, then convert to Scipy sparse format
-    Ts = M.transpose().transpose().tosparse()
+    Ts = M.transpose().tosparse()
 
     # Exact result: convert to Scipy sparse format, then transpose
-    Ts_exact = M.tosparse()
+    Ts_exact = M.tosparse().transpose()
 
     # Check data
     assert abs(Ts - Ts_exact).max() < 1e-14
+    assert abs(Ts - M.T.tosparse()).max() < 1e-14
+
+# TODO: verify for s>1
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [5, 12] )
-@pytest.mark.parametrize( 'n2', [6, 10] )
-@pytest.mark.parametrize( 'p1', [1, 2, 3] )
-@pytest.mark.parametrize( 'p2', [1, 2, 3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-
-def test_stencil_matrix_2d_serial_transpose_4( n1, n2, p1, p2, P1, P2 ):
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 12])
+@pytest.mark.parametrize('n2', [6, 10])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('p2', [1, 2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+# Case where domain and codomain have different size for the second dimension and matrix pads the same
+def test_stencil_matrix_2d_serial_transpose_4(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # This should only work with non periodic boundaries
 
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts1 = [n1,n2]
-    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])
+    npts1 = [n1, n2]
+    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1, p2])
 
-    npts2 = [n1,n2-1]
-    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])
+    npts2 = [n1, n2 - 1]
+    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1, p2])
 
-    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])
-    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])
-
+    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1, p2], shifts=[s1, s2])
+    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space and stencil matrix
-    V1 = StencilVectorSpace( cart1 )
-    V2 = StencilVectorSpace( cart2 )
-    M  = StencilMatrix(V1, V2, pads=(p1,p2))
+    V1 = StencilVectorSpace(cart1, dtype=dtype)
+    V2 = StencilVectorSpace(cart2, dtype=dtype)
+    M = StencilMatrix(V1, V2, pads=(p1, p2))
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[0:n1, 0:n2-1, :, :] = np.random.random((n1, n2-1, 2*p1+1, 2*p2+1))
+    if dtype == complex:
+        M[0:n1, 0:n2 - 1, :, :] = np.random.random((n1, n2 - 1, 2 * p1 + 1, 2 * p2 + 1))+1j*np.random.random((n1, n2 - 1, 2 * p1 + 1, 2 * p2 + 1))
+    else:
+        M[0:n1, 0:n2 - 1, :, :] = np.random.random((n1, n2 - 1, 2 * p1 + 1, 2 * p2 + 1))
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # TEST: compute transpose, then convert to Scipy sparse format
-    Ts = M.transpose().transpose().tosparse()
+    Ts = M.transpose().tosparse()
 
     # Exact result: convert to Scipy sparse format, then transpose
-    Ts_exact = M.tosparse()
+    Ts_exact = M.tosparse().transpose()
 
     # Check data
     assert abs(Ts - Ts_exact).max() < 1e-14
+    assert abs(Ts - M.T.tosparse()).max() < 1e-14
+
+# TODO: verify for s>1
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [7, 12] )
-@pytest.mark.parametrize( 'n2', [7, 10] )
-@pytest.mark.parametrize( 'p1', [2, 3] )
-@pytest.mark.parametrize( 'p2', [2, 3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-
-def test_stencil_matrix_2d_serial_transpose_5( n1, n2, p1, p2, P1, P2 ):
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [7, 12])
+@pytest.mark.parametrize('n2', [7, 10])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+# Case where domain and codomain have same size for both dimension and matrix pads different
+def test_stencil_matrix_2d_serial_transpose_5(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # This should only work with non periodic boundaries
 
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts1 = [n1,n2-1]
-    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])
+    npts1 = [n1, n2 - 1]
+    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1, p2])
 
-    npts2 = [n1,n2-1]
-    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])
+    npts2 = [n1, n2 - 1]
+    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1, p2])
 
-    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])
-    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])
+    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1, p2], shifts=[s1, s2])
+    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space and stencil matrix
-    V1 = StencilVectorSpace( cart1 )
-    V2 = StencilVectorSpace( cart2 )
-    M  = StencilMatrix(V1, V2, pads=(p1, p2-1))
+    V1 = StencilVectorSpace(cart1, dtype=dtype)
+    V2 = StencilVectorSpace(cart2, dtype=dtype)
+    M = StencilMatrix(V1, V2, pads=(p1, p2 - 1))
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[0:n1, 0:n2-1, :, :] = np.random.random((n1, n2-1, 2*p1+1, 2*p2-1))
+    if dtype == complex:
+        M[0:n1, 0:n2 - 1, :, :] = np.random.random((n1, n2 - 1, 2 * p1 + 1, 2 * p2 - 1))+1j*np.random.random((n1, n2 - 1, 2 * p1 + 1, 2 * p2 - 1))
+    else:
+        M[0:n1, 0:n2 - 1, :, :] = np.random.random((n1, n2 - 1, 2 * p1 + 1, 2 * p2 - 1))
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # TEST: compute transpose, then convert to Scipy sparse format
-    Ts = M.transpose().transpose().tosparse()
+    Ts = M.transpose().tosparse()
 
     # Exact result: convert to Scipy sparse format, then transpose
-    Ts_exact = M.tosparse()
+    Ts_exact = M.tosparse().transpose()
 
     # Check data
     assert abs(Ts - Ts_exact).max() < 1e-14
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [7, 12] )
-@pytest.mark.parametrize( 'n2', [7, 10] )
-@pytest.mark.parametrize( 'p1', [2, 3] )
-@pytest.mark.parametrize( 'p2', [2, 3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-
-def test_stencil_matrix_2d_serial_transpose_6( n1, n2, p1, p2, P1, P2 ):
+# TODO: verify for s>1
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [7, 12])
+@pytest.mark.parametrize('n2', [7, 10])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+# Case where domain and codomain have different size for the first dimension and matrix pads are different
+def test_stencil_matrix_2d_serial_transpose_6(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # This should only work with non periodic boundaries
 
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts1 = [n1-1,n2-1]
-    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])
+    npts1 = [n1 - 1, n2 - 1]
+    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1, p2])
 
-    npts2 = [n1,n2-1]
-    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])
+    npts2 = [n1, n2 - 1]
+    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1, p2])
 
-    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])
-    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])
+    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1, p2], shifts=[s1, s2])
+    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space and stencil matrix
-    V1 = StencilVectorSpace( cart1 )
-    V2 = StencilVectorSpace( cart2 )
-    M  = StencilMatrix(V1, V2, pads=(p1, p2-1))
+    V1 = StencilVectorSpace(cart1, dtype=dtype)
+    V2 = StencilVectorSpace(cart2, dtype=dtype)
+    M = StencilMatrix(V1, V2, pads=(p1, p2 - 1))
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[0:n1, 0:n2-1, :, :] = np.random.random((n1, n2-1, 2*p1+1, 2*p2-1))
+    if dtype == complex:
+        M[0:n1, 0:n2 - 1, :, :] = np.random.random((n1, n2 - 1, 2 * p1 + 1, 2 * p2 - 1))+1j*np.random.random((n1, n2 - 1, 2 * p1 + 1, 2 * p2 - 1))
+    else:
+        M[0:n1, 0:n2 - 1, :, :] = np.random.random((n1, n2 - 1, 2 * p1 + 1, 2 * p2 - 1))
 
+
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # TEST: compute transpose, then convert to Scipy sparse format
-    Ts = M.transpose().transpose().tosparse()
+    Ts = M.transpose().tosparse()
 
     # Exact result: convert to Scipy sparse format, then transpose
-    Ts_exact = M.tosparse()
+    Ts_exact = M.tosparse().transpose()
 
     # Check data
     assert abs(Ts - Ts_exact).max() < 1e-14
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [7, 12] )
-@pytest.mark.parametrize( 'n2', [7, 10] )
-@pytest.mark.parametrize( 'p1', [2, 3] )
-@pytest.mark.parametrize( 'p2', [2, 3] )
-@pytest.mark.parametrize( 'P1', [True] )
-@pytest.mark.parametrize( 'P2', [True] )
-
-def test_stencil_matrix_2d_serial_transpose_7( n1, n2, p1, p2, P1, P2 ):
-
+# TODO: verify for s>1
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [7, 12])
+@pytest.mark.parametrize('n2', [7, 10])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [True])
+@pytest.mark.parametrize('P2', [True])
+# Case where domain and codomain have same size for both dimension and matrix pads are different
+def test_stencil_matrix_2d_serial_transpose_7(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space and stencil matrix
-    V1 = StencilVectorSpace( cart )
-    V2 = StencilVectorSpace( cart )
-    M  = StencilMatrix(V1, V2, pads=(p1, p2-1))
+    V1 = StencilVectorSpace(cart, dtype=dtype)
+    V2 = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V1, V2, pads=(p1, p2 - 1))
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[0:n1, 0:n2, :, :] = np.random.random((n1, n2, 2*p1+1, 2*p2-1))
+    if dtype == complex:
+        M[0:n1, 0:n2, :, :] = np.random.random((n1, n2, 2 * p1 + 1, 2 * p2 - 1))+1j*np.random.random((n1, n2, 2 * p1 + 1, 2 * p2 - 1))
+    else:
+        M[0:n1, 0:n2, :, :] = np.random.random((n1, n2, 2 * p1 + 1, 2 * p2 - 1))
 
+
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # TEST: compute transpose, then convert to Scipy sparse format
-    Ts = M.transpose().transpose().tosparse()
+    Ts = M.transpose().tosparse()
 
     # Exact result: convert to Scipy sparse format, then transpose
-    Ts_exact = M.tosparse()
+    Ts_exact = M.tosparse().transpose()
 
     # Check data
     assert abs(Ts - Ts_exact).max() < 1e-14
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [7, 12] )
-@pytest.mark.parametrize( 'n2', [7, 10] )
-@pytest.mark.parametrize( 'p1', [2, 3] )
-@pytest.mark.parametrize( 'p2', [2, 3] )
-@pytest.mark.parametrize( 'P1', [True] )
-@pytest.mark.parametrize( 'P2', [True] )
-
-def test_stencil_matrix_2d_serial_transpose_8( n1, n2, p1, p2, P1, P2 ):
-
+# TODO: verify for s>1
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [7, 12])
+@pytest.mark.parametrize('n2', [7, 10])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [True])
+@pytest.mark.parametrize('P2', [True])
+# Case where domain and codomain have same size for both dimension and matrix pads are different
+def test_stencil_matrix_2d_serial_transpose_8(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space and stencil matrix
-    V1 = StencilVectorSpace( cart )
-    V2 = StencilVectorSpace( cart )
-    M  = StencilMatrix(V1, V2, pads=(p1-1, p2-1))
+    V1 = StencilVectorSpace(cart, dtype=dtype)
+    V2 = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V1, V2, pads=(p1 - 1, p2 - 1))
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[0:n1, 0:n2, :, :] = np.random.random((n1, n2, 2*p1-1, 2*p2-1))
+    if dtype == complex:
+        M[0:n1, 0:n2, :, :] = np.random.random((n1, n2, 2 * p1 - 1, 2 * p2 - 1))+1j*np.random.random((n1, n2, 2 * p1 - 1, 2 * p2 - 1))
+    else:
+        M[0:n1, 0:n2, :, :] = np.random.random((n1, n2, 2 * p1 - 1, 2 * p2 - 1))
 
+
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # TEST: compute transpose, then convert to Scipy sparse format
-    Ts = M.transpose().transpose().tosparse()
+    Ts = M.transpose().tosparse()
 
     # Exact result: convert to Scipy sparse format, then transpose
-    Ts_exact = M.tosparse()
+    Ts_exact = M.tosparse().transpose()
 
     # Check data
     assert abs(Ts - Ts_exact).max() < 1e-14
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [7, 12] )
-@pytest.mark.parametrize( 'n2', [7, 10] )
-@pytest.mark.parametrize( 'p1', [2, 3] )
-@pytest.mark.parametrize( 'p2', [2, 3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-
-def test_stencil_matrix_2d_serial_transpose_9( n1, n2, p1, p2, P1, P2 ):
+# TODO: verify for s>1
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [7, 12])
+@pytest.mark.parametrize('n2', [7, 10])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+# Case where domain and codomain have same size for both dimension and matrix pads are the same
+def test_stencil_matrix_2d_serial_transpose_9(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     # This should only work with non periodic boundaries
 
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts = [n1-1,n2-1]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1 - 1, n2 - 1]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
-
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space and stencil matrix
-    V1 = StencilVectorSpace( cart )
-    V2 = StencilVectorSpace( cart )
-    M  = StencilMatrix(V1, V2)
+    V1 = StencilVectorSpace(cart, dtype=dtype)
+    V2 = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V1, V2)
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1+1, 2*p2+1))
+    if dtype == complex:
+        M[0:n1 - 1, 0:n2 - 1, :, :] = np.random.random((n1 - 1, n2 - 1, 2 * p1 + 1, 2 * p2 + 1))+1j*np.random.random((n1 - 1, n2 - 1, 2 * p1 + 1, 2 * p2 + 1))
+    else:
+        M[0:n1 - 1, 0:n2 - 1, :, :] = np.random.random((n1 - 1, n2 - 1, 2 * p1 + 1, 2 * p2 + 1))
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # TEST: compute transpose, then convert to Scipy sparse format
-    Ts = M.transpose().transpose().tosparse()
+    Ts = M.transpose().tosparse()
 
     # Exact result: convert to Scipy sparse format, then transpose
-    Ts_exact = M.tosparse()
+    Ts_exact = M.tosparse().transpose()
 
     # Check data
     assert abs(Ts - Ts_exact).max() < 1e-14
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [7, 12] )
-@pytest.mark.parametrize( 'n2', [7, 10] )
-@pytest.mark.parametrize( 'n3', [7, 10] )
-@pytest.mark.parametrize( 'p1', [2, 3] )
-@pytest.mark.parametrize( 'p2', [2, 3] )
-@pytest.mark.parametrize( 'p3', [2, 3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-@pytest.mark.parametrize( 'P3', [False] )
-
-def test_stencil_matrix_3d_serial_transpose_1( n1, n2, n3, p1, p2, p3, P1, P2, P3 ):
+# TODO: verify for s>1
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [7, 12])
+@pytest.mark.parametrize('n2', [7, 10])
+@pytest.mark.parametrize('n3', [7, 10])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('p3', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('s3', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+@pytest.mark.parametrize('P3', [False])
+def test_stencil_matrix_3d_serial_transpose_1(dtype, n1, n2, n3, p1, p2, p3, s1, s2, s3, P1, P2, P3):
     # This should only work with non periodic boundaries
 
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1, n3-1], periods=[P1,P2,P3])
+    D = DomainDecomposition([n1 - 1, n2 - 1, n3 - 1], periods=[P1, P2, P3])
 
     # Partition the points
-    npts1 = [n1-1,n2-1, n3-1]
-    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])
+    npts1 = [n1 - 1, n2 - 1, n3 - 1]
+    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1, p2])
 
-    npts2 = [n1,n2-1, n3-1]
-    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])
+    npts2 = [n1, n2 - 1, n3 - 1]
+    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1, p2])
 
-    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2,p3], shifts=[1,1,1])
-    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2,p3], shifts=[1,1,1])
+    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1, p2, p3], shifts=[s1, s2, s3])
+    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1, p2, p3], shifts=[s1, s2, s3])
 
     # Create vector space and stencil matrix
-    V1 = StencilVectorSpace( cart1 )
-    V2 = StencilVectorSpace( cart2 )
-    M  = StencilMatrix(V1, V2, pads=(p1, p2-1, p3-1))
+    V1 = StencilVectorSpace(cart1, dtype=dtype)
+    V2 = StencilVectorSpace(cart2, dtype=dtype)
+    M = StencilMatrix(V1, V2, pads=(p1, p2 - 1, p3 - 1))
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[0:n1, 0:n2-1, 0:n3-1, :, :, :] = np.random.random((n1, n2-1, n3-1, 2*p1+1, 2*p2-1, 2*p3-1))
+    if dtype == complex:
+        M[0:n1, 0:n2 - 1, 0:n3 - 1, :, :, :] = np.random.random((n1, n2 - 1, n3 - 1, 2 * p1 + 1, 2 * p2 - 1, 2 * p3 - 1))+1j*np.random.random((n1, n2 - 1, n3 - 1, 2 * p1 + 1, 2 * p2 - 1, 2 * p3 - 1))
+    else:
+        M[0:n1, 0:n2 - 1, 0:n3 - 1, :, :, :] = np.random.random((n1, n2 - 1, n3 - 1, 2 * p1 + 1, 2 * p2 - 1, 2 * p3 - 1))
 
+
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # TEST: compute transpose, then convert to Scipy sparse format
     Ts = M.transpose().transpose().tosparse()
+    Mt = M.transpose().tosparse()
 
     # Exact result: convert to Scipy sparse format, then transpose
     Ts_exact = M.tosparse()
+    Mt_exact = Ts_exact.transpose()
 
     # Check data
     assert abs(Ts - Ts_exact).max() < 1e-14
+    assert abs(Mt - Mt_exact).max() < 1e-14
 
+# TODO: verify for s>1
 
-#===============================================================================
+# ===============================================================================
 # BACKENDS TESTS
-#===============================================================================
+# ===============================================================================
 
-@pytest.mark.parametrize( 'n1', [5,15] )
-@pytest.mark.parametrize( 'n2', [5,12] )
-@pytest.mark.parametrize( 'p1', [2,3] )
-@pytest.mark.parametrize( 'p2', [2,3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-@pytest.mark.parametrize( 'backend', [PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )
-
-def test_stencil_matrix_2d_serial_backend_dot_1( n1, n2, p1, p2, P1, P2 , backend):
-
+#@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('dtype', [float])
+@pytest.mark.parametrize('n1', [5, 15])
+@pytest.mark.parametrize('n2', [5, 12])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+@pytest.mark.parametrize('backend', [PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL])
+def test_stencil_matrix_2d_serial_backend_dot_1(dtype, n1, n2, p1, p2, s1, s2, P1, P2, backend):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts1 = [n1-1,n2]
-    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])
+    npts1 = [n1 - 1, n2]
+    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1, p2])
 
-    npts2 = [n1-1,n2-1]
-    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])
+    npts2 = [n1 - 1, n2 - 1]
+    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1, p2])
 
-    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])
-    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])
+    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1, p2], shifts=[s1, s2])
+    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space, stencil matrix, and stencil vector
-    V1 = StencilVectorSpace( cart1 )
-    V2 = StencilVectorSpace( cart2 )
-    M1 = StencilMatrix( V1, V2 ,pads=(p1,p2), backend=backend)
-    M2 = StencilMatrix( V2, V1 ,pads=(p1,p2), backend=backend)
-    x1 = StencilVector( V1 )
-    x2 = StencilVector( V2 )
+    V1 = StencilVectorSpace(cart1, dtype=dtype)
+    V2 = StencilVectorSpace(cart2, dtype=dtype)
+    M1 = StencilMatrix(V1, V2, pads=(p1, p2), backend=backend)
+    M2 = StencilMatrix(V2, V1, pads=(p1, p2), backend=backend)
+    x1 = StencilVector(V1)
+    x2 = StencilVector(V2)
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    M1[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1+1, 2*p2+1))
-    M2[0:n1-1, 0:n2, :, :] = np.random.random((n1-1, n2, 2*p1+1, 2*p2+1))
+    M1[0:n1 - 1, 0:n2 - 1, :, :] = np.random.random((n1 - 1, n2 - 1, 2 * p1 + 1, 2 * p2 + 1))
+    M2[0:n1 - 1, 0:n2, :, :] = np.random.random((n1 - 1, n2, 2 * p1 + 1, 2 * p2 + 1))
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M1.remove_spurious_entries()
     M2.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(n1-1):
-        for i2 in range(n2):
-            x1[i1,i2] = 2.0*random() - 1.0
-    x1.update_ghost_regions()
-
-    for i1 in range(n1-1):
-        for i2 in range(n2-1):
-            x2[i1,i2] = 2.0*random() - 1.0
+    if dtype==complex :
+        for i1 in range(n1 - 1):
+            for i2 in range(n2):
+                x1[i1, i2] = 2.0j * random() - 1.0
+        for i1 in range(n1 - 1):
+            for i2 in range(n2 - 1):
+                x2[i1, i2] = 2.0 * random() - 1.0j
+    else:
+        for i1 in range(n1 - 1):
+            for i2 in range(n2):
+                x1[i1, i2] = 2.0 * random() - 1.0
+        for i1 in range(n1 - 1):
+            for i2 in range(n2 - 1):
+                x2[i1, i2] = 2.0 * random() - 1.0
+
+    x1.update_ghost_regions()
     x2.update_ghost_regions()
 
     # Compute matrix-vector product
@@ -1161,43 +1643,48 @@
     y2a = y2.toarray()
 
     # Exact result using Numpy dot product
-    y1a_exact = np.dot( M1a, x1a )
-    y2a_exact = np.dot( M2a, x2a )
+    y1a_exact = np.dot(M1a, x1a)
+    y2a_exact = np.dot(M2a, x2a)
 
     # Check data in 1D array
-
-    assert np.allclose( y1a, y1a_exact, rtol=1e-13, atol=1e-13 )
-    assert np.allclose( y2a, y2a_exact, rtol=1e-13, atol=1e-13 )
+    assert y1.dtype==dtype
+    assert y2.dtype==dtype
+    assert np.allclose(y1a, y1a_exact, rtol=1e-13, atol=1e-13)
+    assert np.allclose(y2a, y2a_exact, rtol=1e-13, atol=1e-13)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [5,15] )
-@pytest.mark.parametrize( 'n2', [5,12] )
-@pytest.mark.parametrize( 'p1', [2,3] )
-@pytest.mark.parametrize( 'p2', [2,3] )
-@pytest.mark.parametrize( 'P1', [True] )
-@pytest.mark.parametrize( 'P2', [True] )
-@pytest.mark.parametrize( 'backend', [None, PSYDAC_BACKEND_PYTHON, PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )
-
-def test_stencil_matrix_2d_serial_backend_dot_2( n1, n2, p1, p2, P1, P2 , backend):
-
+# TODO: Fix why complex don't work with PSYDAC_BACKEND_GPYCCEL backend
+
+# ===============================================================================
+#@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('dtype', [float])
+@pytest.mark.parametrize('n1', [5, 15])
+@pytest.mark.parametrize('n2', [5, 12])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [True])
+@pytest.mark.parametrize('P2', [True])
+@pytest.mark.parametrize('backend', [None, PSYDAC_BACKEND_PYTHON, PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL])
+def test_stencil_matrix_2d_serial_backend_dot_2(dtype, n1, n2, p1, p2, s1, s2, P1, P2, backend):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts = [n1-1,n2-1]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1 - 1, n2 - 1]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space, stencil matrix, and stencil vector
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V , pads=(p1-1, p2-1), backend=backend)
-    x = StencilVector( V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V, pads=(p1 - 1, p2 - 1), backend=backend)
+    x = StencilVector(V)
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    for k1 in range(-p1+1,p1):
-        for k2 in range(-p2+1,p2):
-            M[:,:,k1,k2] = 10*k1+k2
+    for k1 in range(-p1 + 1, p1):
+        for k2 in range(-p2 + 1, p2):
+            M[:, :, k1, k2] = 10 * k1 + k2
 
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
@@ -1205,7 +1692,7 @@
     # Fill in vector with random values, then update ghost regions
     for i1 in range(n1):
         for i2 in range(n2):
-            x[i1,i2] = 2.0*random() - 1.0
+            x[i1, i2] = 2.0 * random() - 1.0
     x.update_ghost_regions()
 
     # Compute matrix-vector product
@@ -1217,65 +1704,70 @@
     ya = y.toarray()
 
     # Exact result using Numpy dot product
-    ya_exact = np.dot( Ma, xa )
+    ya_exact = np.dot(Ma, xa)
 
     # Check data in 1D array
-    assert np.allclose( ya, ya_exact, rtol=1e-13, atol=1e-13 )
+    assert np.allclose(ya, ya_exact, rtol=1e-13, atol=1e-13)
 
     # tests for backend propagation
+    assert y.dtype == dtype
     assert M.backend is backend
     assert M.T.backend is M.backend
-    assert (M+M).backend is M.backend
-    assert (2*M).backend is M.backend
+    assert (M + M).backend is M.backend
+    assert (2 * M).backend is M.backend
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [5,15] )
-@pytest.mark.parametrize( 'n2', [5,12] )
-@pytest.mark.parametrize( 'p1', [2,3] )
-@pytest.mark.parametrize( 'p2', [2,3] )
-@pytest.mark.parametrize( 'P1', [False] )
-@pytest.mark.parametrize( 'P2', [False] )
-@pytest.mark.parametrize( 'backend', [PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )
-
-def test_stencil_matrix_2d_serial_backend_dot_4( n1, n2, p1, p2, P1, P2, backend):
-
+# TODO: Fix why dot don't work with complex and PSYDAC_BACKEND_GPYCCEL backend
+
+# ===============================================================================
+#@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('dtype', [float])
+@pytest.mark.parametrize('n1', [5, 15])
+@pytest.mark.parametrize('n2', [5, 12])
+@pytest.mark.parametrize('p1', [2, 3])
+@pytest.mark.parametrize('p2', [2, 3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [False])
+@pytest.mark.parametrize('P2', [False])
+@pytest.mark.parametrize('backend', [PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL])
+def test_stencil_matrix_2d_serial_backend_dot_4(dtype, n1, n2, p1, p2, s1, s2, P1, P2, backend):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts1 = [n1-1,n2]
-    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1,p2])
+    npts1 = [n1 - 1, n2]
+    global_starts1, global_ends1 = compute_global_starts_ends(D, npts1, [p1, p2])
 
-    npts2 = [n1-1,n2-1]
-    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1,p2])
+    npts2 = [n1 - 1, n2 - 1]
+    global_starts2, global_ends2 = compute_global_starts_ends(D, npts2, [p1, p2])
 
-    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1,p2], shifts=[1,1])
-    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1,p2], shifts=[1,1])
+    cart1 = CartDecomposition(D, npts1, global_starts1, global_ends1, pads=[p1, p2], shifts=[s1, s2])
+    cart2 = CartDecomposition(D, npts2, global_starts2, global_ends2, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space, stencil matrix, and stencil vector
-    V1 = StencilVectorSpace( cart1 )
-    V2 = StencilVectorSpace( cart2 )
-    M1 = StencilMatrix( V1, V2, pads=(p1-1,p2), backend=backend)
-    M2 = StencilMatrix( V2, V1, pads=(p1-1,p2), backend=backend)
-    x1 = StencilVector( V1 )
-    x2 = StencilVector( V2 )
+    V1 = StencilVectorSpace(cart1, dtype=dtype)
+    V2 = StencilVectorSpace(cart2, dtype=dtype)
+    M1 = StencilMatrix(V1, V2, pads=(p1 - 1, p2), backend=backend)
+    M2 = StencilMatrix(V2, V1, pads=(p1 - 1, p2), backend=backend)
+    x1 = StencilVector(V1)
+    x2 = StencilVector(V2)
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    M1[0:n1-1, 0:n2-1, :, :] = np.random.random((n1-1, n2-1, 2*p1-1, 2*p2+1))
-    M2[0:n1-1, 0:n2  , :, :] = np.random.random((n1-1, n2  , 2*p1-1, 2*p2+1))
+    M1[0:n1 - 1, 0:n2 - 1, :, :] = np.random.random((n1 - 1, n2 - 1, 2 * p1 - 1, 2 * p2 + 1))
+    M2[0:n1 - 1, 0:n2, :, :] = np.random.random((n1 - 1, n2, 2 * p1 - 1, 2 * p2 + 1))
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M1.remove_spurious_entries()
     M2.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(n1-1):
+    for i1 in range(n1 - 1):
         for i2 in range(n2):
-            x1[i1,i2] = 2.0*random() - 1.0
+            x1[i1, i2] = 2.0 * random() - 1.0
     x1.update_ghost_regions()
 
-    for i1 in range(n1-1):
-        for i2 in range(n2-1):
-            x2[i1,i2] = 2.0*random() - 1.0
+    for i1 in range(n1 - 1):
+        for i2 in range(n2 - 1):
+            x2[i1, i2] = 2.0 * random() - 1.0
     x2.update_ghost_regions()
 
     # Compute matrix-vector product
@@ -1292,44 +1784,49 @@
     y2a = y2.toarray()
 
     # Exact result using Numpy dot product
-    y1a_exact = np.dot( M1a, x1a )
-    y2a_exact = np.dot( M2a, x2a )
+    y1a_exact = np.dot(M1a, x1a)
+    y2a_exact = np.dot(M2a, x2a)
 
     # Check data in 1D array
 
-    assert np.allclose( y1a, y1a_exact, rtol=1e-13, atol=1e-13 )
-    assert np.allclose( y2a, y2a_exact, rtol=1e-13, atol=1e-13 )
+    assert np.allclose(y1a, y1a_exact, rtol=1e-13, atol=1e-13)
+    assert np.allclose(y2a, y2a_exact, rtol=1e-13, atol=1e-13)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [15] )
-@pytest.mark.parametrize( 'n2', [12] )
-@pytest.mark.parametrize( 'p1', [2] )
-@pytest.mark.parametrize( 'p2', [3] )
-@pytest.mark.parametrize( 'P1', [True] )
-@pytest.mark.parametrize( 'P2', [True] )
-@pytest.mark.parametrize( 'backend', [None, PSYDAC_BACKEND_PYTHON, PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )
-@pytest.mark.parametrize( 'backend2', [None, PSYDAC_BACKEND_PYTHON, PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )
+# TODO: Fix why dot don't work with complex and PSYDAC_BACKEND_GPYCCEL backend
+
+# ===============================================================================
+#@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('dtype', [float])
+@pytest.mark.parametrize('n1', [15])
+@pytest.mark.parametrize('n2', [12])
+@pytest.mark.parametrize('p1', [2])
+@pytest.mark.parametrize('p2', [3])
+@pytest.mark.parametrize('s1', [1])
+@pytest.mark.parametrize('s2', [1])
+@pytest.mark.parametrize('P1', [True])
+@pytest.mark.parametrize('P2', [True])
+@pytest.mark.parametrize('backend', [None, PSYDAC_BACKEND_PYTHON, PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL])
+@pytest.mark.parametrize('backend2', [None, PSYDAC_BACKEND_PYTHON, PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL])
 
-def test_stencil_matrix_2d_serial_backend_switch( n1, n2, p1, p2, P1, P2 , backend, backend2):
-
+def test_stencil_matrix_2d_serial_backend_switch(dtype, n1, n2, p1, p2, s1, s2, P1, P2, backend, backend2):
     # Create domain decomposition
-    D = DomainDecomposition([n1-1,n2-1], periods=[P1,P2])
+    D = DomainDecomposition([n1 - 1, n2 - 1], periods=[P1, P2])
 
     # Partition the points
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     # Create vector space, stencil matrix, and stencil vector
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V , pads=(p1-1, p2-1), backend=backend)
-    x = StencilVector( V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V, pads=(p1 - 1, p2 - 1), backend=backend)
+    x = StencilVector(V)
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    for k1 in range(-p1+1,p1):
-        for k2 in range(-p2+1,p2):
-            M[:,:,k1,k2] = 10*k1+k2
+    for k1 in range(-p1 + 1, p1):
+        for k2 in range(-p2 + 1, p2):
+            M[:, :, k1, k2] = 10 * k1 + k2
 
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
@@ -1337,7 +1834,7 @@
     # Fill in vector with random values, then update ghost regions
     for i1 in range(n1):
         for i2 in range(n2):
-            x[i1,i2] = 2.0*random() - 1.0
+            x[i1, i2] = 2.0 * random() - 1.0
     x.update_ghost_regions()
 
     assert M.backend is backend
@@ -1347,135 +1844,160 @@
     assert M.backend is backend2
     M.dot(x)
 
-#===============================================================================
+# TODO: Fix why dot don't work with complex and PSYDAC_BACKEND_GPYCCEL backend
+
+# ===============================================================================
 # PARALLEL TESTS
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [20,67] )
-@pytest.mark.parametrize( 'p1', [1,2,3] )
-@pytest.mark.parametrize( 'P1', [True, False] )
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [20, 67])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('sh1', [1])
+@pytest.mark.parametrize('P1', [True, False])
 @pytest.mark.parallel
-
-def test_stencil_matrix_1d_parallel_dot( n1, p1, P1 ):
-
+def test_stencil_matrix_1d_parallel_dot(dtype, n1, p1, sh1, P1):
     from mpi4py import MPI
 
     comm = MPI.COMM_WORLD
     # Create domain decomposition
-    D = DomainDecomposition([n1-1], periods=[P1], comm=comm)
+    D = DomainDecomposition([n1 - 1], periods=[P1], comm=comm)
 
     # Partition the points
     npts = [n1]
     global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[sh1])
 
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V )
-    x = StencilVector( V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
+    x = StencilVector(V)
 
     s1, = V.starts
     e1, = V.ends
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    for k1 in range(-p1,p1+1):
-        M[:,k1] = k1
+    if dtype==complex:
+        for k1 in range(-p1, p1 + 1):
+            M[:, k1] = 1j*k1
+    else:
+        for k1 in range(-p1, p1 + 1):
+            M[:, k1] = k1
 
+
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(x.starts[0],x.ends[0]+1):
-        x[i1] = 2.0*random() - 1.0
+    if dtype==complex:
+        for i1 in range(x.starts[0], x.ends[0] + 1):
+            x[i1] = 2.0j * random() - 1.0
+    else:
+        for i1 in range(x.starts[0], x.ends[0] + 1):
+            x[i1] = 2.0 * random() - 1.0
     x.update_ghost_regions()
 
     # Compute matrix-vector product
-    y = M.dot( x )
+    y = M.dot(x)
 
-    assert isinstance( y, StencilVector )
+    assert isinstance(y, StencilVector)
+    assert y.dtype==dtype
     assert y.space is x.space
 
     # Convert stencil objects to Scipy sparse matrix and 1D Numpy arrays
     Ms = M.tosparse()
-    xa = x.toarray( with_pads=True )
+    xa = x.toarray(with_pads=True)
     ya = y.toarray()
 
     # Exact result using Scipy sparse dot product
-    ya_exact = Ms.dot( xa )
+    ya_exact = Ms.dot(xa)
 
     # Check data in 1D array
-    assert np.allclose( ya, ya_exact, rtol=1e-14, atol=1e-14 )
+    assert np.allclose(ya, ya_exact, rtol=1e-14, atol=1e-14)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [8,21] )
-@pytest.mark.parametrize( 'n2', [13,32] )
-@pytest.mark.parametrize( 'p1', [1,3] )
-@pytest.mark.parametrize( 'p2', [1,2] )
-@pytest.mark.parametrize( 'P1', [True, False] )
-@pytest.mark.parametrize( 'P2', [True, False] )
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [8, 21])
+@pytest.mark.parametrize('n2', [13, 32])
+@pytest.mark.parametrize('p1', [1, 3])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('sh1', [1])
+@pytest.mark.parametrize('sh2', [1])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
 @pytest.mark.parallel
-
-def test_stencil_matrix_2d_parallel_dot( n1, n2, p1, p2, P1, P2 ):
-
+def test_stencil_matrix_2d_parallel_dot(dtype, n1, n2, p1, p2, sh1, sh2, P1, P2):
     from mpi4py import MPI
 
     comm = MPI.COMM_WORLD
     # Create domain decomposition
-    D = DomainDecomposition([n1,n2], periods=[P1,P2], comm=comm)
+    D = DomainDecomposition([n1, n2], periods=[P1, P2], comm=comm)
 
     # Partition the points
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[sh1, sh2])
 
     # Create vector space, stencil matrix, and stencil vector
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V )
-    x = StencilVector( V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
+    x = StencilVector(V)
 
-    s1,s2 = V.starts
-    e1,e2 = V.ends
+    s1, s2 = V.starts
+    e1, e2 = V.ends
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    for k1 in range(-p1,p1+1):
-        for k2 in range(-p2,p2+1):
-            M[:,:,k1,k2] = 10*k1+k2
+    if dtype == complex:
+        for k1 in range(-p1, p1 + 1):
+            for k2 in range(-p2, p2 + 1):
+                M[:, :, k1, k2] = 10j * k1 + k2
+    else:
+        for k1 in range(-p1, p1 + 1):
+            for k2 in range(-p2, p2 + 1):
+                M[:, :, k1, k2] = 10 * k1 + k2
 
+
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(s1,e1+1):
-        for i2 in range(s2,e2+1):
-            x[i1,i2] = 2.0*random() - 1.0
+    if dtype == complex:
+        for i1 in range(s1, e1 + 1):
+            for i2 in range(s2, e2 + 1):
+                x[i1, i2] = 2.0j * random() - 1.0
+    else:
+        for i1 in range(s1, e1 + 1):
+            for i2 in range(s2, e2 + 1):
+                x[i1, i2] = 2.0 * random() - 1.0
     x.update_ghost_regions()
 
     # Compute matrix-vector product
     y = M.dot(x)
 
-    assert isinstance( y, StencilVector )
+    assert isinstance(y, StencilVector)
     assert y.space is x.space
 
     # Convert stencil objects to Numpy arrays
     Ma = M.toarray()
-    xa = x.toarray( with_pads=True )
+    xa = x.toarray(with_pads=True)
     ya = y.toarray()
 
     # Exact result using Numpy dot product
-    ya_exact = np.dot( Ma, xa )
+    ya_exact = np.dot(Ma, xa)
 
     # Check data in 1D array
-    assert np.allclose( ya, ya_exact, rtol=1e-13, atol=1e-13 )
+    assert np.allclose(ya, ya_exact, rtol=1e-13, atol=1e-13)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [20,67] )
-@pytest.mark.parametrize( 'p1', [1,2,3] )
-@pytest.mark.parametrize( 'P1', [True, False] )
+
+# ===============================================================================
+@pytest.mark.parametrize('n1', [20, 67])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('sh1', [1])
 @pytest.mark.parallel
-
-def test_stencil_matrix_1d_parallel_sync( n1, p1, P1):
-
-    from mpi4py       import MPI
+def test_stencil_matrix_1d_parallel_sync( n1, p1, sh1, P1):
+    from mpi4py import MPI
     from psydac.ddm.cart import CartDecomposition
 
     comm = MPI.COMM_WORLD
@@ -1486,21 +2008,21 @@
     npts = [n1]
     global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[sh1])
 
-    V = StencilVectorSpace( cart, dtype=int )
-    M = StencilMatrix( V, V )
+    V = StencilVectorSpace(cart, dtype=int)
+    M = StencilMatrix(V, V)
 
     s1, = V.starts
     e1, = V.ends
 
     # Fill-in pattern
-    fill_in = lambda i1, k1 : 10*i1+k1
+    fill_in = lambda i1, k1: 10 * i1 + k1
 
     # Fill in stencil matrix
-    for i1 in range(s1, e1+1):
-        for k1 in range(-p1, p1+1):
-            M[i1,k1] = fill_in( i1, k1 )
+    for i1 in range(s1, e1 + 1):
+        for k1 in range(-p1, p1 + 1):
+            M[i1, k1] = fill_in(i1, k1)
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
@@ -1509,13 +2031,13 @@
     M.update_ghost_regions()
 
     # Convert stencil object to 1D Numpy array
-    Ma = M.toarray( with_pads=True )
+    Ma = M.toarray(with_pads=True)
 
     # Create exact solution
-    Me = np.zeros( (n1,n1), dtype=V.dtype )
+    Me = np.zeros((n1, n1), dtype=V.dtype)
 
     for i1 in range(n1):
-        for k1 in range(-p1, p1+1):
+        for k1 in range(-p1, p1 + 1):
 
             # Get column index
             j1 = i1 + k1
@@ -1528,63 +2050,65 @@
                     continue
 
             # Fill in matrix element
-            Me[i1,j1] = fill_in( i1, k1 )
+            Me[i1, j1] = fill_in(i1, k1)
 
     # Compare local solution to global
-    i1_min = max(0, s1-p1)
-    i1_max = min(e1+p1+1, n1)
+    i1_min = max(0, s1 - p1)
+    i1_max = min(e1 + p1 + 1, n1)
 
-#    for i in range( comm.size ):
-#        if i == comm.rank:
-#            print( "RANK {}:".format( i ) )
-#            print( M._data.shape )
-#            print( Ma.shape )
-#            print( Ma )
-#            print( "PASSED" )
-#            print( flush=True )
-#        comm.Barrier()
+    #    for i in range( comm.size ):
+    #        if i == comm.rank:
+    #            print( "RANK {}:".format( i ) )
+    #            print( M._data.shape )
+    #            print( Ma.shape )
+    #            print( Ma )
+    #            print( "PASSED" )
+    #            print( flush=True )
+    #        comm.Barrier()
 
-    assert np.array_equal( Ma[i1_min:i1_max, :], Me[i1_min:i1_max, :] )
+    assert np.array_equal(Ma[i1_min:i1_max, :], Me[i1_min:i1_max, :])
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [21,67] )
-@pytest.mark.parametrize( 'n2', [13,32] )
-@pytest.mark.parametrize( 'p1', [1,3] )
-@pytest.mark.parametrize( 'p2', [1,2] )
-@pytest.mark.parametrize( 'P1', [True, False] )
-@pytest.mark.parametrize( 'P2', [True, False] )
+#TODO: comprendre comment ca marche
+
+# ===============================================================================
+@pytest.mark.parametrize('n1', [21, 67])
+@pytest.mark.parametrize('n2', [13, 32])
+@pytest.mark.parametrize('p1', [1, 3])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('sh1', [1])
+@pytest.mark.parametrize('sh2', [1])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
 @pytest.mark.parallel
-
-def test_stencil_matrix_2d_parallel_sync( n1, n2, p1, p2, P1, P2):
-
-    from mpi4py       import MPI
+def test_stencil_matrix_2d_parallel_sync(n1, n2, p1, p2, sh1, sh2, P1, P2):
+    from mpi4py import MPI
     from psydac.ddm.cart import CartDecomposition
 
     comm = MPI.COMM_WORLD
     # Create domain decomposition
-    D = DomainDecomposition([n1,n2], periods=[P1,P2], comm=comm)
+    D = DomainDecomposition([n1, n2], periods=[P1, P2], comm=comm)
 
     # Partition the points
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[sh1, sh2])
 
-    V = StencilVectorSpace( cart, dtype=int )
-    M = StencilMatrix( V, V )
+    V = StencilVectorSpace(cart, dtype=int)
+    M = StencilMatrix(V, V)
 
     s1, s2 = V.starts
     e1, e2 = V.ends
 
     # Fill-in pattern
-    fill_in = lambda i1, i2, k1, k2: 1000*i1 + 100*i2 + 10*abs(k1) + abs(k2)
+    fill_in = lambda i1, i2, k1, k2: 1000 * i1 + 100 * i2 + 10 * abs(k1) + abs(k2)
 
     # Fill in stencil matrix
-    for i1 in range(s1, e1+1):
-        for i2 in range(s2, e2+1):
-            for k1 in range(-p1, p1+1):
-                for k2 in range(-p2, p2+1):
-                    M[i1, i2, k1, k2] = fill_in( i1, i2, k1, k2 )
+    for i1 in range(s1, e1 + 1):
+        for i2 in range(s2, e2 + 1):
+            for k1 in range(-p1, p1 + 1):
+                for k2 in range(-p2, p2 + 1):
+                    M[i1, i2, k1, k2] = fill_in(i1, i2, k1, k2)
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
@@ -1593,15 +2117,15 @@
     M.update_ghost_regions()
 
     # Convert stencil object to 1D Numpy array
-    Ma = M.toarray( with_pads=True )
+    Ma = M.toarray(with_pads=True)
 
     # Create exact solution
-    Me = np.zeros( (n1*n2, n1*n2), dtype=V.dtype )
+    Me = np.zeros((n1 * n2, n1 * n2), dtype=V.dtype)
 
     for i1 in range(n1):
         for i2 in range(n2):
-            for k1 in range(-p1, p1+1):
-                for k2 in range(-p2, p2+1):
+            for k1 in range(-p1, p1 + 1):
+                for k2 in range(-p2, p2 + 1):
 
                     # Get column multi-index
                     j1 = i1 + k1
@@ -1628,69 +2152,70 @@
                     j = j1 * n2 + j2
 
                     # Fill in matrix element
-                    Me[i,j] = fill_in( i1, i2, k1, k2 )
+                    Me[i, j] = fill_in(i1, i2, k1, k2)
 
-#    #++++++++++++++++++++++++++++++++++++++
-#    # DEBUG
-#    #++++++++++++++++++++++++++++++++++++++
-#    np.set_printoptions( linewidth=200 )
-#
-#    if comm.rank == 0:
-#        print( 'Me' )
-#        print( Me )
-#        print( flush=True )
-#    comm.Barrier()
-#
-#    for i in range(comm.size):
-#        if i == comm.rank:
-#            print( 'RANK {}'.format( i ) )
-#            print( Ma )
-#            print( flush=True )
-#        comm.Barrier()
-#    #++++++++++++++++++++++++++++++++++++++
+    #    #++++++++++++++++++++++++++++++++++++++
+    #    # DEBUG
+    #    #++++++++++++++++++++++++++++++++++++++
+    #    np.set_printoptions( linewidth=200 )
+    #
+    #    if comm.rank == 0:
+    #        print( 'Me' )
+    #        print( Me )
+    #        print( flush=True )
+    #    comm.Barrier()
+    #
+    #    for i in range(comm.size):
+    #        if i == comm.rank:
+    #            print( 'RANK {}'.format( i ) )
+    #            print( Ma )
+    #            print( flush=True )
+    #        comm.Barrier()
+    #    #++++++++++++++++++++++++++++++++++++++
 
     # Compare local solution to global, row by row
-    i1_min = max(0, s1-p1)
-    i1_max = min(e1+p1+1, n1)
+    i1_min = max(0, s1 - p1)
+    i1_max = min(e1 + p1 + 1, n1)
 
-    i2_min = max(0, s2-p2)
-    i2_max = min(e2+p2+1, n2)
+    i2_min = max(0, s2 - p2)
+    i2_max = min(e2 + p2 + 1, n2)
 
-    for i1 in range( i1_min, i1_max ):
-        for i2 in range( i2_min, i2_max ):
+    for i1 in range(i1_min, i1_max):
+        for i2 in range(i2_min, i2_max):
             i = i1 * n2 + i2
-            assert np.array_equal( Ma[i,:], Me[i,:] )
+            assert np.array_equal(Ma[i, :], Me[i, :])
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [20, 67] )
-@pytest.mark.parametrize( 'p1', [1, 2, 3] )
-@pytest.mark.parametrize( 'P1', [True, False] )
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [20, 67])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('sh1', [1])
+@pytest.mark.parametrize('P1', [True, False])
 @pytest.mark.parallel
-
-def test_stencil_matrix_1d_parallel_transpose( n1, p1, P1 ):
-
-    from mpi4py       import MPI
+def test_stencil_matrix_1d_parallel_transpose(dtype, n1, p1, sh1, P1):
+    from mpi4py import MPI
     from psydac.ddm.cart import CartDecomposition
 
     comm = MPI.COMM_WORLD
     # Create domain decomposition
-    D = DomainDecomposition([n1-1], periods=[P1], comm=comm)
+    D = DomainDecomposition([n1 - 1], periods=[P1], comm=comm)
 
     # Partition the points
     npts = [n1]
     global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[sh1])
 
     # Create vector space and stencil matrix
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
 
     s1, = V.starts
     e1, = V.ends
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[s1:e1+1, -p1:p1+1] = np.random.random( (e1-s1+1, 2*p1+1) )
+    M[s1:e1 + 1, -p1:p1 + 1] = np.random.random((e1 - s1 + 1, 2 * p1 + 1))
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
@@ -1700,47 +2225,51 @@
 
     # Exact result: convert to Numpy array including padding, then transpose,
     # hence remove entries that do not belong to current process.
-    Ta_exact = M.toarray( with_pads=True ).transpose()
-    Ta_exact[  :s1, :] = 0.0
-    Ta_exact[e1+1:, :] = 0.0
+    Ta_exact = M.toarray(with_pads=True).transpose()
+    Ta_exact[:s1, :] = 0.0
+    Ta_exact[e1 + 1:, :] = 0.0
 
     # Check data
-    assert np.array_equal( Ta, Ta_exact )
+    assert M.transpose().dtype
+    assert np.array_equal(Ta, Ta_exact)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [8, 21] )
-@pytest.mark.parametrize( 'n2', [13, 32] )
-@pytest.mark.parametrize( 'p1', [1, 3] )
-@pytest.mark.parametrize( 'p2', [1, 2] )
-@pytest.mark.parametrize( 'P1', [True, False] )
-@pytest.mark.parametrize( 'P2', [True, False] )
+#TODO: comprendre comment ca marche
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [8, 21])
+@pytest.mark.parametrize('n2', [13, 32])
+@pytest.mark.parametrize('p1', [1, 3])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('sh1', [1])
+@pytest.mark.parametrize('sh2', [1])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
 @pytest.mark.parallel
-
-def test_stencil_matrix_2d_parallel_transpose( n1, n2, p1, p2, P1, P2 ):
-
-    from mpi4py       import MPI
+def test_stencil_matrix_2d_parallel_transpose(dtype, n1, n2, p1, p2, sh1, sh2, P1, P2):
+    from mpi4py import MPI
     from psydac.ddm.cart import CartDecomposition
 
     comm = MPI.COMM_WORLD
     # Create domain decomposition
-    D = DomainDecomposition([n1,n2], periods=[P1,P2], comm=comm)
+    D = DomainDecomposition([n1, n2], periods=[P1, P2], comm=comm)
 
     # Partition the points
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[sh1, sh2])
 
     # Create vector space and stencil matrix
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V)
 
     s1, s2 = V.starts
     e1, e2 = V.ends
 
     # Fill in matrix values with random numbers between 0 and 1
-    M[s1:e1+1, s2:e2+1, -p1:p1+1, -p2:p2+1] = np.random.random(
-            (e1-s1+1, e2-s2+1, 2*p1+1, 2*p2+1))
+    M[s1:e1 + 1, s2:e2 + 1, -p1:p1 + 1, -p2:p2 + 1] = np.random.random(
+        (e1 - s1 + 1, e2 - s2 + 1, 2 * p1 + 1, 2 * p2 + 1))
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
@@ -1753,154 +2282,164 @@
 
     # Exact result: convert to Scipy sparse format including padding, then
     # transpose, hence remove entries that do not belong to current process.
-    Ts_exact = M.tosparse( with_pads=True ).transpose()
+    Ts_exact = M.tosparse(with_pads=True).transpose()
 
-    #...
+    # ...
     Ts_exact = Ts_exact.tocsr()
     for i, j in zip(*Ts_exact.nonzero()):
-        i1, i2 = np.unravel_index( i, shape=[n1, n2], order='C' )
+        i1, i2 = np.unravel_index(i, shape=[n1, n2], order='C')
         if not (s1 <= i1 <= e1 and s2 <= i2 <= e2):
             Ts_exact[i, j] = 0.0
     Ts_exact = Ts_exact.tocoo()
     Ts_exact.eliminate_zeros()
-    #...
+    # ...
 
     # Check data
     assert abs(Ts - Ts_exact).max() < 1e-14
 
-#===============================================================================
+
+# ===============================================================================
 # PARALLEL BACKENDS TESTS
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [20,67] )
-@pytest.mark.parametrize( 'p1', [1,2,3] )
-@pytest.mark.parametrize( 'P1', [True, False] )
-@pytest.mark.parametrize( 'backend', [PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )
+# ===============================================================================
+# @pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('dtype', [float])
+@pytest.mark.parametrize('n1', [20, 67])
+@pytest.mark.parametrize('p1', [1, 2, 3])
+@pytest.mark.parametrize('sh1', [1])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('backend', [PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL])
 @pytest.mark.parallel
-
-def test_stencil_matrix_1d_parallel_backend_dot( n1, p1, P1 , backend):
-
-    from mpi4py       import MPI
+def test_stencil_matrix_1d_parallel_backend_dot(dtype, n1, p1, sh1, P1, backend):
+    from mpi4py import MPI
     from psydac.ddm.cart import CartDecomposition
 
     comm = MPI.COMM_WORLD
     # Create domain decomposition
-    D = DomainDecomposition([n1-1], periods=[P1], comm=comm)
+    D = DomainDecomposition([n1 - 1], periods=[P1], comm=comm)
 
     # Partition the points
     npts = [n1]
     global_starts, global_ends = compute_global_starts_ends(D, npts, [p1])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[sh1])
 
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V , backend=backend)
-    x = StencilVector( V )
+    V = StencilVectorSpace(cart, dtype=dtype)
+    M = StencilMatrix(V, V, backend=backend)
+    x = StencilVector(V)
 
     s1, = V.starts
     e1, = V.ends
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    for k1 in range(-p1,p1+1):
-        M[:,k1] = k1
+    for k1 in range(-p1, p1 + 1):
+        M[:, k1] = k1
 
     # If domain is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(x.starts[0],x.ends[0]+1):
-        x[i1] = 2.0*random() - 1.0
+    for i1 in range(x.starts[0], x.ends[0] + 1):
+        x[i1] = 2.0 * random() - 1.0
     x.update_ghost_regions()
 
     # Compute matrix-vector product
-    y = M.dot( x )
+    y = M.dot(x)
 
-    assert isinstance( y, StencilVector )
+    assert isinstance(y, StencilVector)
+    assert y.dtype==dtype
     assert y.space is x.space
 
     # Convert stencil objects to Scipy sparse matrix and 1D Numpy arrays
     Ms = M.tosparse()
-    xa = x.toarray( with_pads=True )
+    xa = x.toarray(with_pads=True)
     ya = y.toarray()
 
     # Exact result using Scipy sparse dot product
-    ya_exact = Ms.dot( xa )
+    ya_exact = Ms.dot(xa)
 
     # Check data in 1D array
-    assert np.allclose( ya, ya_exact, rtol=1e-14, atol=1e-14 )
+    assert np.allclose(ya, ya_exact, rtol=1e-14, atol=1e-14)
 
-#===============================================================================
-@pytest.mark.parametrize( 'n1', [8,21] )
-@pytest.mark.parametrize( 'n2', [13,32] )
-@pytest.mark.parametrize( 'p1', [1,3] )
-@pytest.mark.parametrize( 'p2', [1,2] )
-@pytest.mark.parametrize( 'P1', [True, False] )
-@pytest.mark.parametrize( 'P2', [True, False] )
-@pytest.mark.parametrize( 'backend', [None, PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL] )
+# TODO: Fix why dot don't work with complex and PSYDAC_BACKEND_GPYCCEL backend
+
+# ===============================================================================
+@pytest.mark.parametrize('n1', [8, 21])
+@pytest.mark.parametrize('n2', [13, 32])
+@pytest.mark.parametrize('p1', [1, 3])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('sh1', [1])
+@pytest.mark.parametrize('sh2', [1])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
+@pytest.mark.parametrize('backend', [None, PSYDAC_BACKEND_NUMBA, PSYDAC_BACKEND_GPYCCEL])
 @pytest.mark.parallel
-
-def test_stencil_matrix_2d_parallel_backend_dot( n1, n2, p1, p2, P1, P2, backend):
-
-    from mpi4py       import MPI
+def test_stencil_matrix_2d_parallel_backend_dot(n1, n2, p1, p2, sh1, sh2, P1, P2, backend):
+    from mpi4py import MPI
     from psydac.ddm.cart import CartDecomposition
 
     comm = MPI.COMM_WORLD
     # Create domain decomposition
-    D = DomainDecomposition([n1,n2], periods=[P1,P2], comm=comm)
+    D = DomainDecomposition([n1, n2], periods=[P1, P2], comm=comm)
 
     # Partition the points
-    npts = [n1,n2]
-    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1,p2])
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts, [p1, p2])
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1,p2], shifts=[1,1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[sh1, sh2])
 
     # Create vector space, stencil matrix, and stencil vector
-    V = StencilVectorSpace( cart )
-    M = StencilMatrix( V, V , backend=backend)
-    x = StencilVector( V )
+    V = StencilVectorSpace(cart)
+    M = StencilMatrix(V, V, backend=backend)
+    x = StencilVector(V)
 
-    s1,s2 = V.starts
-    e1,e2 = V.ends
+    s1, s2 = V.starts
+    e1, e2 = V.ends
 
     # Fill in stencil matrix values based on diagonal index (periodic!)
-    for k1 in range(-p1,p1+1):
-        for k2 in range(-p2,p2+1):
-            M[:,:,k1,k2] = 10*k1+k2
+    for k1 in range(-p1, p1 + 1):
+        for k2 in range(-p2, p2 + 1):
+            M[:, :, k1, k2] = 10 * k1 + k2
 
     # If any dimension is not periodic, set corresponding periodic corners to zero
     M.remove_spurious_entries()
 
     # Fill in vector with random values, then update ghost regions
-    for i1 in range(s1,e1+1):
-        for i2 in range(s2,e2+1):
-            x[i1,i2] = 2.0*random() - 1.0
+    for i1 in range(s1, e1 + 1):
+        for i2 in range(s2, e2 + 1):
+            x[i1, i2] = 2.0 * random() - 1.0
     x.update_ghost_regions()
 
     # Compute matrix-vector product
     y = M.dot(x)
 
-    assert isinstance( y, StencilVector )
+    assert isinstance(y, StencilVector)
     assert y.space is x.space
 
     # Convert stencil objects to Numpy arrays
     Ma = M.toarray()
-    xa = x.toarray( with_pads=True )
+    xa = x.toarray(with_pads=True)
     ya = y.toarray()
 
     # Exact result using Numpy dot product
-    ya_exact = np.dot( Ma, xa )
+    ya_exact = np.dot(Ma, xa)
 
     # Check data in 1D array
-    assert np.allclose( ya, ya_exact, rtol=1e-13, atol=1e-13 )
+    assert np.allclose(ya, ya_exact, rtol=1e-13, atol=1e-13)
 
     # tests for backend propagation
     assert M.backend is backend
     assert M.T.backend is M.backend
-    assert (M+M).backend is M.backend
-    assert (2*M).backend is M.backend
+    assert (M + M).backend is M.backend
+    assert (2 * M).backend is M.backend
 
-#===============================================================================
+# TODO: Fix why dot don't work with complex and PSYDAC_BACKEND_GPYCCEL backend
+
+# ===============================================================================
 # SCRIPT FUNCTIONALITY
-#===============================================================================
+# ===============================================================================
 if __name__ == "__main__":
     import sys
-    pytest.main( sys.argv )
+
+    pytest.main(sys.argv)
+
+    # TODO : Add conjugate and vdot as properties and do some tests
Index: psydac/linalg/tests/test_stencil_vector.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># coding: utf-8\n\nimport pytest\nimport numpy as np\n\nfrom psydac.linalg.stencil import StencilVectorSpace, StencilVector\nfrom psydac.linalg.utilities import array_to_psydac\nfrom psydac.ddm.cart import DomainDecomposition, CartDecomposition\n\n\n# ===============================================================================\ndef compute_global_starts_ends(domain_decomposition, npts):\n    ndims = len(npts)\n    global_starts = [None] * ndims\n    global_ends = [None] * ndims\n\n    for axis in range(ndims):\n        es = domain_decomposition.global_element_starts[axis]\n        ee = domain_decomposition.global_element_ends[axis]\n\n        global_ends[axis] = ee.copy()\n        global_ends[axis][-1] = npts[axis] - 1\n        global_starts[axis] = np.array([0] + (global_ends[axis][:-1] + 1).tolist())\n\n    return global_starts, global_ends\n\n\n# ===============================================================================\n# SERIAL TESTS\n# ===============================================================================\n\n\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 7])\n@pytest.mark.parametrize('n2', [1, 5])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('p2', [1, 2])\ndef test_stencil_vector_2d_serial_init(dtype, n1, n2, p1, p2, P1=True, P2=False):\n    D = DomainDecomposition([n1, n2], periods=[P1, P2])\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n    V = StencilVectorSpace(C, dtype=dtype)\n    x = StencilVector(V)\n\n    assert x.space is V\n    assert x.dtype == dtype\n    assert x.starts == (0, 0)\n    assert x.ends == (n1 - 1, n2 - 1)\n    assert x.pads == (p1, p2)\n    assert x._data.shape == (n1 + 2 * p1, n2 + 2 * p2)\n    assert x._data.dtype == dtype\n    assert not x.ghost_regions_in_sync\n\n\n# ===============================================================================\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 7])\n@pytest.mark.parametrize('n2', [1, 5])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('p2', [1, 2])\ndef test_stencil_vector_2d_serial_copy(dtype, n1, n2, p1, p2, P1=True, P2=False):\n    D = DomainDecomposition([n1, n2], periods=[P1, P2])\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n\n    V = StencilVectorSpace(C, dtype=dtype)\n    x = StencilVector(V)\n\n    for i1 in range(n1):\n        for i2 in range(n2):\n            x[i1, i2] = 10 * i1 + i2\n\n    z = x.copy()\n\n    assert isinstance(z, StencilVector)\n    assert z.space is V\n    assert z._data is not x._data\n    assert z.dtype == dtype\n    assert np.array_equal(x._data, z._data)\n\n\n# ===============================================================================\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [7, 15])\n@pytest.mark.parametrize('n2', [8, 12])\n@pytest.mark.parametrize('p1', [1, 2, 3])\n@pytest.mark.parametrize('p2', [1, 2, 3])\ndef test_stencil_vector_2d_basic_ops(dtype, n1, n2, p1, p2, P1=True, P2=False):\n    D = DomainDecomposition([n1, n2], periods=[P1, P2])\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n\n    V = StencilVectorSpace(C, dtype=dtype)\n    M = StencilVector(V)\n\n    # take random data, but determinize it\n    np.random.seed(2)\n    if dtype == float:\n        M._data[:] = np.random.random(M._data.shape)\n    else:\n        M._data[:] = np.random.random(M._data.shape) + 1j * np.random.random(M._data.shape)\n\n    # we try to go for equality here...\n    assert (M * 2).dtype == dtype\n    assert np.array_equal((M * 2)._data, M._data * 2)\n    assert (M / 2).dtype == dtype\n    assert np.array_equal((M / 2)._data, M._data / 2)\n    assert (M + M).dtype == dtype\n    assert np.array_equal((M + M)._data, M._data + M._data)\n    assert (M - M).dtype == dtype\n    assert np.array_equal((M - M)._data, M._data - M._data)\n\n    M1 = M.copy()\n    M1 *= 2\n    M2 = M.copy()\n    M2 /= 2\n    M3 = M.copy()\n    M3 += M\n    M4 = M.copy()\n    M4 -= M\n\n    for (m, mex) in zip([M1, M2, M3, M4], [M._data * 2, M._data / 2, M._data + M._data, M._data - M._data]):\n        assert isinstance(m, StencilVector)\n        assert m.dtype == dtype\n        assert m.space is V\n        assert np.array_equal(m._data, mex)\n\n\n# ===============================================================================\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 7])\n@pytest.mark.parametrize('n2', [1, 5])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('p2', [1, 2])\ndef test_stencil_matrix_2d_serial_toarray(dtype, n1, n2, p1, p2, P1=True, P2=False):\n    D = DomainDecomposition([n1, n2], periods=[P1, P2])\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n\n    V = StencilVectorSpace(C, dtype=dtype)\n    x = StencilVector(V)\n\n    for i1 in range(n1):\n        for i2 in range(n2):\n            x[i1, i2] = 10 * i1 + i2\n\n    xc = x.toarray()\n    xf = x.toarray(order='F')\n    xcp = x.toarray(with_pads=True)\n    xfp = x.toarray(order='F', with_pads=True)\n\n    zc = np.zeros((n1 * n2))\n    zf = np.zeros((n1 * n2))\n    zcp = np.zeros(((n1 + 2 * p1) * (n2 + 2 * p2)))\n    zfp = np.zeros(((n1 + 2 * p1) * (n2 + 2 * p2)))\n    for i1 in range(n1):\n        for i2 in range(n2):\n            zc[i1 * n2 + i2] = 10 * i1 + i2\n            zf[i1 + i2 * n1] = 10 * i1 + i2\n    # Verify toarray() with and without padding\n    for (x, z) in zip([xc, xf, xcp, xc], [zc, zf, zc, zf]):\n        assert x.shape == (n1 * n2,)\n        assert x.dtype == dtype\n        assert np.array_equal(xc, zc)\n\n\n# ===============================================================================\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 7])\n@pytest.mark.parametrize('n2', [1, 5])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('p2', [1, 2])\ndef test_stencil_vector_2d_serial_math(dtype, n1, n2, p1, p2, P1=True, P2=False):\n    D = DomainDecomposition([n1, n2], periods=[P1, P2])\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n\n    V = StencilVectorSpace(C, dtype=dtype)\n    x = StencilVector(V)\n    y = StencilVector(V)\n    if dtype == complex:\n        for i1 in range(n1):\n            for i2 in range(n2):\n                x[i1, i2] = 10 * i1 + 1j * i2\n    else:\n        for i1 in range(n1):\n            for i2 in range(n2):\n                x[i1, i2] = 10 * i1 + i2\n\n    y[:, :] = 42.0\n\n    r1 = x + y\n    r2 = x - y\n    r3 = 2 * x\n    r4 = x * 2\n\n    xa = x.toarray()\n    ya = y.toarray()\n\n    r1_exact = xa + ya\n    r2_exact = xa - ya\n    r3_exact = 2 * xa\n    r4_exact = xa * 2\n\n    for (r, rex) in zip([r1, r2, r3, r4], [r1_exact, r2_exact, r3_exact, r4_exact]):\n        assert isinstance(r, StencilVector)\n        assert r.space is V\n        assert r.dtype == dtype\n        assert np.array_equal(r.toarray(), rex)\n\n\n# ===============================================================================\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 7])\n@pytest.mark.parametrize('n2', [1, 5])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('p2', [1, 2])\ndef test_stencil_vector_2d_serial_dot(dtype, n1, n2, p1, p2, P1=True, P2=False):\n    D = DomainDecomposition([n1, n2], periods=[P1, P2])\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n\n    V = StencilVectorSpace(C, dtype)\n    x = StencilVector(V)\n    y = StencilVector(V)\n    if dtype == complex:\n        for i1 in range(n1):\n            for i2 in range(n2):\n                x[i1, i2] = 10j * i1 + i2\n                y[i1, i2] = 10j * i2 - i1\n    else:\n        for i1 in range(n1):\n            for i2 in range(n2):\n                x[i1, i2] = 10 * i1 + i2\n                y[i1, i2] = 10 * i2 - i1\n\n    z1 = x.dot(y)\n    z2 = y.dot(x)\n\n    z_exact = np.dot(x.toarray(), y.toarray())\n\n    assert z1.dtype == dtype\n    assert z2.dtype == dtype\n    assert z1 == z_exact\n    assert z2 == z_exact\n\n\n# ===============================================================================\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 7])\n@pytest.mark.parametrize('n2', [1, 5])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('p2', [1, 2])\ndef test_stencil_vector_2d_serial_vdot(dtype, n1, n2, p1, p2, P1=True, P2=False):\n    D = DomainDecomposition([n1, n2], periods=[P1, P2])\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n\n    V = StencilVectorSpace(C, dtype)\n    x = StencilVector(V)\n    y = StencilVector(V)\n    if dtype == complex:\n        for i1 in range(n1):\n            for i2 in range(n2):\n                x[i1, i2] = 10j * i1 + i2\n                y[i1, i2] = 10j * i2 - i1\n    else:\n        for i1 in range(n1):\n            for i2 in range(n2):\n                x[i1, i2] = 10 * i1 + i2\n                y[i1, i2] = 10 * i2 - i1\n\n    z1 = x.vdot(y)\n    z2 = y.vdot(x)\n\n    z_exact = np.vdot(x.toarray(), y.toarray())\n\n    assert z1.dtype == dtype\n    assert z2.dtype == dtype\n    assert z1 == z_exact\n    assert z2 == z_exact.conjugate()\n\n\n# ===============================================================================\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 7])\n@pytest.mark.parametrize('n2', [1, 5])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('p2', [1, 2])\ndef test_stencil_vector_2d_serial_conjugate(dtype, n1, n2, p1, p2, P1=True, P2=False):\n    D = DomainDecomposition([n1, n2], periods=[P1, P2])\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n\n    V = StencilVectorSpace(C, dtype)\n    x = StencilVector(V)\n    if dtype == complex:\n        for i1 in range(n1):\n            for i2 in range(n2):\n                x[i1, i2] = 10j * i1 + i2\n    else:\n        for i1 in range(n1):\n            for i2 in range(n2):\n                x[i1, i2] = 10 * i1 + i2\n\n    z = x.conjugate()\n\n    z_exact = x._data.conjugate()\n\n    assert z.dtype == dtype\n    assert np.array_equal(z._data, z_exact)\n\n\n# ===============================================================================\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 7])\n@pytest.mark.parametrize('n2', [1, 5])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('p2', [1, 2])\n@pytest.mark.parametrize('P1', [True, False])\n@pytest.mark.parametrize('P2', [True, False])\ndef test_stencil_2d_array_to_psydac(dtype, n1, n2, p1, p2, P1, P2):\n    D = DomainDecomposition([n1, n2], periods=[P1, P2])\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n\n    V = StencilVectorSpace(C, dtype=dtype)\n    x = StencilVector(V)\n\n    if dtype == complex:\n        for i1 in range(n1):\n            for i2 in range(n2):\n                x[i1, i2] = 10j * i1 + i2\n    else:\n        for i1 in range(n1):\n            for i2 in range(n2):\n                x[i1, i2] = 10 * i1 + i2\n\n    xa = x.toarray()\n    v = array_to_psydac(xa, V)\n\n    assert v.dtype == dtype\n    # assert np.allclose( xa , v.toarray() )\n    assert np.array_equal(xa, v.toarray())\n\n\n# ===============================================================================\n# PARALLEL TESTS\n# ===============================================================================\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [12, 22])\n@pytest.mark.parametrize('n2', [12, 24])\n@pytest.mark.parametrize('p1', [1, 3, 4])\n@pytest.mark.parametrize('p2', [1, 3, 4])\n@pytest.mark.parallel\ndef test_stencil_vector_2d_parallel_init(dtype, n1, n2, p1, p2, P1=True, P2=False):\n    from mpi4py import MPI\n\n    comm = MPI.COMM_WORLD\n    D = DomainDecomposition([n1, n2], periods=[P1, P2], comm=comm)\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n\n    V = StencilVectorSpace(cart, dtype=dtype)\n    x = StencilVector(V)\n\n    assert x.space is V\n    assert x.dtype == dtype\n    assert x.starts == (0, 0)\n    assert x.ends == (n1 - 1, n2 - 1)\n    assert x.pads == (p1, p2)\n    assert x._data.shape == (n1 + 2 * p1, n2 + 2 * p2)\n    assert x._data.dtype == dtype\n    assert not x.ghost_regions_in_sync\n\n\n# ===============================================================================\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [20, 64])\n@pytest.mark.parametrize('n2', [24, 64])\n@pytest.mark.parametrize('p1', [1, 3, 4])\n@pytest.mark.parametrize('p2', [1, 3, 4])\n@pytest.mark.parametrize('P1', [True, False])\n@pytest.mark.parametrize('P2', [True, False])\n@pytest.mark.parallel\ndef test_stencil_vector_2d_parallel_toarray(dtype, n1, n2, p1, p2, P1, P2):\n    from mpi4py import MPI\n\n    comm = MPI.COMM_WORLD\n    D = DomainDecomposition([n1, n2], periods=[P1, P2], comm=comm)\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n\n    V = StencilVectorSpace(cart, dtype=dtype)\n    x = StencilVector(V)\n\n    # Values in 2D grid (global indexing)\n    if dtype==complex:\n        f = lambda i1, i2: 100j * i1 + i2\n    else:\n        f = lambda i1, i2: 100 * i1 + i2\n\n    # Initialize distributed 2D stencil vector\n    for i1 in range(V.starts[0], V.ends[0] + 1):\n        for i2 in range(V.starts[1], V.ends[1] + 1):\n            x[i1, i2] = f(i1, i2)\n\n    x.update_ghost_regions()\n\n    assert x.dtype == dtype\n\n    # Construct local 2D array manually\n    z = np.zeros((n1, n2), dtype=dtype)\n    for i1 in range(cart.starts[0], cart.ends[0] + 1):\n        for i2 in range(cart.starts[1], cart.ends[1] + 1):\n            z[i1, i2] = f(i1, i2)\n\n    # Verify toarray() without padding\n    xa = x.toarray()\n    za = z.reshape(-1)\n\n    assert xa.dtype == dtype\n    assert xa.shape == (n1 * n2,)\n    assert np.array_equal(xa, za)\n\n    # Verify toarray() with padding: internal region should not change\n    xe = x.toarray(with_pads=True)\n    xe = xe.reshape(n1, n2)\n    index = tuple(slice(s, e + 1) for s, e in zip(cart.starts, cart.ends))\n\n    # print()\n    # print(z)\n    # print()\n    # print(xe.reshape(n1, n2))\n\n    assert xe.dtype == dtype\n    assert xe.shape == (n1 ,n2)\n    assert np.all(xe[index] == z[index])\n    # assert np.array_equal(xe[index] == z[index])\n\n    # TODO: test that ghost regions have been properly copied to 'xe' array\n    # TODO: x.toarray ne marche pas pour les complexes\n# ===============================================================================\n@pytest.mark.parametrize('n1', [12, 24])\n@pytest.mark.parametrize('n2', [12, 24])\n@pytest.mark.parametrize('p1', [1, 3, 4])\n@pytest.mark.parametrize('p2', [1, 3, 4])\n@pytest.mark.parametrize('P1', [True, False])\n@pytest.mark.parametrize('P2', [True, False])\n@pytest.mark.parallel\ndef test_stencil_vector_2d_parallel_dot(n1, n2, p1, p2, P1, P2):\n    from mpi4py import MPI\n\n    comm = MPI.COMM_WORLD\n    D = DomainDecomposition([n1, n2], periods=[P1, P2], comm=comm)\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n\n    V = StencilVectorSpace(cart)\n    x = StencilVector(V)\n    y = StencilVector(V)\n\n    for i1 in range(V.starts[0], V.ends[0] + 1):\n        for i2 in range(V.starts[1], V.ends[1] + 1):\n            x[i1, i2] = 10 * i1 + i2\n            y[i1, i2] = 10 * i2 - i1\n\n    res1 = x.dot(y)\n    res2 = y.dot(x)\n    res_ex = comm.allreduce(np.dot(x.toarray(), y.toarray()))\n\n    assert res1 == res_ex\n    assert res2 == res_ex\n\n\n# TODO: add test str, topestc, update_ghost_region, exchange_assembly_data, right multiplication\n# ===============================================================================\nif __name__ == \"__main__\":\n    import sys\n\n    pytest.main(sys.argv)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/psydac/linalg/tests/test_stencil_vector.py b/psydac/linalg/tests/test_stencil_vector.py
--- a/psydac/linalg/tests/test_stencil_vector.py	
+++ b/psydac/linalg/tests/test_stencil_vector.py	
@@ -35,13 +35,15 @@
 @pytest.mark.parametrize('n2', [1, 5])
 @pytest.mark.parametrize('p1', [1, 2])
 @pytest.mark.parametrize('p2', [1, 2])
-def test_stencil_vector_2d_serial_init(dtype, n1, n2, p1, p2, P1=True, P2=False):
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+def test_stencil_vector_2d_serial_init(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
     D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
     V = StencilVectorSpace(C, dtype=dtype)
     x = StencilVector(V)
 
@@ -50,7 +52,7 @@
     assert x.starts == (0, 0)
     assert x.ends == (n1 - 1, n2 - 1)
     assert x.pads == (p1, p2)
-    assert x._data.shape == (n1 + 2 * p1, n2 + 2 * p2)
+    assert x._data.shape == (n1 + 2 * p1 * s1, n2 + 2 * p2 * s2)
     assert x._data.dtype == dtype
     assert not x.ghost_regions_in_sync
 
@@ -61,20 +63,25 @@
 @pytest.mark.parametrize('n2', [1, 5])
 @pytest.mark.parametrize('p1', [1, 2])
 @pytest.mark.parametrize('p2', [1, 2])
-def test_stencil_vector_2d_serial_copy(dtype, n1, n2, p1, p2, P1=True, P2=False):
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+def test_stencil_vector_2d_serial_copy(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
     D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     V = StencilVectorSpace(C, dtype=dtype)
     x = StencilVector(V)
 
-    for i1 in range(n1):
-        for i2 in range(n2):
-            x[i1, i2] = 10 * i1 + i2
+    # take random data, but determinize it
+    np.random.seed(2)
+    if dtype == float:
+        x._data[:] = np.random.random(x._data.shape)
+    else:
+        x._data[:] = np.random.random(x._data.shape) + 1j * np.random.random(x._data.shape)
 
     z = x.copy()
 
@@ -91,13 +98,15 @@
 @pytest.mark.parametrize('n2', [8, 12])
 @pytest.mark.parametrize('p1', [1, 2, 3])
 @pytest.mark.parametrize('p2', [1, 2, 3])
-def test_stencil_vector_2d_basic_ops(dtype, n1, n2, p1, p2, P1=True, P2=False):
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+def test_stencil_vector_2d_basic_ops(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
     D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     V = StencilVectorSpace(C, dtype=dtype)
     M = StencilVector(V)
@@ -141,13 +150,15 @@
 @pytest.mark.parametrize('n2', [1, 5])
 @pytest.mark.parametrize('p1', [1, 2])
 @pytest.mark.parametrize('p2', [1, 2])
-def test_stencil_matrix_2d_serial_toarray(dtype, n1, n2, p1, p2, P1=True, P2=False):
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+def test_stencil_matrix_2d_serial_toarray(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
     D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     V = StencilVectorSpace(C, dtype=dtype)
     x = StencilVector(V)
@@ -165,10 +176,12 @@
     zf = np.zeros((n1 * n2))
     zcp = np.zeros(((n1 + 2 * p1) * (n2 + 2 * p2)))
     zfp = np.zeros(((n1 + 2 * p1) * (n2 + 2 * p2)))
+
     for i1 in range(n1):
         for i2 in range(n2):
             zc[i1 * n2 + i2] = 10 * i1 + i2
             zf[i1 + i2 * n1] = 10 * i1 + i2
+
     # Verify toarray() with and without padding
     for (x, z) in zip([xc, xf, xcp, xc], [zc, zf, zc, zf]):
         assert x.shape == (n1 * n2,)
@@ -182,25 +195,26 @@
 @pytest.mark.parametrize('n2', [1, 5])
 @pytest.mark.parametrize('p1', [1, 2])
 @pytest.mark.parametrize('p2', [1, 2])
-def test_stencil_vector_2d_serial_math(dtype, n1, n2, p1, p2, P1=True, P2=False):
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+def test_stencil_vector_2d_serial_math(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
     D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     V = StencilVectorSpace(C, dtype=dtype)
     x = StencilVector(V)
     y = StencilVector(V)
-    if dtype == complex:
-        for i1 in range(n1):
-            for i2 in range(n2):
-                x[i1, i2] = 10 * i1 + 1j * i2
+
+    # take random data, but determinize it
+    np.random.seed(2)
+    if dtype == float:
+        x._data[:] = np.random.random(x._data.shape)
     else:
-        for i1 in range(n1):
-            for i2 in range(n2):
-                x[i1, i2] = 10 * i1 + i2
+        x._data[:] = np.random.random(x._data.shape) + 1j * np.random.random(x._data.shape)
 
     y[:, :] = 42.0
 
@@ -230,13 +244,15 @@
 @pytest.mark.parametrize('n2', [1, 5])
 @pytest.mark.parametrize('p1', [1, 2])
 @pytest.mark.parametrize('p2', [1, 2])
-def test_stencil_vector_2d_serial_dot(dtype, n1, n2, p1, p2, P1=True, P2=False):
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+def test_stencil_vector_2d_serial_dot(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
     D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     V = StencilVectorSpace(C, dtype)
     x = StencilVector(V)
@@ -269,13 +285,15 @@
 @pytest.mark.parametrize('n2', [1, 5])
 @pytest.mark.parametrize('p1', [1, 2])
 @pytest.mark.parametrize('p2', [1, 2])
-def test_stencil_vector_2d_serial_vdot(dtype, n1, n2, p1, p2, P1=True, P2=False):
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+def test_stencil_vector_2d_serial_vdot(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
     D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     V = StencilVectorSpace(C, dtype)
     x = StencilVector(V)
@@ -308,13 +326,15 @@
 @pytest.mark.parametrize('n2', [1, 5])
 @pytest.mark.parametrize('p1', [1, 2])
 @pytest.mark.parametrize('p2', [1, 2])
-def test_stencil_vector_2d_serial_conjugate(dtype, n1, n2, p1, p2, P1=True, P2=False):
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+def test_stencil_vector_2d_serial_conjugate(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
     D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     V = StencilVectorSpace(C, dtype)
     x = StencilVector(V)
@@ -341,15 +361,17 @@
 @pytest.mark.parametrize('n2', [1, 5])
 @pytest.mark.parametrize('p1', [1, 2])
 @pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
 @pytest.mark.parametrize('P1', [True, False])
 @pytest.mark.parametrize('P2', [True, False])
-def test_stencil_2d_array_to_psydac(dtype, n1, n2, p1, p2, P1, P2):
+def test_stencil_vector_2d_array_to_psydac(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     V = StencilVectorSpace(C, dtype=dtype)
     x = StencilVector(V)
@@ -371,6 +393,197 @@
     assert np.array_equal(xa, v.toarray())
 
 
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 7])
+@pytest.mark.parametrize('n2', [5, 9])
+@pytest.mark.parametrize('p1', [1, 2])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
+def test_stencil_vector_2d_serial_update_ghost_region(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
+
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts)
+
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
+
+    V = StencilVectorSpace(C, dtype=dtype)
+    x = StencilVector(V)
+    if dtype == complex:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 10j * i1
+    else:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 10 * i1
+
+    x.update_ghost_regions()
+    data = x._data
+
+    assert x._sync
+    if P1:
+        assert np.array_equal(data[0:p1 * s1, :], data[n1:n1 + p1 * s1, :])
+        assert np.array_equal(data[n1 + p1 * s1:n1 + 2 * p1 * s1, :], data[p1 * s1:2 * p1 * s1, :])
+    else:
+        assert np.array_equal(data[0:p1 * s1, :], np.zeros((p1 * s1, n2 + 2 * p2 * s2), dtype=dtype))
+        assert np.array_equal(data[n1 + p1 * s1:n1 + 2 * p1 * s1, :],
+                              np.zeros((p1 * s1, n2 + 2 * p2 * s2), dtype=dtype))
+
+    if P2:
+        assert np.array_equal(data[:, 0:p2 * s2], data[:, n2:n2 + p2 * s2])
+        assert np.array_equal(data[:, n2 + p2 * s2:n2 + 2 * p2 * s2], data[:, p2 * s2:2 * p2 * s2])
+    else:
+        assert np.array_equal(data[:, 0:p2 * s2], np.zeros((n1 + 2 * p1 * s1, p2 * s2), dtype=dtype))
+        assert np.array_equal(data[:, n2 + p2 * s2:n2 + 2 * p2 * s2],
+                              np.zeros((n1 + 2 * p1 * s1, p2 * s2), dtype=dtype))
+
+    # TODO : test update ghost region interface
+
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 7])
+@pytest.mark.parametrize('n2', [5, 9])
+@pytest.mark.parametrize('p1', [1, 2])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
+def test_stencil_vector_2d_serial_update_ghost_region_interior(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
+
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts)
+
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
+
+    V = StencilVectorSpace(C, dtype=dtype)
+    x = StencilVector(V)
+    if dtype == complex:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 10j * i1
+    else:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 10 * i1
+
+    x.update_ghost_regions()
+    data = x._data
+
+    assert x._sync
+    if P1:
+        assert np.array_equal(data[0:p1 * s1, :], data[n1:n1 + p1 * s1, :])
+        assert np.array_equal(data[n1 + p1 * s1:n1 + 2 * p1 * s1, :], data[p1 * s1:2 * p1 * s1, :])
+    else:
+        assert np.array_equal(data[0:p1 * s1, :], np.zeros((p1 * s1, n2 + 2 * p2 * s2), dtype=dtype))
+        assert np.array_equal(data[n1 + p1 * s1:n1 + 2 * p1 * s1, :],
+                              np.zeros((p1 * s1, n2 + 2 * p2 * s2), dtype=dtype))
+
+    if P2:
+        assert np.array_equal(data[:, 0:p2 * s2], data[:, n2:n2 + p2 * s2])
+        assert np.array_equal(data[:, n2 + p2 * s2:n2 + 2 * p2 * s2], data[:, p2 * s2:2 * p2 * s2])
+    else:
+        assert np.array_equal(data[:, 0:p2 * s2], np.zeros((n1 + 2 * p1 * s1, p2 * s2), dtype=dtype))
+        assert np.array_equal(data[:, n2 + p2 * s2:n2 + 2 * p2 * s2],
+                              np.zeros((n1 + 2 * p1 * s1, p2 * s2), dtype=dtype))
+
+
+# ===============================================================================
+"""
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 7])
+@pytest.mark.parametrize('n2', [5, 9])
+@pytest.mark.parametrize('p1', [1, 2])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+@pytest.mark.parametrize('axis', [0, 1])
+@pytest.mark.parametrize('ext', [-1, 1])
+def test_stencil_vector_2d_serial_update_ghost_region_interface(dtype, n1, n2, p1, p2, s1, s2, axis, ext, P1=False,
+                                                                P2=False):
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
+
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts)
+
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
+
+    V = StencilVectorSpace(C, dtype=dtype)
+    V.set_interface(axis, ext, C)
+
+    x = StencilVector(V)
+
+    if dtype == complex:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 10j * i1 + i2
+    else:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 10 * i1 + i2
+
+    x.update_ghost_regions()
+
+    V_inter = V.interfaces[axis, ext]
+    starts_inter = V_inter.starts
+    ends_inter = V_inter.ends
+    x_inter = x._data[starts_inter[0]:ends_inter[0] + 2 * s1 * p1 + 1, starts_inter[1]:ends_inter[1] + 2 * s2 * p2 + 1]
+
+    assert x._sync
+    print(x._interface_data[axis, ext][...])
+    print(x_inter)
+    assert np.array_equal(x._interface_data[axis, ext][...], x_inter)
+
+    # TODO : make this test work because it seems that the interface had wrong size
+"""
+
+# ===============================================================================
+"""
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [1, 7])
+@pytest.mark.parametrize('n2', [1, 5])
+@pytest.mark.parametrize('p1', [1, 2])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
+def test_stencil_2d_array_to_petsc(dtype, n1, n2, p1, p2, P1, P2):
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
+
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts)
+
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+
+    V = StencilVectorSpace(C, dtype=dtype)
+    x = StencilVector(V)
+
+    if dtype == complex:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 10j * i1 + i2
+    else:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 10 * i1 + i2
+
+    xa = x.topetsc()
+    from psydac.linalg.topetsc import vec_topetsc
+    vec = vec_topetsc(x)
+
+    assert xa.dtype == dtype
+    assert xa.shape == (n1, n2)
+    assert xa == vec
+    # TODO : You need the module petsc4py which is not installed for now
+"""
+
+
 # ===============================================================================
 # PARALLEL TESTS
 # ===============================================================================
@@ -379,8 +592,10 @@
 @pytest.mark.parametrize('n2', [12, 24])
 @pytest.mark.parametrize('p1', [1, 3, 4])
 @pytest.mark.parametrize('p2', [1, 3, 4])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
 @pytest.mark.parallel
-def test_stencil_vector_2d_parallel_init(dtype, n1, n2, p1, p2, P1=True, P2=False):
+def test_stencil_vector_2d_parallel_init(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
     from mpi4py import MPI
 
     comm = MPI.COMM_WORLD
@@ -389,7 +604,7 @@
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     V = StencilVectorSpace(cart, dtype=dtype)
     x = StencilVector(V)
@@ -399,7 +614,7 @@
     assert x.starts == (0, 0)
     assert x.ends == (n1 - 1, n2 - 1)
     assert x.pads == (p1, p2)
-    assert x._data.shape == (n1 + 2 * p1, n2 + 2 * p2)
+    assert x._data.shape == (n1 + 2 * p1 * s1, n2 + 2 * p2 * s2)
     assert x._data.dtype == dtype
     assert not x.ghost_regions_in_sync
 
@@ -410,10 +625,10 @@
 @pytest.mark.parametrize('n2', [24, 64])
 @pytest.mark.parametrize('p1', [1, 3, 4])
 @pytest.mark.parametrize('p2', [1, 3, 4])
-@pytest.mark.parametrize('P1', [True, False])
-@pytest.mark.parametrize('P2', [True, False])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
 @pytest.mark.parallel
-def test_stencil_vector_2d_parallel_toarray(dtype, n1, n2, p1, p2, P1, P2):
+def test_stencil_vector_2d_parallel_toarray(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
     from mpi4py import MPI
 
     comm = MPI.COMM_WORLD
@@ -422,13 +637,13 @@
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
     V = StencilVectorSpace(cart, dtype=dtype)
     x = StencilVector(V)
 
     # Values in 2D grid (global indexing)
-    if dtype==complex:
+    if dtype == complex:
         f = lambda i1, i2: 100j * i1 + i2
     else:
         f = lambda i1, i2: 100 * i1 + i2
@@ -467,21 +682,22 @@
     # print(xe.reshape(n1, n2))
 
     assert xe.dtype == dtype
-    assert xe.shape == (n1 ,n2)
-    assert np.all(xe[index] == z[index])
-    # assert np.array_equal(xe[index] == z[index])
+    assert xe.shape == (n1, n2)
+    assert np.array_equal(xe[index], z[index])
 
     # TODO: test that ghost regions have been properly copied to 'xe' array
-    # TODO: x.toarray ne marche pas pour les complexes
+
+
 # ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
 @pytest.mark.parametrize('n1', [12, 24])
 @pytest.mark.parametrize('n2', [12, 24])
 @pytest.mark.parametrize('p1', [1, 3, 4])
 @pytest.mark.parametrize('p2', [1, 3, 4])
-@pytest.mark.parametrize('P1', [True, False])
-@pytest.mark.parametrize('P2', [True, False])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
 @pytest.mark.parallel
-def test_stencil_vector_2d_parallel_dot(n1, n2, p1, p2, P1, P2):
+def test_stencil_vector_2d_parallel_dot(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
     from mpi4py import MPI
 
     comm = MPI.COMM_WORLD
@@ -490,9 +706,9 @@
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
 
-    V = StencilVectorSpace(cart)
+    V = StencilVectorSpace(cart, dtype=dtype)
     x = StencilVector(V)
     y = StencilVector(V)
 
@@ -509,8 +725,104 @@
     assert res2 == res_ex
 
 
-# TODO: add test str, topestc, update_ghost_region, exchange_assembly_data, right multiplication
 # ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [12, 24])
+@pytest.mark.parametrize('n2', [12, 24])
+@pytest.mark.parametrize('p1', [1, 3, 4])
+@pytest.mark.parametrize('p2', [1, 3, 4])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+@pytest.mark.parallel
+def test_stencil_vector_2d_parallel_vdot(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
+    from mpi4py import MPI
+
+    comm = MPI.COMM_WORLD
+    D = DomainDecomposition([n1, n2], periods=[P1, P2], comm=comm)
+
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts)
+
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
+
+    V = StencilVectorSpace(cart, dtype=dtype)
+    x = StencilVector(V)
+    y = StencilVector(V)
+
+    for i1 in range(V.starts[0], V.ends[0] + 1):
+        for i2 in range(V.starts[1], V.ends[1] + 1):
+            x[i1, i2] = 10 * i1 + i2
+            y[i1, i2] = 10 * i2 - i1
+
+    res1 = x.vdot(y)
+    res2 = y.vdot(x)
+    res_ex1 = comm.allreduce(np.vdot(x.toarray(), y.toarray()))
+    res_ex2 = comm.allreduce(np.vdot(y.toarray(), x.toarray()))
+
+    assert res1 == res_ex1
+    assert res2 == res_ex2
+
+
+# ===============================================================================
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 7])
+@pytest.mark.parametrize('n2', [5, 9])
+@pytest.mark.parametrize('p1', [1, 2])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
+@pytest.mark.parallel
+def test_stencil_vector_2d_parallel_update_ghost_region_interior(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
+    from mpi4py import MPI
+
+    comm = MPI.COMM_WORLD
+    D = DomainDecomposition([n1, n2], periods=[P1, P2], comm=comm)
+
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts)
+
+    cart = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
+
+    V = StencilVectorSpace(cart, dtype=dtype)
+    x = StencilVector(V)
+    if dtype == complex:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 10j * i1
+    else:
+        for i1 in range(n1):
+            for i2 in range(n2):
+                x[i1, i2] = 10 * i1
+
+    x.update_ghost_regions()
+    data = x._data
+
+    assert x._sync
+    if P1:
+        assert np.array_equal(data[0:p1 * s1, :], data[n1:n1 + p1 * s1, :])
+        assert np.array_equal(data[n1 + p1 * s1:n1 + 2 * p1 * s1, :], data[p1 * s1:2 * p1 * s1, :])
+    else:
+        assert np.array_equal(data[0:p1 * s1, :], np.zeros((p1 * s1, n2 + 2 * p2 * s2), dtype=dtype))
+        assert np.array_equal(data[n1 + p1 * s1:n1 + 2 * p1 * s1, :],
+                              np.zeros((p1 * s1, n2 + 2 * p2 * s2), dtype=dtype))
+
+    if P2:
+        assert np.array_equal(data[:, 0:p2 * s2], data[:, n2:n2 + p2 * s2])
+        assert np.array_equal(data[:, n2 + p2 * s2:n2 + 2 * p2 * s2], data[:, p2 * s2:2 * p2 * s2])
+    else:
+        assert np.array_equal(data[:, 0:p2 * s2], np.zeros((n1 + 2 * p1 * s1, p2 * s2), dtype=dtype))
+        assert np.array_equal(data[:, n2 + p2 * s2:n2 + 2 * p2 * s2],
+                              np.zeros((n1 + 2 * p1 * s1, p2 * s2), dtype=dtype))
+
+
+# TODO: add test exchange_assembly_data
+# TODO comment the code
+# TODO : Add some test for the dimension
+#===============================================================================
+# SCRIPT FUNCTIONALITY
+#===============================================================================
 if __name__ == "__main__":
     import sys
 
Index: .idea/vcs.xml
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/vcs.xml	
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/modules.xml
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/modules.xml	
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/psydac.iml" filepath="$PROJECT_DIR$/.idea/psydac.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/psydac.iml
===================================================================
diff --git a/.idea/psydac.iml b/.idea/psydac.iml
new file mode 100644
--- /dev/null	
+++ b/.idea/psydac.iml	
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="PYTHON_MODULE" version="4">
+  <component name="NewModuleRootManager">
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+  <component name="PyDocumentationSettings">
+    <option name="format" value="NUMPY" />
+    <option name="myDocStringFormat" value="NumPy" />
+  </component>
+  <component name="TestRunnerService">
+    <option name="PROJECT_TEST_RUNNER" value="py.test" />
+  </component>
+</module>
\ No newline at end of file
Index: .idea/inspectionProfiles/profiles_settings.xml
===================================================================
diff --git a/.idea/inspectionProfiles/profiles_settings.xml b/.idea/inspectionProfiles/profiles_settings.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/inspectionProfiles/profiles_settings.xml	
@@ -0,0 +1,6 @@
+<component name="InspectionProjectProfileManager">
+  <settings>
+    <option name="USE_PROJECT_PROFILE" value="false" />
+    <version value="1.0" />
+  </settings>
+</component>
\ No newline at end of file
Index: .idea/.gitignore
===================================================================
diff --git a/.idea/.gitignore b/.idea/.gitignore
new file mode 100644
--- /dev/null	
+++ b/.idea/.gitignore	
@@ -0,0 +1,3 @@
+# Default ignored files
+/shelf/
+/workspace.xml
Index: .idea/misc.xml
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/misc.xml	
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.8 (psydac)" project-jdk-type="Python SDK" />
+</project>
\ No newline at end of file
Index: psydac/linalg/tests/test_stencil_vector_space.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pytest\nimport numpy as np\n\nfrom psydac.linalg.stencil import StencilVectorSpace, StencilVector\nfrom psydac.ddm.cart import DomainDecomposition, CartDecomposition, find_mpi_type\n\n\n# ===============================================================================\ndef compute_global_starts_ends(domain_decomposition, npts):\n    ndims = len(npts)\n    global_starts = [None] * ndims\n    global_ends = [None] * ndims\n\n    for axis in range(ndims):\n        es = domain_decomposition.global_element_starts[axis]\n        ee = domain_decomposition.global_element_ends[axis]\n\n        global_ends[axis] = ee.copy()\n        global_ends[axis][-1] = npts[axis] - 1\n        global_starts[axis] = np.array([0] + (global_ends[axis][:-1] + 1).tolist())\n\n    return global_starts, global_ends\n\n\n# ===============================================================================\n# SERIAL TESTS\n# ===============================================================================\n\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 7])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('P1', [True, False])\n@pytest.mark.parametrize('s1', [1, 2])\n\ndef test_stencil_vector_space_1d_serial_init(dtype, n1, p1, P1, s1):\n    D = DomainDecomposition([n1], periods=[P1])\n\n    npts = [n1]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[s1])\n    V = StencilVectorSpace(C, dtype=dtype)\n\n    assert V.dimension == n1\n    assert V.dtype == dtype\n    assert V.mpi_type == find_mpi_type(dtype)\n    assert V.shape == (n1 + 2 * p1*s1,)\n    assert not V.parallel\n    assert V.cart == C\n    assert V.npts == (n1,)\n    assert V.starts == (0,)\n    assert V.ends == (n1 - 1,)\n    assert V.parent_starts == (None,)\n    assert V.parent_ends == (None,)\n    assert V.pads == (p1,)\n    assert V.periods == (P1,)\n    assert V.shifts == (s1,)\n    assert V.ndim == 1\n    assert V.interfaces == type(type.__dict__)({})\n# ===============================================================================\n\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 7])\n@pytest.mark.parametrize('n2', [1, 5])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('p2', [1, 2])\n@pytest.mark.parametrize('P1', [True, False])\n@pytest.mark.parametrize('P2', [True, False])\n@pytest.mark.parametrize('s1', [1, 2])\n@pytest.mark.parametrize('s2', [1, 2])\n\ndef test_stencil_vector_space_2d_serial_init(dtype, n1, n2, p1, p2, P1, P2, s1, s2):\n    D = DomainDecomposition([n1, n2], periods=[P1, P2])\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])\n    V = StencilVectorSpace(C, dtype=dtype)\n\n    assert V.dimension == n1 * n2\n    assert V.dtype == dtype\n    assert V.mpi_type == find_mpi_type(dtype)\n    assert V.shape == ((n1 + 2 * p1*s1), (n2 + 2 * p2*s2))\n    assert not V.parallel\n    assert V.cart == C\n    assert V.npts == (n1, n2)\n    assert V.starts == (0, 0)\n    assert V.ends == (n1 - 1, n2 - 1)\n    assert V.parent_starts == (None, None)\n    assert V.parent_ends == (None, None)\n    assert V.pads == (p1, p2)\n    assert V.periods == (P1,P2)\n    assert V.shifts == (s1, s2)\n    assert V.ndim == 2\n    assert V.interfaces == type(type.__dict__)({})\n# ===============================================================================\n\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 9])\n@pytest.mark.parametrize('n2', [1, 7])\n@pytest.mark.parametrize('n3', [1, 5])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('p2', [1, 2])\n@pytest.mark.parametrize('p3', [1, 2])\n@pytest.mark.parametrize('P1', [True, False])\n@pytest.mark.parametrize('P2', [True, False])\n@pytest.mark.parametrize('P3', [True, False])\n@pytest.mark.parametrize('s1', [1, 2])\n@pytest.mark.parametrize('s2', [1, 2])\n@pytest.mark.parametrize('s3', [1, 2])\n\ndef test_stencil_vector_space_3d_serial_init(dtype, n1, n2, n3, p1, p2, p3, P1, P2, P3, s1, s2, s3):\n    D = DomainDecomposition([n1,n2,n3], periods=[P1, P2, P3])\n\n    npts = [n1,n2, n3]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2, p3], shifts=[s1, s2, s3])\n    V = StencilVectorSpace(C, dtype=dtype)\n\n    assert V.dimension == n1*n2*n3\n    assert V.dtype == dtype\n    assert V.mpi_type == find_mpi_type(dtype)\n    assert V.shape == (n1 + 2 * p1*s1, n2 + 2 * p2*s2, n3 + 2 * p3*s3)\n    assert not V.parallel\n    assert V.cart == C\n    assert V.npts == (n1, n2, n3)\n    assert V.starts == (0, 0, 0)\n    assert V.ends == (n1 - 1, n2 - 1, n3 - 1)\n    assert V.parent_starts == (None, None, None)\n    assert V.parent_ends == (None, None, None)\n    assert V.pads == (p1, p2, p3)\n    assert V.periods == (P1, P2, P3)\n    assert V.shifts == (s1, s2, s3)\n    assert V.ndim == 3\n    assert V.interfaces == type(type.__dict__)({})\n# ===============================================================================\n\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [2, 9])\n@pytest.mark.parametrize('n2', [2, 7])\n@pytest.mark.parametrize('n3', [2, 5])\n\ndef test_stencil_vector_space_3D_serial_parent(dtype, n1, n2, n3, P1=True, P2=False, P3=True):\n    D = DomainDecomposition([n1, n2, n3], periods=[P1, P2, P3])\n\n    npts_red = [1, 1, 1]\n    npts = [n1, n2, n3]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[1, 1, 1], shifts=[1, 1, 1])\n    Cred=C.reduce_npts(npts_red, global_starts, global_ends, [1, 1, 1])\n    V = StencilVectorSpace(Cred, dtype=dtype)\n\n    assert V.dimension == 1\n    assert V.dtype == dtype\n    assert V.starts == (0, 0, 0)\n    assert V.ends == (n1-1, n2-1, n3-1)\n    assert V.parent_starts == (0, 0, 0)\n    assert V.parent_ends == (n1-1, n2-1, n3-1)\n# ===============================================================================\n\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [2, 9])\n@pytest.mark.parametrize('n2', [2, 7])\n\ndef test_stencil_vector_space_2D_serial_zeros(dtype, n1, n2, p1=1, p2=1, P1=True, P2=False):\n    D = DomainDecomposition([n1, n2], periods=[P1, P2])\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n    V = StencilVectorSpace(C, dtype=dtype)\n    x = V.zeros()\n\n    assert x.space is V\n    assert x.dtype == dtype\n    assert x.starts == (0, 0)\n    assert x.ends   == (n1-1, n2-1)\n    assert x._data.shape == (n1+2*p1, n2+2*p2)\n    assert x.pads == (p1, p2)\n    assert x._data.dtype == dtype\n    assert np.array_equal(x._data, np.zeros((n1+2*p1, n2+2*p2), dtype=dtype))\n\n\n# TODO : test for set_interface\n\n\n# ===============================================================================\n# PARALLEL TESTS\n# ===============================================================================\n\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 7])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('P1', [True, False])\n@pytest.mark.parametrize('s1', [1, 2])\n@pytest.mark.parallel\n\ndef test_stencil_vector_space_1d_serial_init(dtype, n1, p1, P1, s1):\n\n    from mpi4py import MPI\n\n    comm = MPI.COMM_WORLD\n    D = DomainDecomposition([n1], periods=[P1], comm=comm)\n\n    npts = [n1]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1], shifts=[s1])\n    V = StencilVectorSpace(C, dtype=dtype)\n\n    assert V.dimension == n1\n    assert V.dtype == dtype\n    assert V.mpi_type == find_mpi_type(dtype)\n    assert V.shape == (n1 + 2 * p1*s1,)\n    assert V.parallel\n    assert V.cart == C\n    assert V.npts == (n1,)\n    assert V.starts == (0,)\n    assert V.ends == (n1 - 1,)\n    assert V.parent_starts == (None,)\n    assert V.parent_ends == (None,)\n    assert V.pads == (p1,)\n    assert V.periods == (P1,)\n    assert V.shifts == (s1,)\n    assert V.ndim == 1\n    assert V.interfaces == type(type.__dict__)({})\n# ===============================================================================\n\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 7])\n@pytest.mark.parametrize('n2', [1, 5])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('p2', [1, 2])\n@pytest.mark.parametrize('P1', [True, False])\n@pytest.mark.parametrize('P2', [True, False])\n@pytest.mark.parametrize('s1', [1, 2])\n@pytest.mark.parametrize('s2', [1, 2])\n@pytest.mark.parallel\n\ndef test_stencil_vector_space_2d_serial_init(dtype, n1, n2, p1, p2, P1, P2, s1, s2):\n\n    from mpi4py import MPI\n\n    comm = MPI.COMM_WORLD\n    D = DomainDecomposition([n1, n2], periods=[P1, P2], comm=comm)\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])\n    V = StencilVectorSpace(C, dtype=dtype)\n\n    assert V.dimension == n1 * n2\n    assert V.dtype == dtype\n    assert V.mpi_type == find_mpi_type(dtype)\n    assert V.shape == ((n1 + 2 * p1*s1), (n2 + 2 * p2*s2))\n    assert V.parallel\n    assert V.cart == C\n    assert V.npts == (n1, n2)\n    assert V.starts == (0, 0)\n    assert V.ends == (n1 - 1, n2 - 1)\n    assert V.parent_starts == (None, None)\n    assert V.parent_ends == (None, None)\n    assert V.pads == (p1, p2)\n    assert V.periods == (P1,P2)\n    assert V.shifts == (s1, s2)\n    assert V.ndim == 2\n    assert V.interfaces == type(type.__dict__)({})\n# ===============================================================================\n\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [1, 9])\n@pytest.mark.parametrize('n2', [1, 7])\n@pytest.mark.parametrize('n3', [1, 5])\n@pytest.mark.parametrize('p1', [1, 2])\n@pytest.mark.parametrize('p2', [1, 2])\n@pytest.mark.parametrize('p3', [1, 2])\n@pytest.mark.parametrize('P1', [True, False])\n@pytest.mark.parametrize('P2', [True, False])\n@pytest.mark.parametrize('P3', [True, False])\n@pytest.mark.parametrize('s1', [1, 2])\n@pytest.mark.parametrize('s2', [1, 2])\n@pytest.mark.parametrize('s3', [1, 2])\n@pytest.mark.parallel\n\ndef test_stencil_vector_space_3d_serial_init(dtype, n1, n2, n3, p1, p2, p3, P1, P2, P3, s1, s2, s3):\n\n    from mpi4py import MPI\n\n    comm = MPI.COMM_WORLD\n    D = DomainDecomposition([n1, n2, n3], periods=[P1, P2, P3], comm=comm)\n\n    npts = [n1,n2, n3]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2, p3], shifts=[s1, s2, s3])\n    V = StencilVectorSpace(C, dtype=dtype)\n\n    assert V.dimension == n1*n2*n3\n    assert V.dtype == dtype\n    assert V.mpi_type == find_mpi_type(dtype)\n    assert V.shape == (n1 + 2 * p1*s1, n2 + 2 * p2*s2, n3 + 2 * p3*s3)\n    assert V.parallel\n    assert V.cart == C\n    assert V.npts == (n1, n2, n3)\n    assert V.starts == (0, 0, 0)\n    assert V.ends == (n1 - 1, n2 - 1, n3 - 1)\n    assert V.parent_starts == (None, None, None)\n    assert V.parent_ends == (None, None, None)\n    assert V.pads == (p1, p2, p3)\n    assert V.periods == (P1, P2, P3)\n    assert V.shifts == (s1, s2, s3)\n    assert V.ndim == 3\n    assert V.interfaces == type(type.__dict__)({})\n# ===============================================================================\n\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [2, 9])\n@pytest.mark.parametrize('n2', [2, 7])\n@pytest.mark.parametrize('n3', [2, 5])\n@pytest.mark.parallel\n\ndef test_stencil_vector_space_3D_serial_parent(dtype, n1, n2, n3, P1=True, P2=False, P3=True):\n\n    from mpi4py import MPI\n\n    comm = MPI.COMM_WORLD\n    D = DomainDecomposition([n1, n2, n3], periods=[P1, P2, P3], comm=comm)\n\n    npts_red = [1, 1, 1]\n    npts = [n1, n2, n3]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[1, 1, 1], shifts=[1, 1, 1])\n    Cred=C.reduce_npts(npts_red, global_starts, global_ends, [1, 1, 1])\n    V = StencilVectorSpace(Cred, dtype=dtype)\n\n    assert V.dimension == 1\n    assert V.dtype == dtype\n    assert V.starts == (0, 0, 0)\n    assert V.ends == (n1-1, n2-1, n3-1)\n    assert V.parent_starts == (0, 0, 0)\n    assert V.parent_ends == (n1-1, n2-1, n3-1)\n# ===============================================================================\n\n@pytest.mark.parametrize('dtype', [float, complex])\n@pytest.mark.parametrize('n1', [2, 9])\n@pytest.mark.parametrize('n2', [2, 7])\n@pytest.mark.parallel\n\ndef test_stencil_vector_space_2D_serial_zeros(dtype, n1, n2, p1=1, p2=1, P1=True, P2=False):\n\n    from mpi4py import MPI\n\n    comm = MPI.COMM_WORLD\n    D = DomainDecomposition([n1, n2], periods=[P1, P2], comm=comm)\n\n    npts = [n1, n2]\n    global_starts, global_ends = compute_global_starts_ends(D, npts)\n\n    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])\n    V = StencilVectorSpace(C, dtype=dtype)\n    x = V.zeros()\n\n    assert isinstance(x, StencilVector )\n    assert x.space is V\n    assert x.dtype == dtype\n    assert x.starts == (0, 0)\n    assert x.ends   == (n1-1, n2-1)\n    assert x._data.shape == (n1+2*p1, n2+2*p2)\n    assert x.pads == (p1, p2)\n    assert x._data.dtype == dtype\n    assert np.array_equal(x._data, np.zeros((n1+2*p1, n2+2*p2), dtype=dtype))\n\n\n# TODO : test for set_interface\n
===================================================================
diff --git a/psydac/linalg/tests/test_stencil_vector_space.py b/psydac/linalg/tests/test_stencil_vector_space.py
--- a/psydac/linalg/tests/test_stencil_vector_space.py	
+++ b/psydac/linalg/tests/test_stencil_vector_space.py	
@@ -29,10 +29,10 @@
 @pytest.mark.parametrize('dtype', [float, complex])
 @pytest.mark.parametrize('n1', [1, 7])
 @pytest.mark.parametrize('p1', [1, 2])
-@pytest.mark.parametrize('P1', [True, False])
 @pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('P1', [True, False])
 
-def test_stencil_vector_space_1d_serial_init(dtype, n1, p1, P1, s1):
+def test_stencil_vector_space_1d_serial_init(dtype, n1, p1, s1, P1):
     D = DomainDecomposition([n1], periods=[P1])
 
     npts = [n1]
@@ -64,12 +64,12 @@
 @pytest.mark.parametrize('n2', [1, 5])
 @pytest.mark.parametrize('p1', [1, 2])
 @pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
 @pytest.mark.parametrize('P1', [True, False])
 @pytest.mark.parametrize('P2', [True, False])
-@pytest.mark.parametrize('s1', [1, 2])
-@pytest.mark.parametrize('s2', [1, 2])
 
-def test_stencil_vector_space_2d_serial_init(dtype, n1, n2, p1, p2, P1, P2, s1, s2):
+def test_stencil_vector_space_2d_serial_init(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
     D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     npts = [n1, n2]
@@ -103,14 +103,14 @@
 @pytest.mark.parametrize('p1', [1, 2])
 @pytest.mark.parametrize('p2', [1, 2])
 @pytest.mark.parametrize('p3', [1, 2])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+@pytest.mark.parametrize('s3', [1, 2])
 @pytest.mark.parametrize('P1', [True, False])
 @pytest.mark.parametrize('P2', [True, False])
 @pytest.mark.parametrize('P3', [True, False])
-@pytest.mark.parametrize('s1', [1, 2])
-@pytest.mark.parametrize('s2', [1, 2])
-@pytest.mark.parametrize('s3', [1, 2])
 
-def test_stencil_vector_space_3d_serial_init(dtype, n1, n2, n3, p1, p2, p3, P1, P2, P3, s1, s2, s3):
+def test_stencil_vector_space_3d_serial_init(dtype, n1, n2, n3, p1, p2, p3, s1, s2, s3, P1, P2, P3):
     D = DomainDecomposition([n1,n2,n3], periods=[P1, P2, P3])
 
     npts = [n1,n2, n3]
@@ -164,14 +164,18 @@
 @pytest.mark.parametrize('dtype', [float, complex])
 @pytest.mark.parametrize('n1', [2, 9])
 @pytest.mark.parametrize('n2', [2, 7])
+@pytest.mark.parametrize('p1', [1, 2])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
 
-def test_stencil_vector_space_2D_serial_zeros(dtype, n1, n2, p1=1, p2=1, P1=True, P2=False):
+def test_stencil_vector_space_2D_serial_zeros(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
     D = DomainDecomposition([n1, n2], periods=[P1, P2])
 
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
     V = StencilVectorSpace(C, dtype=dtype)
     x = V.zeros()
 
@@ -179,13 +183,69 @@
     assert x.dtype == dtype
     assert x.starts == (0, 0)
     assert x.ends   == (n1-1, n2-1)
-    assert x._data.shape == (n1+2*p1, n2+2*p2)
+    assert x._data.shape == (n1+2*p1*s1, n2+2*p2*s2)
     assert x.pads == (p1, p2)
     assert x._data.dtype == dtype
-    assert np.array_equal(x._data, np.zeros((n1+2*p1, n2+2*p2), dtype=dtype))
-
-
-# TODO : test for set_interface
+    assert np.array_equal(x._data, np.zeros((n1+2*p1*s1, n2+2*p2*s2), dtype=dtype))
+# ===============================================================================
+
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [5, 9])
+@pytest.mark.parametrize('n2', [5, 7])
+@pytest.mark.parametrize('p1', [1, 2])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+@pytest.mark.parametrize('axis', [0, 1])
+@pytest.mark.parametrize('ext', [-1, 1])
+
+def test_stencil_vector_space_2D_serial_set_interface(dtype, n1, n2, p1, p2, s1, s2, axis, ext, P1=True, P2=False):
+    D = DomainDecomposition([n1, n2], periods=[P1, P2])
+
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts)
+
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
+    V = StencilVectorSpace(C, dtype=dtype)
+    x = V.zeros()
+
+    V.set_interface(axis, ext, C)
+
+    V_inter=V.interfaces[axis, ext]
+
+    assert isinstance(V_inter, StencilVectorSpace)
+    assert V_inter.dimension == n1 * n2
+    assert V_inter.dtype == dtype
+    assert V_inter.mpi_type == find_mpi_type(dtype)
+    assert not V_inter.parallel
+    assert isinstance(V_inter.cart, CartDecomposition)
+    assert V_inter.npts == (n1, n2)
+    assert V_inter.parent_starts == (None, None)
+    assert V_inter.parent_ends == (None, None)
+    assert V_inter.pads == (p1, p2)
+    assert V_inter.periods == (P1, P2)
+    assert V_inter.shifts == (s1, s2)
+    assert V_inter.ndim == 2
+    assert V_inter.interfaces == type(type.__dict__)({})
+
+    if axis == 0:
+        assert V_inter.shape == ((p1+1 + 2 * p1 * s1), (n2 + 2 * p2 * s2))
+        if ext == 1:
+            assert V_inter.starts == (n1-1-p1, 0)
+            assert V_inter.ends == (n1-1, n2-1)
+        else:
+            assert V_inter.starts == (0, 0)
+            assert V_inter.ends == (p1, n2-1)
+    else:
+        assert V_inter.shape == ((n1 + 2 * p1 * s1), p2+1+2*p2*s2)
+        if ext == 1:
+            assert V_inter.starts == (0, n2-1-p2)
+            assert V_inter.ends == (n1-1, n2-1)
+        else:
+            assert V_inter.starts == (0, 0)
+            assert V_inter.ends == (n1-1, p2)
+
+
 
 
 # ===============================================================================
@@ -195,11 +255,11 @@
 @pytest.mark.parametrize('dtype', [float, complex])
 @pytest.mark.parametrize('n1', [1, 7])
 @pytest.mark.parametrize('p1', [1, 2])
-@pytest.mark.parametrize('P1', [True, False])
 @pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('P1', [True, False])
 @pytest.mark.parallel
 
-def test_stencil_vector_space_1d_serial_init(dtype, n1, p1, P1, s1):
+def test_stencil_vector_space_1d_parallel_init(dtype, n1, p1, s1, P1):
 
     from mpi4py import MPI
 
@@ -235,13 +295,13 @@
 @pytest.mark.parametrize('n2', [1, 5])
 @pytest.mark.parametrize('p1', [1, 2])
 @pytest.mark.parametrize('p2', [1, 2])
-@pytest.mark.parametrize('P1', [True, False])
-@pytest.mark.parametrize('P2', [True, False])
 @pytest.mark.parametrize('s1', [1, 2])
 @pytest.mark.parametrize('s2', [1, 2])
+@pytest.mark.parametrize('P1', [True, False])
+@pytest.mark.parametrize('P2', [True, False])
 @pytest.mark.parallel
 
-def test_stencil_vector_space_2d_serial_init(dtype, n1, n2, p1, p2, P1, P2, s1, s2):
+def test_stencil_vector_space_2d_parallel_init(dtype, n1, n2, p1, p2, s1, s2, P1, P2):
 
     from mpi4py import MPI
 
@@ -279,15 +339,15 @@
 @pytest.mark.parametrize('p1', [1, 2])
 @pytest.mark.parametrize('p2', [1, 2])
 @pytest.mark.parametrize('p3', [1, 2])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+@pytest.mark.parametrize('s3', [1, 2])
 @pytest.mark.parametrize('P1', [True, False])
 @pytest.mark.parametrize('P2', [True, False])
 @pytest.mark.parametrize('P3', [True, False])
-@pytest.mark.parametrize('s1', [1, 2])
-@pytest.mark.parametrize('s2', [1, 2])
-@pytest.mark.parametrize('s3', [1, 2])
 @pytest.mark.parallel
 
-def test_stencil_vector_space_3d_serial_init(dtype, n1, n2, n3, p1, p2, p3, P1, P2, P3, s1, s2, s3):
+def test_stencil_vector_space_3d_parallel_init(dtype, n1, n2, n3, p1, p2, p3, s1, s2, s3, P1, P2, P3):
 
     from mpi4py import MPI
 
@@ -324,7 +384,7 @@
 @pytest.mark.parametrize('n3', [2, 5])
 @pytest.mark.parallel
 
-def test_stencil_vector_space_3D_serial_parent(dtype, n1, n2, n3, P1=True, P2=False, P3=True):
+def test_stencil_vector_space_3D_parallel_parent(dtype, n1, n2, n3, P1=True, P2=False, P3=True):
 
     from mpi4py import MPI
 
@@ -350,9 +410,13 @@
 @pytest.mark.parametrize('dtype', [float, complex])
 @pytest.mark.parametrize('n1', [2, 9])
 @pytest.mark.parametrize('n2', [2, 7])
+@pytest.mark.parametrize('p1', [1, 2])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
 @pytest.mark.parallel
 
-def test_stencil_vector_space_2D_serial_zeros(dtype, n1, n2, p1=1, p2=1, P1=True, P2=False):
+def test_stencil_vector_space_2D_parallel_zeros(dtype, n1, n2, p1, p2, s1, s2, P1=True, P2=False):
 
     from mpi4py import MPI
 
@@ -362,7 +426,7 @@
     npts = [n1, n2]
     global_starts, global_ends = compute_global_starts_ends(D, npts)
 
-    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[1, 1])
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
     V = StencilVectorSpace(C, dtype=dtype)
     x = V.zeros()
 
@@ -371,10 +435,82 @@
     assert x.dtype == dtype
     assert x.starts == (0, 0)
     assert x.ends   == (n1-1, n2-1)
-    assert x._data.shape == (n1+2*p1, n2+2*p2)
+    assert x._data.shape == (n1+2*p1*s1, n2+2*p2*s2)
     assert x.pads == (p1, p2)
     assert x._data.dtype == dtype
-    assert np.array_equal(x._data, np.zeros((n1+2*p1, n2+2*p2), dtype=dtype))
+    assert np.array_equal(x._data, np.zeros((n1+2*p1*s1, n2+2*p2*s2), dtype=dtype))
+
+# ===============================================================================
+
+@pytest.mark.parametrize('dtype', [float, complex])
+@pytest.mark.parametrize('n1', [1, 9])
+@pytest.mark.parametrize('n2', [1, 7])
+@pytest.mark.parametrize('p1', [1, 2])
+@pytest.mark.parametrize('p2', [1, 2])
+@pytest.mark.parametrize('s1', [1, 2])
+@pytest.mark.parametrize('s2', [1, 2])
+@pytest.mark.parametrize('axis', [0, 1])
+@pytest.mark.parametrize('ext', [-1, 1])
+@pytest.mark.parallel
+
+def test_stencil_vector_space_2D_parrallel_set_interface(dtype, n1, n2, p1, p2, s1, s2, axis, ext, P1=True, P2=False):
+    from mpi4py import MPI
+
+    comm = MPI.COMM_WORLD
+    D = DomainDecomposition([n1, n2], periods=[P1, P2], comm=comm)
+
+    npts = [n1, n2]
+    global_starts, global_ends = compute_global_starts_ends(D, npts)
+
+    C = CartDecomposition(D, npts, global_starts, global_ends, pads=[p1, p2], shifts=[s1, s2])
+
+    V = StencilVectorSpace(C, dtype=dtype)
+    x = V.zeros()
+
+    V.set_interface(axis, ext, C)
+
+    V_inter=V.interfaces[axis, ext]
+
+    assert isinstance(V_inter, StencilVectorSpace)
+    assert V_inter.dimension == n1 * n2
+    assert V_inter.dtype == dtype
+    assert V_inter.mpi_type == find_mpi_type(dtype)
+    assert V_inter.parallel
+    assert isinstance(V_inter.cart, CartDecomposition)
+    assert V_inter.npts == (n1, n2)
+    assert V_inter.parent_starts == (None, None)
+    assert V_inter.parent_ends == (None, None)
+    assert V_inter.pads == (p1, p2)
+    assert V_inter.periods == (P1, P2)
+    assert V_inter.shifts == (s1, s2)
+    assert V_inter.ndim == 2
+    assert V_inter.interfaces == type(type.__dict__)({})
 
+    if axis == 0:
+        assert V_inter.shape == ((p1+1 + 2 * p1 * s1), (n2 + 2 * p2 * s2))
+        if ext == 1:
+            assert V_inter.starts == (n1-1-p1, 0)
+            assert V_inter.ends == (n1-1, n2-1)
+        else:
+            assert V_inter.starts == (0, 0)
+            assert V_inter.ends == (p1, n2-1)
+    else:
+        assert V_inter.shape == ((n1 + 2 * p1 * s1), p2+1+2*p2*s2)
+        if ext == 1:
+            assert V_inter.starts == (0, n2-1-p2)
+            assert V_inter.ends == (n1-1, n2-1)
+        else:
+            assert V_inter.starts == (0, 0)
+            assert V_inter.ends == (n1-1, p2)
 
-# TODO : test for set_interface
+    assert V_inter.parent_starts == (None, None)
+    assert V_inter.parent_ends == (None, None)
+
+#TODO comment the code
+#===============================================================================
+# SCRIPT FUNCTIONALITY
+#===============================================================================
+if __name__ == "__main__":
+    import sys
+
+    pytest.main(sys.argv)
\ No newline at end of file
